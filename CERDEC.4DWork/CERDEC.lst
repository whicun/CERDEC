file C:\Users\ebenton\Documents\CERDEC TS\CERDEC.4dg

000001  000001  // ##################
000002  000002  // Headers
000003  000003  // ##################
000004  000004        
file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\Gen4-uLCD-70DT.fnc

000005  000005  #platform "Gen4-uLCD-70DT"
000006  000005  #platform "Gen4-uLCD-70DT"
000007  000008  */
000008  000009      #constant Gen4_ULCD_70DT_DIABLO16_GFX
000009  000009      #constant Gen4_ULCD_70DT_DIABLO16_GFX
000010  000010        
000011  000011      #IFNOT EXISTS DIABLO16_GFX2_FUNCTIONS
file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\Diablo16_Functions.fnc

000012  000012          #inherit "Diablo16_Functions.fnc"          // inherit the generic functions
000013  000012          #inherit "Diablo16_Functions.fnc"          // inherit the generic functions
000014  000001        
000015  000002  // Common inheritance for Diablo16 platforms
000016  000003        
000017  000004  //#constant ULCD_32PT_DIABLO16_GFX
000018  000005        
000019  000006        
000020  000007  // define the compiler dummy preambles
000021  000008  #constant LOCAL $//
000022  000008  #constant LOCAL $//
000023  000009  #constant EXTERN $ /**/
000024  000009  #constant EXTERN $ /**/
000025  000010        
000026  000011  #CONST
000027  000020  #END
000028  000021        
000029  000022  #CONST
000030  000038  #END
000031  000039        
000032  000040        
000033  000041        
000034  000042        
000035  000047  */
000036  000048        
000037  000049        
000038  000050  //------------------------------------------------------------------//
000039  000051  //     EVE  miscellaneous functions                                 //
000040  000052  //------------------------------------------------------------------//
000041  000053        
000042  000054  func to("device"), 0;                // output device redirection
000043  000055  // Syntax: to(outstream);
000044  000056  // Usage : to(APPEND); putstr("TWO ");
000045  000057  // Notes : outstream: A variable or constant specifying destination for putch, putstr, putnum and print functions.
000046  000058  //     :
000047  000059  //     : to() sends the printed output to destinations other than the screen. Normally, print just
000048  000060  //     : sends its output to the display in TEXT mode which is the default, however, the output from
000049  000061  //     : print can be sent to COM0, and MDA (media) 'streams'. The to(...) function can also stream
000050  000062  //     : to a memory array . Note that once the to(...) function has taken effect, the stream reverts
000051  000063  //     : back to the default stream which is TEXT as soon as putch, putstr, putnum or print has
000052  000064  //     : completed its action. The APPEND argument is used to send the printed output to the same
000053  000065  //     : place as the previous redirection. This is most useful for building string arrays, or adding
000054  000066  //     : sequential data to a media stream.
000055  000067  //     :
000056  000068  //     : Predefined Name Constant    putch(), putstr(), putnum(), print() redirection
000057  000069  //     : APPEND         0x0000      Output is directed to the same stream that was previously assigned. Output is
000058  000070  //     :                            appended to user memory if previous redirection was to an array.
000059  000071  //     : COM0           0xFF04      Output is redirected to the COM (serial) port.
000060  000072  //     : TEXT           0xFF08      Output is directed to the screen (default).
000061  000073  //     : MDA            0xFF10      Output is directed to the SD or FLASH media.
000062  000074  //     : I2C1           0xF820      Output is directed to the I2C1 port.
000063  000075  //     : memory pointer             Output is redirect to the memory pointer argument, eg to(myarray); print("HELLO");
000064  000076        
000065  000077  //------------------------------------------------------------------//
000066  000078  // to(..) redirection constants            //
000067  000079  //------------------------------------------------------------------//
000068  000080  #CONST
000069  000093  #END
000070  000094        
000071  000095        
000072  000096  func putch("char"), 0;                // write single char to current output device
000073  000097  // Syntax    : putch("char");
000074  000098  // Usage     : putch("A");
000075  000099  // Notes     : prints single characters to the current output stream, usually the
000076  000100  //           : display unless redirected with the ‘to’ redirection function.
000077  000101  //         : The arguments can be a variable, array element, expression or constant.
000078  000102        
000079  000103        
000080  000104  func putchXY("xpos", "ypos", "char"), 0;
000081  000105  // Syntax  : putchXY(x, y, '0x41'),
000082  000106  // Usage   : putchXY(100, 100, "HELLO");
000083  000107  // Notes   : Print a single character at position x, y.
000084  000108  //         : Char may be a constant or variable.
000085  000109  // Returns : nothing.
000086  000110        
000087  000111  func putstrXY("xpos", "ypos", "string"), 0;
000088  000112  // Syntax  : putstrXY(x, y, "string"),
000089  000113  // Usage   : putstrXY(100, 100, "HELLO");
000090  000114  // Notes   : Print a string at position x, y
000091  000115  //         : "String" may be a string constant, or pointer to a word aligned string.
000092  000116  // Returns : nothing.
000093  000117        
000094  000118        
000095  000119  func putstrCentred("xc", "yc", "string"), 0;
000096  000120  // Syntax  : putstrCentred(x, y, "string"),
000097  000121  // Usage   : putstrCentred(100, 100, "HELLO");
000098  000122  // Notes   : Print a string centred at position x, y
000099  000123  //         : "String" may be a string constant, or pointer to a word aligned string.
000100  000124  // Returns : nothing.
000101  000125        
000102  000126        
000103  000127  func pause("milliseconds"), 0;            // blocking delay
000104  000128  // Syntax: pause(milliseconds);
000105  000129  // Usage : pause(1000);                //pause for 1 second
000106  000130  // Notes : Pause for a number of milli second.Maximum delay could be 65535 milli seconds
000107  000131        
000108  000132        
000109  000133  func putnum("arg1","arg2"), 1;            // print number to current output device
000110  000134  // Syntax: putnum(format, value);
000111  000135  // Usage : var := putnum(HEX, val);
000112  000136  // Notes : prints a 16bit number in various formats to the current output stream, usually the display.
000113  000137  //     : Format: A constant that specifies the number format
000114  000138  //     : Value : The number to be printed
000115  000139  //     : (      DECIMAL   )    (   UNSIGNED DECIMAL )    (    HEX         )     (    BINARY          )
000116  000140  //     : DEC     DECZ     DECZB     UDEC     UDECZ     UDECZB     HEX     HEXZ     HEXZB     BIN     BINZ     BINZB
000117  000141  //     : DEC1 DEC1Z     DEC1ZB     UDEC1     UDEC1Z     UDEC1ZB HEX1     HEX1Z     HEX1ZB     BIN1     BIN1Z     BIN1ZB
000118  000142  //     : DEC2 DEC2Z     DEC2ZB     UDEC2     UDEC2Z     UDEC2ZB HEX2     HEX2Z     HEX1ZB     BIN2     BIN2Z     BIN2ZB
000119  000143  //     : DEC3 DEC3Z     DEC3ZB     UDEC3     UDEC3Z     UDEC3ZB HEX3     HEX3Z     HEX1ZB     BIN3     BIN3Z     BIN3ZB
000120  000144  //     : DEC4 DEC4Z     DEC4ZB     UDEC4     UDEC4Z     UDEC4ZB HEX4     HEX4Z     HEX1ZB     BIN4     BIN4Z     BIN4ZB
000121  000145  //     : DEC5 DEC5Z     DEC5ZB     UDEC5     UDEC5Z     UDEC5ZB             BIN5     BIN5Z     BIN5ZB
000122  000146  //     :                                     BIN6     BIN6Z     BIN6ZB
000123  000147  //     :                                     BIN7     BIN7Z     BIN7ZB
000124  000148  //     :                                     BIN8     BIN8Z     BIN8ZB
000125  000149  //     :                                     BIN9     BIN9Z     BIN9ZB
000126  000150  //     :                                     BIN10     BIN10Z     BIN10ZB
000127  000151  //     :                                     BIN11     BIN11Z     BIN11ZB
000128  000152  //     :                                     BIN12     BIN12Z     BIN12ZB
000129  000153  //     :                                     BIN13     BIN13Z     BIN13ZB
000130  000154  //     :                                     BIN14     BIN14Z     BIN14ZB
000131  000155  //     :                                     BIN15     BIN15Z     BIN15ZB
000132  000156  //     :                                     BIN16     BIN16Z     BIN16ZB
000133  000157  //     : field: Returns the the default width of the numeric field (digit count), usually ignored.
000134  000158  //     : bit 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
000135  000159  //     : | | | | \___ ___/ \__ __/ \_____ _____/
000136  000160  //     : | | | | V V V
000137  000161  //     : | | | | | | |
000138  000162  //     : | | | | | |
000139  000163  //     : | | | | (nb 0 = 16) | |____BASE (usually 2,10 or 16)
000140  000164  //     : | | | | digit count |
000141  000165  //     : | | | | |___reserved (not used on GOLDELOX)
000142  000166  //     : | | | |
000143  000167  //     : | | | |
000144  000168  //     : | | | |
000145  000169  //     : | | | |
000146  000170  //     : | | | |
000147  000171  //     : | | | |______ 1 = leading zeros included
000148  000172  //     : | | | 0 = leading zeros suppressed
000149  000173  //     : | | |
000150  000174  //     : | | |
000151  000175  //     : | | |_______ 1 = leading zero blanking
000152  000176  //     : | |
000153  000177  //     : | |_____ sign bit (0 = signed, 1 = unsigned)
000154  000178  //     : |
000155  000179  //     : |______ 1 = space before unsigned number
000156  000180        
000157  000181        
000158  000182  func __translate("arg1","arg2","arg3","arg4"), 1; // list translator (*** internal compiler use only, not usable)
000159  000183        
000160  000184        
000161  000185  func putstr("string"), 1;                         // print var (word) aligned string to current output device
000162  000186  // Syntax: putstr(pointer);
000163  000187  // Usage : putstr("HELLO\n");
000164  000188  // Notes : putstr prints a string to the current output stream, usually the display. The argument can be
000165  000189  //       : a string constant, a word aligned pointer to a string, a pointer to an array, or a pointer to
000166  000190  //       : a data statement. Note that string constants and data statement pointers are byte aligned.
000167  000191  //       : The output of putstr can be redirected to the communications port, the media, or memory
000168  000192  //       : using the to(...); function.
000169  000193  //       : A string constant is automatically terminated with a zero.
000170  000194  //       : A string in a data statement is not automatically terminated with a zero.
000171  000195  //       : All variables in 4DGL are 16bit, if an array is used for holding 8 bit characters, each array
000172  000196  //       : element packs 1 or 2 characters.
000173  000197        
000174  000198        
000175  000199  func strlen("varAddress"), 1;                   // return length of a var (word) aligned string in character units
000176  000200  // Syntax: strlen("varAddress);
000177  000201  // Usage : strlen("HELLO\n");
000178  000202  // Notes : gives the length of a string that is packed into regular var array
000179  000203  //       : Use str_Length(ptr)  for string pointer mode
000180  000204        
000181  000205        
000182  000206  func charwidth("char"), 1;
000183  000207  // Syntax  : charwidth(char);
000184  000208  // Usage   : wid := charwidth('W');
000185  000209  // Notes   : calculates width of a character in pixel units.
000186  000210  //         : 'char' may be a constant or variable.
000187  000211  // Returns : Width of character in pixel units.
000188  000212        
000189  000213        
000190  000214  func charheight("char"), 1;
000191  000215  // Syntax  : charheight(char);
000192  000216  // Usage   : ht := charheight('0x41');
000193  000217  // Notes   : Calculates height of a character in pixel units.
000194  000218  //         : 'char' may be a constant or variable.
000195  000219  // Returns : Height of character in pixel units.
000196  000220        
000197  000221        
000198  000222  func strwidth("pointer"), 1;
000199  000223  // Syntax  : strwidth(ptr);
000200  000224  // Usage   : x := strwidth("HELLO");
000201  000225  // Notes   : returns width of a string in pixel units.
000202  000226  //         : 'pointer' may be a constant or pointer to word aligned variable
000203  000227  // Returns : Width of string in pixel units, can be multi line.
000204  000228        
000205  000229        
000206  000230  func strheight(), 1;
000207  000231  // Syntax  : strheight();
000208  000232  // Usage   : h := strheight();
000209  000233  // Notes   : calculates height of a string in pixel units (after a call to strwidth );
000210  000234  //         : pointer may be a constant or pointer to word aligned variable
000211  000235  // Returns : Height of string in pixel units, can be multi line.
000212  000236        
000213  000237        
000214  000238  func unicode_page("charbeg","charend","charoffset"), 1;
000215  000239  // Syntax: unicode_page("charbeg","charend","charoffset");
000216  000240  // Usage : eg:  F_Traditional_0x20_0xFF
000217  000241  // Notes : After selecting a unicode image control with txt_FontID,
000218  000242  //       : this function is called to set the required font within the
000219  000243  //       : unicode set. The file "Unicode.inc" contains wrappers for
000220  000244  //       : this function, and it is not normally called directly.
000221  000245  //       : Returns count of characters in the set.
000222  000246  //       : Refer to "Unicode.inc" for further information.
000223  000247        
000224  000248        
000225  000249  //------------------------------------------------------------------//
000226  000250  //          Text Related Functions                                  //
000227  000251  //------------------------------------------------------------------//
000228  000252        
000229  000253  func txt_MoveCursor("line", "column"), 0;
000230  000254  // Syntax: txt_SetCursor(line, column);
000231  000255  // Usage : txt_SetCursor(arg1, arg2);
000232  000256  // Notes : Moves the text Cursor to a new screen position set by
000233  000257  //       : line,column parameters.
000234  000258        
000235  000259  func txt_Set("function", "value"), 0;
000236  000260  // Syntax: txt_Set(function, value);
000237  000261  // Usage : txt_Set(arg1, arg2);
000238  000262  // Returns : Original value before the change
000239  000263  // Notes : Sets various text related parameters used by other functions
000240  000264  //       : This allows the features to be set programatically with a
000241  000265  //       : single function call.It is strongly recommended to use the
000242  000266  //       : pre-defined constants rather than the mode numbers.
000243  000267  //       : NB:- It is often required to be able to set text
000244  000268  //       : functions with a single function call for graphics engine
000245  000269  //       : related functions, however, there is a complete set of single parameter
000246  000270  //       : shortcut functions that have exactly the same function as
000247  000271  //       : each of the txt_Set modes and saves 1 parameter / uses less memory
000248  000272  //       :
000249  000273  //       : txt_Set(TEXT_COLOUR, colour);        // function 0, TEXT_COLOUR, default colour = LIME
000250  000274  //       : txt_Set(TEXT_HIGHLIGHT, colour);     // function 1, TEXT_HIGHLIGHT)
000251  000275  //       : txt_Set(FONT_ID, fontNumer);         // function 2, FONT_ID)
000252  000276  //       : txt_Set(TEXT_WIDTH, multiplier);     // function 3, TEXT_WIDTH)
000253  000277  //       : txt_Set(TEXT_HEIGHT, multiplier);    // function 4, TEXT_HEIGHT)
000254  000278  //       : txt_Set(TEXT_XGAP, pixels);          // function 5, TEXT_XGAP)
000255  000279  //       : txt_Set(TEXT_YGAP, pixels);          // function 6, TEXT_YGAP)
000256  000280  //       : txt_Set(TEXT_PRINTDELAY, msecs);     // function 7, TEXT_PRINTDELAY)
000257  000281  //       : txt_Set(TEXT_OPACITY, value);        // function 8, TEXT_OPACITY)
000258  000282  //       : txt_Set(TEXT_BOLD, boldness);        // function 9, TEXT_BOLD)
000259  000283  //       : txt_Set(TEXT_ITALIC, slope);         // function 10, TEXT_ITALIC)
000260  000284  //       : txt_Set(TEXT_INVERSE, onoff);        // function 11, TEXT_INVERSE)
000261  000285  //       : txt_Set(TEXT_UNDERLINED, onoff);     // function 12, TEXT_UNDERLINED)
000262  000286  //       : txt_Set(TEXT_ATTRIBUTES, combine);   // function 13, TEXT_ATTRIBUTES)
000263  000287  //       : txt_Set(TEXT_WRAP, column);          // function 14, TEXT_WRAP)
000264  000288  //       : txt_Set(TEXT_ANGLE , degrees);       // function 15, TEXT_ANGLE)
000265  000289  //       :
000266  000290  //       : txt_Set(TEXT_COLOUR, colour);
000267  000291  //       : mode = TEXT_COLOUR (function 0)
000268  000292  //       : txt_Set(TEXT_COLOUR, value);
000269  000293  //       : value = 0 to 0xFFFF, Black to White
000270  000294  //       : Sets the Text colour for the display
000271  000295  //       : Default = LIME.
000272  000296  //       :
000273  000297  //       : mode = TEXT_HIGHLIGHT (function 1)
000274  000298  //       : txt_Set(TEXT_HIGHLIGHT, value);
000275  000299  //       : value = 0 to 0xFFFF, Black to White
000276  000300  //       : Sets the Text background colour for the display. Effective
000277  000301  //       : when text mode is Opaque.
000278  000302  //       : Default = BLACK.
000279  000303  //       :
000280  000304  //       : mode = FONT_ID (function 2)
000281  000305  //       : txt_Set(FONT_ID, value);
000282  000306  //       : value = FONT1 to FONT11 for internal fonts
000283  000307  //       : else this value is the name of a font included
000284  000308  //       : in a users program in a data statement.
000285  000309  //       : Default = FONT SIZE 3.
000286  000310  //       :
000287  000311  //       : mode = TEXT_WIDTH  (function 3)
000288  000312  //       : txt_Set(TEXT_WIDTH, value);
000289  000313  //       : value = 1 to 16
000290  000314  //       : Sets the Text Width multiplier
000291  000315  //       : text will be printed magnified horizontally
000292  000316  //       : by this factor, Default = 1.
000293  000317  //       :
000294  000318  //       : mode = TEXT_HEIGHT  (function 4)
000295  000319  //       : txt_Set(TEXT_HEIGHT, value);
000296  000320  //       : value = 1 to 16
000297  000321  //       : Sets the Text Height multiplier
000298  000322  //       : text will be printed magnified vertically
000299  000323  //       : by this factor, Default = 1.
000300  000324  //       :
000301  000325  //       : mode = TEXT_XGAP  (function 5)
000302  000326  //       : txt_Set(TEXT_XGAP, value);
000303  000327  //       : value = 1 to 32
000304  000328  //       : Sets the horizontal gap between characters
000305  000329  //       : The gap is in pixel units, Default = 0
000306  000330  //       :
000307  000331  //       : mode = TEXT_YGAP  (function 6)
000308  000332  //       : txt_Set(TEXT_YGAP, value);
000309  000333  //       : value = 1 to 32
000310  000334  //       : Sets the vertical gap below characters
000311  000335  //       : The gap is in pixel units, Default = 0
000312  000336  //       :
000313  000337  //       : mode = TEXT_PRINTDELAY  (function 7) DEPRECATED
000314  000338  //       : txt_Set(TEXT_PRINTDELAY, value);
000315  000339  //       : value = 0 to 255
000316  000340  //       : Sets the delay time (in ms) during character
000317  000341  //       : printing to give a 'teletype' like effect.
000318  000342  //       : Often used to attract attention to a string
000319  000343  //       : being printed which can often be missed if
000320  000344  //       : just suddenly appearing or changing.
000321  000345  //       : Default = 0 ms.
000322  000346  //       :
000323  000347  //       : mode = TEXT_OPACITY (function 8)
000324  000348  //       : txt_Set(TEXT_OPACITY, value);
000325  000349  //       : value = TRANSPARENT (0) = Text Trasparent
000326  000350  //       : value = OPAQUE (1) = Text Opaque
000327  000351  //       : Sets the Opacity/Transparency of the text
000328  000352  //       : Default = 0 or TRANSPARENT
000329  000353  //       :
000330  000354  //       : mode = TEXT_BOLD (function 9)
000331  000355  //       : txt_Set(TEXT_BOLD, value);
000332  000356  //       : value = dont care
000333  000357  //       : Sets Bold Text mode for the next string or char
000334  000358  //       : The feature automatically resets after printing
000335  000359  //       : using putstr or print has completed
000336  000360  //       :
000337  000361  //       : mode = TEXT_ITALIC (function10)
000338  000362  //       : txt_Set(TEXT_ITALIC, value);
000339  000363  //       : value = dont care
000340  000364  //       : Sets Italic Text mode for the next string or char
000341  000365  //       : The feature automatically resets after printing
000342  000366  //       : using putstr or print has completed
000343  000367        
000344  000368  //       : mode = TEXT_INVERSE (function 11)
000345  000369  //       : txt_Set(TEXT_INVERSE, value);
000346  000370  //       : value = dont care
000347  000371  //       : Sets Inverse Text mode for the next string or char
000348  000372  //       : The feature automatically resets after printing
000349  000373  //       : using putstr or print has completed
000350  000374  //       :
000351  000375  //       : mode = TEXT_UNDERLINED (function 12)
000352  000376  //       : txt_Set(TEXT_UNDERLINED, value);
000353  000377  //       : value = dont care
000354  000378  //       : Sets Underlined Text mode for the next string or char
000355  000379  //       : The feature automatically resets after printing
000356  000380  //       : using putstr or print has completed
000357  000381  //       :
000358  000382  //       : mode = TEXT_ATTRIBUTES (function 13)
000359  000383  //       : txt_Set(TEXT_ATTRIBUTES, value);
000360  000384  //       : value = bits are defined as:
000361  000385  //       :  BOLD        16          // TEXT_ATTRIBUTES bold text (auto reset)
000362  000386  //       :  ITALIC      32          // TEXT_ATTRIBUTES italic text (auto reset)
000363  000387  //       :  INVERSE     64          // TEXT_ATTRIBUTES inverse text (auto reset)
000364  000388  //       :  UNDERLINED  128         // TEXT_ATTRIBUTES underlined text (auto reset)
000365  000389  //       : Allows a combination of text attributes to be defined together
000366  000390  //       : by 'or'ing the bits together.
000367  000391  //       : Example: txt_Set(TEXT_ATTRIBUTES, BOLD | INVERSE); // bold + inverse
000368  000392  //       : The feature automatically resets after printing
000369  000393  //       : using putstr or print has completed.
000370  000394  //       : Bits 0-3 and 8-15 are reserved for future attributes.
000371  000395  //       :
000372  000396  //       : mode = TEXT_WRAP (function 14)
000373  000397  //       : txt_Set(TEXT_WRAP , value);
000374  000398  //       : Sets the position where text wrap will occur
000375  000399  //       : The feature automatically resets when screen
000376  000400  //       : mode is changed. If the value is set to 0,
000377  000401  //       : text wrap is turned off.
000378  000402  //       : of the current screen. Default value is 0
000379  000403  // Notes : The value is in pixel units.
000380  000404  //       :
000381  000405  //       : mode = TEXT_ANGLE (function 15)
000382  000406  //       : txt_Set(TEXT_ANGLE , value);
000383  000407  //       : Sets the angle of plotted fonts
000384  000408  // Notes : The angle is in degrees.
000385  000409  //       :
000386  000410        
000387  000411  //------------------------------------------------------------------------------
000388  000412  //txt_Set() related constants
000389  000413  //------------------------------------------------------------------------------
000390  000414  #CONST
000391  000433  #END
000392  000434        
000393  000435  //------------------------------------------------------------------------------
000394  000436  //txt_Set() related arguments
000395  000437  //------------------------------------------------------------------------------
000396  000438  #CONST
000397  000464  #END
000398  000465        
000399  000466        
000400  000467  //=====================================================//
000401  000468  // Single parameter short-cuts                         //
000402  000469  // for the txt_Set functions                           //
000403  000470  // These functions return the existing value before    //
000404  000471  // the change is made.                                 //
000405  000472  //=====================================================//
000406  000473  func txt_FGcolour("colour"), 1;             // 0  text foreground colour
000407  000474  func txt_BGcolour("colour"), 1;             // 1  text background colour
000408  000475  func txt_FontID("id"), 1;                   // 2  text font ID (0 = system font)
000409  000476  func txt_Width("multiplier"), 1;            // 3  text width multiplier
000410  000477  func txt_Height("multiplier"), 1;           // 4  text height multiplier
000411  000478  func txt_Xgap("pixelcount"), 1;             // 5  text gap between characters
000412  000479  func txt_Ygap("pixelcount"), 1;             // 6  text gap between lines
000413  000480  func txt_Delay("millisecs"), 1;             // 7  text printing delay factor
000414  000481  func txt_Opacity("mode"), 1;                // 8  text OPAQUE or TRANSPARENT
000415  000482  func txt_Bold("mode"), 1;                   // 9  text bold ON/OFF
000416  000483  func txt_Italic("mode"), 1;                 // 10 text italic ON/OFF
000417  000484  func txt_Inverse("mode"), 1;                // 11 text inverse ON/OFF
000418  000485  func txt_Underline("mode"), 1;              // 12 text underline ON/OFF
000419  000486  func txt_Attributes("value"), 1;            // 13 text combined bold|italic|inverse|underline
000420  000487  func txt_Wrap("value"), 1;                  // 14 text set text wrap position
000421  000488  func txt_Angle("value"), 1;                 // 15 text set angle of plotted font
000422  000489        
000423  000490        
000424  000491        
000425  000492  //------------------------------------------------------------------//
000426  000493  // Memory Access Functions                                          //
000427  000494  //------------------------------------------------------------------//
000428  000495                                                  //
000429  000496  func peekW("address"), 1;                       // read a word from system memory
000430  000497  func pokeW("address", "wordvalue"), 0;          // write a word to system memory
000431  000498  // refer to address map of internal variables   //
000432  000499        
000433  000500        
000434  000501  //------------------------------------------------------------------//
000435  000502  //        CTYPE Function Prototypes
000436  000503  //------------------------------------------------------------------//
000437  000504        
000438  000505  func isdigit("char"), 1;    //Returns a 1 if the character is an ascii digit else returns a 0
000439  000506  // Syntax: isdigit("char");
000440  000507  // Usage : Var := isdigit(ch);
000441  000508  // Notes : char specifies the ascii character for the test
000442  000509  //     : 0 : char is not an ascii digit.
000443  000510  //     : 1 : char is an ascii digit..
000444  000511  //     : Valid range is "0123456789"
000445  000512        
000446  000513  func isxdigit("char"), 1;    //Returns a 1 if the character is an ascii hexadecimal digit else returns a 0
000447  000514  // Syntax: isxdigit("char");
000448  000515  // Usage : Var := isxdigit(ch);
000449  000516  // Notes : char specifies the ascii character for the test
000450  000517  //     : 0 : char is not an ascii hexadecimal digit.
000451  000518  //     : 1 : char is an ascii hexadecimal digit..
000452  000519  //     : Valid range is "0123456789ABCDEF"
000453  000520        
000454  000521  func isupper("char"), 1;    //Returns a 1 if the character is an ascii upper case letter else returns a 0
000455  000522  // Syntax: isupper("char");
000456  000523  // Usage : Var := isupper(ch);
000457  000524  // Notes : char specifies the ascii character for the test
000458  000525  //     : 0 : char is not an ascii upper-case letter.
000459  000526  //     : 1 : char is an ascii upper-case letter.
000460  000527  //     : Valid range is "ABCD....WXYZ"
000461  000528        
000462  000529  func islower("char"), 1;    //Returns a 1 if the character is an ascii lower case letter else returns a 0
000463  000530  // Syntax: islower("char");
000464  000531  // Usage : Var := islower(ch);
000465  000532  // Notes : char specifies the ascii character for the test
000466  000533  //     : 0 : char is not an ascii lower-case letter.
000467  000534  //     : 1 : char is an ascii lower-case letter.
000468  000535  //     : Valid range is "abcd....wxyz"
000469  000536        
000470  000537  func isalpha("char"), 1;    //Returns a 1 if the character is an ascii lower or upper case letter else returns a 0
000471  000538  // Syntax: isalpha("char");
000472  000539  // Usage : Var := isalpha(ch);
000473  000540  // Notes : char specifies the ascii character for the test
000474  000541  //     : 0 : char is not an ascii lower or upper case letter.
000475  000542  //     : 1 : char is an ascii lower or upper case letter.
000476  000543  //     : Valid range is "ABCD...XYZ", "abcd....wxyz"
000477  000544        
000478  000545  func isalnum("char"), 1;    //Returns a 1 if the character is an ascii alpha numeric else returns a 0
000479  000546  // Syntax: isalnum("char");
000480  000547  // Usage : Var := isalnum(ch);
000481  000548  // Notes : char specifies the ascii character for the test
000482  000549  //     : 0 : char is not an ascii alphanumeric character.
000483  000550  //     : 1 : char is an ascii alphanumeric character.
000484  000551  //     : Valid range is "ABCD...XYZ", "abcd....wxyz", "0123456789"
000485  000552        
000486  000553  func isprint("char"), 1;    //Returns a 1 if the character is a printible ascii char else returns a 0
000487  000554  // Syntax: isprint("char");
000488  000555  // Usage : Var := isprint(ch);
000489  000556  // Notes : char specifies the ascii character for the test
000490  000557  //     : 0 : char is not a printable ascii character.
000491  000558  //     : 1 : char is a printable ascii character.
000492  000559  //     : Valid range is "0x20...0x7F"
000493  000560        
000494  000561  func isspace("char"), 1;    //Returns a 1 if the character is any one of the space type chars else returns a 0
000495  000562  // Syntax: isspace("char");
000496  000563  // Usage : Var := isspace(ch);
000497  000564  // Notes : char specifies the ascii character for the test
000498  000565  //     : 0 : char is not a space type character.
000499  000566  //     : 1 : char is a space type character.
000500  000567  //     : Valid range is space, formfeed, newline, carriage return, tab, vertical tab
000501  000568        
000502  000569  //unformatted
000503  000570  func iswhite("char"), 1;    //
000504  000571  // Syntax: iswhite("char");
000505  000572  // Usage : Var := iswhite(ch);
000506  000573  // Notes : char specifies the ascii character for the test
000507  000574  //     : 0 : char is not a space or tab character.
000508  000575  //     : 1 : char is not a space or tab character.
000509  000576  //     : Valid range is space or tab
000510  000577        
000511  000578  func toupper("char"), 1; //if character is lower case it returns the upper case equivalent else returns the passed char
000512  000579  // Syntax: toupper("char");
000513  000580  // Usage : Var := toupper(ch);
000514  000581  // Notes : char specifies the ascii character for the test
000515  000582  //     : "ABCD....XYZ" : if character is a lower case letter.
000516  000583  //     : char : if character is not a lower case letter.
000517  000584  //     : Valid range is "abcd....wxyz"
000518  000585        
000519  000586  func tolower("char"), 1; //if character is upper case it returns the lower case equivalent else returns the passed char
000520  000587  // Syntax: tolower("char");
000521  000588  // Usage : Var := tolower(ch);
000522  000589  // Notes : char specifies the ascii character for the test
000523  000590  //     : "abcd....xyz" : if character is an upper case letter.
000524  000591  //     : char : if character is not an upper case letter.
000525  000592  //     : Valid range is "ABCD....WXYZ"
000526  000593        
000527  000594  func LObyte("var"), 1;        //Returns the lower byte (lower 8 bits) of a 16 bit variable.
000528  000595  // Syntax: LObyte(var);
000529  000596  // Usage : myVar := LObyte(myvar2);
000530  000597  // Notes : var specifies the user variable
000531  000598  //     : Returns the lower byte (lower 8 bits) of a 16 bit variable
000532  000599        
000533  000600  func HIbyte("var"), 1;        //Returns the High byte (upper 8 bits) of a 16 bit variable.
000534  000601  // Syntax: HIbyte(var);
000535  000602  // Usage : myVar := HIbyte(myvar2);
000536  000603  // Notes : var specifies the user variable
000537  000604  //     : Returns the high byte (upper 8 bits) of a 16 bit variable
000538  000605        
000539  000606        
000540  000607  func ByteSwap("var"), 1;    //Returns the swapped upper and lower bytes of a 16 bit variable.
000541  000608  // Syntax: ByteSwap(var);
000542  000609  // Usage : myVar := ByteSwap(myvar2);
000543  000610  // Notes : var specifies the user variable
000544  000611  //     : Returns the endian swapped value of a 16 bit variable
000545  000612        
000546  000613        
000547  000614  func NybleSwap("var"), 1;    //Returns the swapped lower bytes nybles, upper byte retained.
000548  000615  // Syntax: NybleSwap(var);
000549  000616  // Usage : myVar := NybleSwap(myvar2);
000550  000617  // Notes : var specifies the user variable
000551  000618  //     : Returns the 16 bit variable with swapped lower nybles
000552  000619        
000553  000620  func putnumXY("xpos", "ypos", "arg1","arg2"), 1;            // print number at the specified position
000554  000621  // Syntax: putnumXY(x, y, format, value);
000555  000622  // Usage : var := putnumXY(100, 100, HEX, val);
000556  000623  // Notes : prints a 16bit number in various formats at the specified XY coordinates.
000557  000624  //     : Format: A constant that specifies the number format
000558  000625  //     : Value : The number to be printed
000559  000626        
000560  000627  func txt_FontBank("flashbank", "address"), 1;               // use a font located in another bank
000561  000628  // Syntax: txt_FontBank(bank, offset);
000562  000629  // Usage : txt_FontBank(FLASHBANK_2, arg2);
000563  000630  // Returns : Current font before the change, or 0 if invalid or bank is protected
000564  000631  // Notes : Sets the current font to a font held in another bank
000565  000632        
000566  000633  //------------------------------------------------------------------//
000567  000634  // 16bit signed Math Functions                                      //
000568  000635  //------------------------------------------------------------------//
000569  000636                                                  //
000570  000637  func ABS("value"), 1;                           // return a positive number
000571  000638  // Syntax: ABS(value);
000572  000639  // Usage : var := ABS(arg);
000573  000640  // Notes : Returns the absolute value of an argument
000574  000641        
000575  000642  func MIN("value1", "value2"), 1;                // return the smaller of 2 numbers
000576  000643  // Syntax: MIN(value1, value2);
000577  000644  // Usage : var := MIN(arg1, arg2);
000578  000645  // Notes : Returns the minimum of 2 arguments
000579  000646        
000580  000647  func MAX("value1", "value2"), 1;                // return the larger of 2 numbers
000581  000648  // Syntax: MAX(value1, value2);
000582  000649  // Usage : var := MAX(arg1, arg2);
000583  000650  // Notes : Returns the maximum of 2 arguments
000584  000651        
000585  000652  func SWAP("&var", "&var"), 0;                   // swap 2 variables, arguments must point to variables
000586  000653  // Syntax: SWAP(&var1, &var2);
000587  000654  // Usage : SWAP(&var1, &var2);
000588  000655  // Notes : Swaps the contents of 2 variables or memory locations
000589  000656        
000590  000657  func SIN("angle"), 1;                           // return SIN of angle
000591  000658  // Syntax: SIN(angle);
000592  000659  // Usage : var := SIN(arg);
000593  000660  // Notes : Returns the sine in radians of an argument in degrees
000594  000661  //       : the returned value range is from 127 to -127. The real
000595  000662  //       : cosine values vary from 1.0 to -1.0 so appropriate
000596  000663  //       : scaling must be done in user code.
000597  000664        
000598  000665  func COS("angle"), 1;                           // return COS of angle
000599  000666  // Syntax: COS(angle);
000600  000667  // Usage : var := COS(arg);
000601  000668  // Notes : Returns the cosine in radians of an argument in degrees
000602  000669  //       : the returned value range is from 127 to -127. The real
000603  000670  //       : cosine values vary from 1.0 to -1.0 so appropriate
000604  000671  //       : scaling must be done in user code.
000605  000672        
000606  000673  func RAND(), 1;                                 // return a pseudo random number
000607  000674  // Syntax: RAND();
000608  000675  // Usage : var := RAND();
000609  000676  // Notes : Returns a random number between 0 and 0xFFFF.
000610  000677  //       : The random number generator must first be seeded
000611  000678  //       : by using the SEED(number) function.
000612  000679        
000613  000680  func RANDVAL("low", "high"), 1;                 // return a ranged pseudo random number
000614  000681  // Syntax: RANDVAL("low", "high");
000615  000682  // Usage : var := RANDVAL(low, high);
000616  000683  // Notes : Returns a random number between low and high limits
000617  000684  //       : such that low <= N < high
000618  000685  //       : The random number generator may first be seeded
000619  000686  //       : by using the SEED(number) function.
000620  000687  //       : RANDVAL is the equivalent of aggregate functions:-
000621  000688  //       :     myvar = ABS( (RAND()%(high-low)+low) );
000622  000689  //       : Note that the lower limit is inclusive, but the upper limit is exclusive.
000623  000690        
000624  000691  func SEED("number"), 0;                         // re-seed the pseudo random number generator
000625  000692  // Syntax: SEED(number);
000626  000693  // Usage : SEED(arg);
000627  000694  // Notes : Seeds the random number generator.
000628  000695        
000629  000696  func SQRT("number"), 1;                         // return square root of a number
000630  000697  // Syntax: SQRT(number);
000631  000698  // Usage : SQRT(arg);
000632  000699  // Notes : Returns the integer square root of a number.
000633  000700        
000634  000701  func OVF(), 1;                                  // returns upper 16bits of 32bit results
000635  000702  // Syntax: OVF();
000636  000703  // Usage : loWord := 0x2710 * 0x2710;           // (10000 * 10000 in hex format)
000637  000704  //       : hiWord := OVF();
000638  000705  // Notes : This function returns the high order 16 bits from certain math and shift functions..
000639  000706        
000640  000707  func CY(), 1;
000641  000708  // Syntax: CY();
000642  000709  // Usage : myvar := 0xFFF8 + 9;                 // result = 1
000643  000710  //       : print(myvar," "CY(),"\n");           // carry = 1
000644  000711  // Notes : This function returns the carry status of an
000645  000712  // unsigned overflow from any 16 or 32bit additions or sutractions.
000646  000713        
000647  000714  func EVE_SP(), 1;
000648  000715  // Syntax: EVE_SP();
000649  000716  // Usage : eg:  print(EVE_SP());
000650  000717  // Notes : Used for debugging to assess the current stack level,
000651  000718  //       : mainly for checking stack leaks, see example EVE_SP.4dg
000652  000719        
000653  000720  func EVE_SSIZE(), 1;
000654  000721  // Syntax: EVE_SSIZE();
000655  000722  // Usage : eg:  print(EVE_SSIZE());
000656  000723  // Notes : Used to get the stack size,
000657  000724  //       : mainly for debugging purposes, EVE_SP.4dg
000658  000725        
000659  000726        
000660  000727  //------------------------------------------------------------------//
000661  000728  //
000662  000729  //------------------------------------------------------------------//
000663  000730  func mem_ArrayOp1("memarray", "count", "op", "value"), 0;                     // single array functions
000664  000731        
000665  000732        
000666  000733  // single word array operations
000667  000734  #CONST
000668  000755  #END
000669  000756        
000670  000757        
000671  000758  func mem_ArrayOp2("memarray1", "memarray2", "count", "op", "value"), 0;         // dual array functions
000672  000759        
000673  000760  // dual word array operations
000674  000761  #CONST
000675  000773  #END
000676  000774        
000677  000775        
000678  000776  func __reserved3(), 0; // do not remove
000679  000777  func __reserved4(), 0; // do not remove
000680  000778        
000681  000779        
000682  000780  //------------------------------------------------------------------//
000683  000781  // unsigned long (32 bit) operations                                //
000684  000782  //------------------------------------------------------------------//
000685  000783        
000686  000784  func uadd_3232("res32", "val1", "val2"), 1;
000687  000785  // Syntax   : cmp_3232(res32, varA, varB);
000688  000786  // Input    : DWORD res32 points to optional result (or zero for compare)
000689  000787  //          : DWORD val1 points to 32bit augend
000690  000788  //          : DWORD val2 points to 32bit addend
000691  000789  // Usage    : var res32[2];
000692  000790  //          : res := cmp_3232(res32, val1, val2);
000693  000791  // Notes    : performs an unsigned addition of 2 x 32bit values
000694  000792  //          : placing the 32bit result in a 2 word array.
000695  000793  // Returns  : returns 1 on 32bit unsigned overflow (carry).
000696  000794  //          ; carry flag is also set on 32bit unsigned overflow
000697  000795  //          ; and can be read with the CY() function.
000698  000796        
000699  000797        
000700  000798  func usub_3232("res32", "val1", "val2"), 1;
000701  000799  // Syntax   : cmp_3232(res32, varA, varB);
000702  000800  // Input    : DWORD res32 points to optional result (or zero for compare)
000703  000801  //          : DWORD val1 points to first 32bit minuend
000704  000802  //          : DWORD val2 points to 32bit subtrahend
000705  000803  // Usage    : var res32[2];
000706  000804  //          : res := cmp_3232(res32, val1, val2);
000707  000805  // Notes    : performs an unsigned subtraction of 2 x 32bit values
000708  000806  //          : placing the 32bit result in a 2 word array.
000709  000807  // Returns  : returns 1 on 32bit unsigned overflow (borrow).
000710  000808  //          ; carry flag is also set on 32bit unsigned underflow
000711  000809  //          ; and can be read with the CY() function.
000712  000810        
000713  000811        
000714  000812  func umul_1616("&res32", "val1", "val2"), 1;
000715  000813  // Syntax   : umul_1616(&res32, varA, varB);
000716  000814  // Input    : DWORD result   points to 32bit result register.
000717  000815  //          : VAR   val1  16bit register or constant
000718  000816  //          : VAR   val2  16bit register or constant
000719  000817  // Usage    : var res32[2];
000720  000818  //          : umul_1616(&res32, myvar, 50000);
000721  000819  // Notes    : performs an unsigned multiply of 2 x 16bit values
000722  000820  //          : placing the 32bit result in a 2 word array.
000723  000821  // Returns  : the pointer to the 32bit result.
000724  000822  //          : carry and overflow are not affected.
000725  000823        
000726  000824        
000727  000825  func udiv_3232("res32", "val1", "val2"), 1;
000728  000826  // Syntax   : udiv_1616(res32, varA, varB);
000729  000827  // Input    : DWORD *result   points to 32bit result register.
000730  000828  //          : DWORD   val1  pointer to 32bit value (dividend)
000731  000829  //          : DWORD   val2  pointer to 32bit value (divisor)
000732  000830  // Usage    : var res32[2];
000733  000831  //          : umul_1616(res32, myvar, 50000);
000734  000832  // Notes    : performs an unsigned division of 2 x 32bit values
000735  000833  //          : placing the 32bit result in a 2 word array.
000736  000834  // Returns  : the pointer to the 32bit result.
000737  000835  //          : carry and overflow are not affected.
000738  000836        
000739  000837        
000740  000838  func ucmp_3232("val1", "val2"), 1;
000741  000839  // Syntax   : cmp_3232(varA, varB);
000742  000840  // Input    : DWORD val1 points to 32bit minuend
000743  000841  //          : DWORD val2 points to 32bit sutrahend
000744  000842  // Usage    : res := cmp_3232(val1, val2);
000745  000843  // Notes    : performs an unsigned comparison of 2 x 32bit values.
000746  000844  //          : The result of the subtraction is returned.
000747  000845  // Returns  : 0  if equal
000748  000846  //          : 1  if val1 > val2
000749  000847  //          : -1 if val1 < val2
000750  000848  //          : This function does not affect the carry flag.
000751  000849        
000752  000850  func __reserved5(), 0; // do not remove
000753  000851  func __reserved6(), 0; // do not remove
000754  000852        
000755  000853  //------------------------------------------------------------------//
000756  000854  // Floating point operations                                        //
000757  000855  // Note that source arguments may be a pointer to a float variable, //
000758  000856  // or a numeric text string.                                        //
000759  000857  // A string argument is converted at run-time by calling            //
000760  000858  // flt_Val for a string argument.                                   //
000761  000859  // Note that a float variable is a 2 word array, eg var myfloat[2]; //
000762  000860  //------------------------------------------------------------------//
000763  000861  func flt_VAL("fresult", "numstring"), 1;
000764  000862  // Syntax   : flt_VAL(float1, mystring);
000765  000863  // Input    : FLOAT  fresult  points to float result register
000766  000864  //          : numstring       a string constant or string variable
000767  000865  //          : that is holds valid floating point number.
000768  000866  // Usage    : var float1[2];
000769  000867  //          : flt_VAL(float1, "1.0594631");
000770  000868  // Notes    : The string argument can be a string constant, a pointer
000771  000869  //          : to a string variable, or a pointer to a data statement.
000772  000870  //          : The string may be a float, or a hex or binary integer value (no decimal point allowed).
000773  000871  //          : For hex or binary, the number is preceeded with 0x or 0b
000774  000872  // Returns  : the pointer to the float result.
000775  000873  //          : carry and overflow are not affected.
000776  000874        
000777  000875        
000778  000876  func flt_ITOF("fresult", "var16"), 1;
000779  000877  // Syntax   : flt_ITOF(resf, intval);
000780  000878  // Input    : FLOAT  fresult  points to float result register
000781  000879  //          : var16           a 16bit signed integer variable or string constant
000782  000880  // Usage    : var float1[2];
000783  000881  //          : var myvar := 30000;
000784  000882  //          : flt_VAL(float1, myvar);
000785  000883  // Notes    : Converts a 16bit signed integer value to a signed floating point number.
000786  000884  // Returns  : the pointer to the float result.
000787  000885        
000788  000886        
000789  000887  func flt_UITOF("fresult", "uvar16"), 1;
000790  000888  // Syntax   : flt_ITOF(resf, intval);
000791  000889  // Input    : FLOAT  fresult  points to float result register
000792  000890  //          : var16           a 16bit integer variable or constant (treated as unsigned)
000793  000891  // Usage    : var float1[2];
000794  000892  //          : var myuvar := 30000;
000795  000893  //          : flt_UITOF(float1, myuvar);
000796  000894  // Notes    : Converts a 16bit unsigned integer value to a positive floating point number.
000797  000895  // Returns  : the pointer to the float result.
000798  000896        
000799  000897  func flt_LTOF("fresult", "var32"), 1;
000800  000898  // Syntax   : flt_LTOF(resf, var32);
000801  000899  // Input    : FLOAT  fresult  points to float result register
000802  000900  //          : var32           points to a 32bit (long) signed variable or string constant
000803  000901  // Usage    : var float1[2];
000804  000902  //          : var mylong[2];
000805  000903  //          : flt_VAL(float1, mylong);
000806  000904  // Notes    : Converts a 32bit signed integer value to a signed floating point number.
000807  000905  // Returns  : the pointer to the float result.
000808  000906        
000809  000907        
000810  000908  func flt_ULTOF("fresult", "uvar32"), 1;
000811  000909  // Syntax   : flt_ITOF(resf, uvar32);
000812  000910  // Input    : FLOAT  fresult  points to float result register
000813  000911  //          : var32           points to a 32bit (unsigned long) unsigned variable or string constant
000814  000912  // Usage    : var float1[2];
000815  000913  //          : var myulong[2];
000816  000914  //          : flt_VAL(float1, myulong);
000817  000915  // Notes    : Converts a 32bit unsigned integer value to a positive floating point number.
000818  000916  // Returns  : the pointer to the float result.
000819  000917        
000820  000918        
000821  000919  func flt_PRINT("fvalue", "formatstring"), 1;
000822  000920  // Syntax   : flt_PRINT(resf, formatstr);
000823  000921  // Input    : FLOAT  fresult  points to float result register
000824  000922  //          : formatstring    zero, null string, of valid format string
000825  000923  // Usage    : var float1[2];
000826  000924  //          : flt_PRINT(float1, "");
000827  000925  // Notes    : The string argument can be a string constant, a pointer
000828  000926  //          : to a string variable, or a pointer to a data statement.
000829  000927  //          : If it is zero or an empty string, the number is
000830  000928  //          : automatically formatted for the best presentation.
000831  000929  //          : The format string is similar to the C language, but only
000832  000930  //          : a single '%' may be used to print a single variable.
000833  000931  // Returns  : zero if success.
000834  000932        
000835  000933        
000836  000934  func flt_ABS("result", "floatval"), 1;
000837  000935  // Syntax   : flt_ABS(&result, &fval);
000838  000936  // Input    : FLOAT  result   points to float result register
000839  000937  //          : numstring       a string that is a valid number
000840  000938  // Usage    : var float1[2];
000841  000939  //          : flt_VAL(float1, float1); // convert float1 to its ABS value
000842  000940  // Returns  : the pointer to the float result.
000843  000941  //          : carry and overflow are not affected.
000844  000942        
000845  000943        
000846  000944  func flt_ACOS("result", "floatval"), 1;
000847  000945  // Syntax   : flt_ACOS(result, fval);
000848  000946  // Input    : FLOAT  result (in radians) points to float result register
000849  000947  //          : FLOAT  floatval points to the float value to get arccos of
000850  000948  // Usage    : var float1[2];
000851  000949  //          : flt_ACOS(result, float1); // get the arccos of float1
000852  000950  // Notes    : the result is in radians.
000853  000951  // Returns  : the pointer to the float result.
000854  000952  //          : carry and overflow are not affected.
000855  000953        
000856  000954        
000857  000955  func flt_ASIN("result", "floatval"), 1;
000858  000956  // Syntax   : flt_ASIN(result, fval);
000859  000957  // Input    : FLOAT  result (in radians) points to float result register
000860  000958  //          : FLOAT  floatval points to the float value to get arcsin of
000861  000959  // Usage    : var float1[2];
000862  000960  //          : flt_ASIN(result, float1); // get the Arcsin of float1
000863  000961  // Notes    : the result is in radians.
000864  000962  // Returns  : the pointer to the float result.
000865  000963  //          : carry and overflow are not affected.
000866  000964        
000867  000965        
000868  000966  func flt_ATAN("result", "floatval"), 1;
000869  000967  // Syntax   : flt_ATAN(result, fval);
000870  000968  // Input    : FLOAT  result (in radians) points to float result register
000871  000969  //          : FLOAT  floatval points to the float value to get arctan of
000872  000970  // Usage    : var float1[2];
000873  000971  //          : flt_ATAN(result, float1); // get the Arctan of float1
000874  000972  // Notes    : the result is in radians.
000875  000973  // Returns  : the pointer to the float result.
000876  000974  //          : carry and overflow are not affected.
000877  000975        
000878  000976        
000879  000977  func flt_COS("result", "floatval"), 1;
000880  000978  // Syntax   : flt_COS(result, fval);
000881  000979  // Input    : FLOAT  result   points to float result register
000882  000980  //          : FLOAT  floatval (in radians) points to the float value to get Cos of
000883  000981  // Usage    : var float1[2];
000884  000982  //          : flt_COS(result, float1); // get the Cosine of float1
000885  000983  // Notes    : the result is in radians.
000886  000984  // Returns  : the pointer to the float result.
000887  000985  //          : carry and overflow are not affected.
000888  000986        
000889  000987        
000890  000988  func flt_EXP("result", "floatval"), 1;
000891  000989  // Syntax   : flt_EXP(result, fval);
000892  000990  // Input    : FLOAT  result   points to float result register
000893  000991  //          : FLOAT  floatval points to the float value to get Exponent of
000894  000992  // Usage    : var float1[2];
000895  000993  //          : flt_EXP(result, float1); // get the Exponent of float1
000896  000994  // Returns  : the pointer to the float result.
000897  000995  //          : carry and overflow are not affected.
000898  000996        
000899  000997        
000900  000998  func flt_CEIL("result", "floatval"), 1;
000901  000999  // Syntax   : flt_CEIL(result, floatval);
000902  001000  // Input    : FLOAT  floatval points to the float value to integerize up
000903  001001  // Usage    : var float1[2];
000904  001002  //          : n := flt_INT(float1, float1); // round value up to the integer value
000905  001003  // Notes    : Removes fractional part, rounding up correctly.
000906  001004  // Returns  : the pointer to the float result.
000907  001005  //          : carry and overflow are not affected.
000908  001006        
000909  001007        
000910  001008  func flt_FLOOR("result", "floatval"), 1;
000911  001009  // Syntax   : flt_FLOOR(result, floatval);
000912  001010  // Input    : FLOAT  floatval points to the float value to integerize down
000913  001011  // Usage    : var float1[2];
000914  001012  //          : n := flt_INT(float1, float1); // round value down to the integer value
000915  001013  // Notes    : Removes fractional part, rounding down correctly.
000916  001014  // Returns  : the pointer to the float result.
000917  001015  //          : carry and overflow are not affected.
000918  001016        
000919  001017        
000920  001018  func flt_SIN("result", "floatval"), 1;
000921  001019  // Syntax   : flt_SIN(result, fval);
000922  001020  // Input    : FLOAT  result   points to float result register
000923  001021  //          : FLOAT  floatval (in radians) points to the float value to get Sine of
000924  001022  // Usage    : var float1[2];
000925  001023  //          : flt_SIN(result, float1); // get the Sin of float1
000926  001024  // Notes    : the result is in radians.
000927  001025  // Returns  : the pointer to the float result.
000928  001026  //          : carry and overflow are not affected.
000929  001027        
000930  001028        
000931  001029  func flt_LOG("result", "floatval"), 1;
000932  001030  // Syntax   : flt_LOG(&result, &fval);
000933  001031  // Input    : FLOAT  result   points to float result register
000934  001032  //          : FLOAT  floatval points to the float value to get Log of
000935  001033  // Usage    : var float1[2];
000936  001034  //          : flt_LOG(result, float1); // get the natural Log of float1
000937  001035  // Returns  : the pointer to the float result.
000938  001036  //          : carry and overflow are not affected.
000939  001037        
000940  001038        
000941  001039  func flt_SQR("result", "floatval"), 1;
000942  001040  // Syntax   : flt_SQR(result, fval);
000943  001041  // Input    : FLOAT  result   points to float result register
000944  001042  //          : FLOAT  floatval points to the float value to get Log of
000945  001043  // Usage    : var float1[2];
000946  001044  //          : flt_SQR(result, float1); // get the square root of float1
000947  001045  // Returns  : the pointer to the float result, or zero if number was negative.
000948  001046  //          : carry and overflow are not affected.
000949  001047        
000950  001048        
000951  001049  func flt_TAN("result", "floatval"), 1;
000952  001050  // Syntax   : flt_TAN(result, fval);
000953  001051  // Input    : FLOAT  result   points to float result register
000954  001052  //          : FLOAT  floatval (in radians) points to the float value to get Tangent of
000955  001053  // Usage    : var float1[2];
000956  001054  //          : flt_TAN(result, float1); // get the Tangent of float1
000957  001055  // Returns  : the pointer to the float result.
000958  001056  //          : carry and overflow are not affected.
000959  001057        
000960  001058        
000961  001059  func flt_POW("result", "floatx", "floaty"), 1;
000962  001060  // Syntax   : flt_POW(result, fval1, fval2);
000963  001061  // Input    : FLOAT  result   points to float result register
000964  001062  //          : FLOAT  floatx   points to the float value to raise
000965  001063  //          : FLOAT  floaty   points to the float value for power
000966  001064  // Usage    : flt_POW(result, floatx, floaty); // raise x to power y
000967  001065  // Returns  : the pointer to the float result, or zero if error occurs.
000968  001066  //          : carry and overflow are not affected.
000969  001067        
000970  001068        
000971  001069  func flt_ADD("result", "floatA", "floatB"), 1;
000972  001070  // Syntax   : flt_ADD(result, floatA, floatB);
000973  001071  // Input    : FLOAT  result   points to float result register
000974  001072  //          : FLOAT  floatval points to the float value A
000975  001073  //          : FLOAT  floatval points to the float value B
000976  001074  // Usage    : flt_ADD(result, floatx, floaty); // add B to A
000977  001075  // Returns  : the pointer to the float result, or zero if error occurs.
000978  001076  //          : carry and overflow are not affected.
000979  001077        
000980  001078        
000981  001079  func flt_SUB("&result", "&floatA", "&floatB"), 1;
000982  001080  // Syntax   : flt_SUB(result, floatA, floatB);
000983  001081  // Input    : FLOAT  result   points to float result register
000984  001082  //          : FLOAT  floatval points to the float value A
000985  001083  //          : FLOAT  floatval points to the float value B
000986  001084  // Usage    : flt_SUB(&result, &floatx, &floaty); // subtract B from A
000987  001085  // Returns  : the pointer to the float result, or zero if error occurs.
000988  001086  //          : carry and overflow are not affected.
000989  001087        
000990  001088        
000991  001089  func flt_MUL("result", "floatA", "floatB"), 1;
000992  001090  // Syntax   : flt_MUL(result, floatA, floatB);
000993  001091  // Input    : FLOAT  result   points to float result register
000994  001092  //          : FLOAT  floatval points to the float value A
000995  001093  //          : FLOAT  floatval points to the float value B
000996  001094  // Usage    : flt_MUL(result, floatA, floatB); // multiply A by B
000997  001095  // Returns  : the pointer to the float result, or zero if error occurs.
000998  001096  //          : carry and overflow are not affected.
000999  001097        
001000  001098        
001001  001099  func flt_DIV("result", "floatA", "floatB"), 1;
001002  001100  // Syntax   : flt_DIV(result, floatA, floatB);
001003  001101  // Input    : FLOAT  result   points to float result register
001004  001102  //          : FLOAT  floatval points to the float value A
001005  001103  //          : FLOAT  floatval points to the float value B
001006  001104  // Usage    : flt_DIV(result, floatA, floatB); // divide A by B
001007  001105  // Returns  : the pointer to the float result, or zero if error occurs.
001008  001106  //          : carry and overflow are not affected.
001009  001107        
001010  001108        
001011  001109  //------------------------------------------------------------------//
001012  001110  // The following float functions all return integer values.
001013  001111  //------------------------------------------------------------------//
001014  001112  func flt_EQ("floatA", "floatB"), 1;
001015  001113  // Syntax   : flt_EQ(floatA, floatB);
001016  001114  // Input    : FLOAT  floatval points to the float value A
001017  001115  //          : FLOAT  floatval points to the float value B
001018  001116  // Usage    : if (flt_EQ(floatA, floatB)) // compare A to B, true if A == B
001019  001117  // Returns  : True if numbers are equal, false otherwise.
001020  001118        
001021  001119        
001022  001120  func flt_NE("floatA", "floatB"), 1;
001023  001121  // Syntax   : flt_NE(floatA, floatB);
001024  001122  // Input    : FLOAT  floatval points to the float value A
001025  001123  //          : FLOAT  floatval points to the float value B
001026  001124  // Usage    : if (flt_NE(floatA, floatB)) // compare A to B, true if A != B
001027  001125  // Returns  : True if numbers are not equal, false otherwise.
001028  001126        
001029  001127        
001030  001128        
001031  001129  func flt_GT("floatA", "floatB"), 1;
001032  001130  // Syntax   : flt_GT(floatA, floatB);
001033  001131  // Input    : FLOAT  floatval points to the float value A
001034  001132  //          : FLOAT  floatval points to the float value B
001035  001133  // Usage    : if (flt_GT(floatA, floatB)) // compare A to B, true if A > B
001036  001134  // Returns  : True if A > B, false otherwise.
001037  001135        
001038  001136        
001039  001137  func flt_GE("floatA", "floatB"), 1;
001040  001138  // Syntax   : flt_GE(floatA, floatB);
001041  001139  // Input    : FLOAT  floatval points to the float value A
001042  001140  //          : FLOAT  floatval points to the float value B
001043  001141  // Usage    : if (flt_GE(floatA, floatB)) // compare A to B, true if A >= B
001044  001142  // Returns  : True if A >= B, false otherwise.
001045  001143        
001046  001144        
001047  001145  func flt_LT("floatA", "floatB"), 1;
001048  001146  // Syntax   : flt_LT(floatA, floatB);
001049  001147  // Input    : FLOAT  floatval points to the float value A
001050  001148  //          : FLOAT  floatval points to the float value B
001051  001149  // Usage    : if (flt_LT(floatA, floatB)) // compare A to B, true if A < B
001052  001150  // Returns  : True if A < B, false otherwise.
001053  001151        
001054  001152        
001055  001153  func flt_LE("floatA", "floatB"), 1;
001056  001154  // Syntax   : flt_LE(floatA, floatB);
001057  001155  // Input    : FLOAT  floatval points to the float value A
001058  001156  //          : FLOAT  floatval points to the float value B
001059  001157  // Usage    : if (flt_LE(floatA, floatB )) // compare A to B, true if A <= B
001060  001158  // Returns  : True if A <= B, false otherwise.
001061  001159        
001062  001160        
001063  001161  func flt_SGN("floatval"), 1;
001064  001162  // Syntax   : flt_SGN(fval);
001065  001163  // Input    : FLOAT  floatval   points to the float value examine sign
001066  001164  // Usage    : var float1[2];
001067  001165  //          : n := flt_SGN(float1); // return -1 if float number negative
001068  001166  // Notes    : returns 0 if sign is positive or zero.
001069  001167  // Returns  : returns 16bit integer -1 if float sign is negative, or zero if positive.
001070  001168  //          : carry and overflow are not affected.
001071  001169        
001072  001170        
001073  001171  func flt_FTOI("floatvar"), 1;
001074  001172  // Syntax   : flt_FTOI(myfloat);
001075  001173  // Input    : FLOAT  fresult  points to float result register
001076  001174  // Usage    : var float1[2];
001077  001175  //          : myvar := flt_VAL(&float1, myvar);
001078  001176  // Notes    : Converts a floating point number to a 16bit integer.
001079  001177  //          : The floating point number is rounded up or down accordingly.
001080  001178  // Returns  : the integer value of the float.
001081  001179        
001082  001180  func flt_PRINTxy("xpos", "ypos", "fvalue", "formatstring"), 1;
001083  001181  // Syntax   : flt_PRINT(x, y, resf, formatstr);
001084  001182  // Input    : FLOAT  fresult  points to float result register
001085  001183  //          : formatstring    zero, null string, of valid format string
001086  001184  // Usage    : var float1[2];
001087  001185  //          : flt_PRINT(float1, "");
001088  001186  // Notes    : The string argument can be a string constant, a pointer
001089  001187  //          : to a string variable, or a pointer to a data statement.
001090  001188  //          : If it is zero or an empty string, the number is
001091  001189  //          : automatically formatted for the best presentation.
001092  001190  //          : The format string is similar to the C language, but only
001093  001191  //          : a single '%' may be used to print a single variable.
001094  001192  // Returns  : zero if success.
001095  001193        
001096  001194  func __reserved9(), 0; // do not remove
001097  001195  func __reserved10(), 0; // do not remove
001098  001196        
001099  001197  //------------------------------------------------------------------//
001100  001198  //------------------------------------------------------------------//
001101  001199  //------------------------------------------------------------------//
001102  001200  //------------------------------------------------------------------//
001103  001201  //------------------------------------------------------------------//
001104  001202  func pin_Set("mode", "pin"), 1;            // set pin to required mode
001105  001203  // Syntax: pin_Set(mode, pin);
001106  001204  // Usage : pin_Set(PIN_OUT,);
001107  001205  // Notes : Sets the selected pin to the desired mode. Refer to the manual
001108  001206  //       : for pin function compatitblilites.
001109  001207  //       : returns true if the pin number and mode is legal (usually ignored)
001110  001208  //       :    available pin modes
001111  001209  //       :    PIN_INP                 0        // pin is input, no pullup or pulldown
001112  001210  //       :    PIN_INP_HI              1        // pin is input with pullup to Vcc
001113  001211  //       :    PIN_INP_LO              2        // pin is input with pulldown to Gnd
001114  001212  //       :    PIN_OUT                 3        // pin is output
001115  001213  //       :    PIN_OUT_OD              4        // pin is output with open drain
001116  001214  //       :    PIN_AN                  5        // pin is analogue (PA0 to PA3 only)
001117  001215  //       :    PIN_ANAVG               6        // pin is analogue (PA0 to PA3 only), averaged - 16 samples
001118  001216  //       :
001119  001217        
001120  001218  func pin_HI("pin"), 1;                    // set pin to logic '1'
001121  001219  // Syntax: pin_HI(pin);
001122  001220  // Usage : pin_HI(PA4);        // make PA4 HI level
001123  001221  // Notes : Outputs a logic "High" to the pin latch
001124  001222  //       : The pin is automatically made an output.
001125  001223  //       : pullup, pulldown, and change notification will be disable for the selected pin.
001126  001224  //       : returns true if the pin number is legal (usually ignored)
001127  001225  //       :
001128  001226        
001129  001227  func pin_LO("pin"), 1;                    // set pin to logic '0'
001130  001228  // Syntax: pin_LO(pin);
001131  001229  // Usage : pin_LO(PA3);
001132  001230  // Notes : Outputs a logic "Low" to the pin latch
001133  001231  //       : The pin is automatically made an output.
001134  001232  //       : pullup, pulldown, and change notification will be disable for the selected pins.
001135  001233  //       : returns true if the pin number is legal (usually ignored)
001136  001234  //       :
001137  001235        
001138  001236  func pin_Val("pin", "value"), 0;                    // set pin to to state of variable
001139  001237  // Syntax: pin_Var(pin, value);
001140  001238  // Usage : pin_Var(IO3, myvar);
001141  001239  // Notes : Outputs a logic state on a pin depending on the value of bit 0 of a variable
001142  001240  //       : The pin is automatically made an output.
001143  001241  //       : pullup, pulldown, and change notification will be disable for the selected pins.
001144  001242  //       : returns true if the pin number is legal (usually ignored)
001145  001243        
001146  001244  func pin_Read("pin"), 1;                // read pin, logic or analogue
001147  001245  // Syntax: pin_Read(PA0);
001148  001246  // Usage : arg1 := pin_Read(arg2);
001149  001247  // Notes : Read a pin in various ways. If the pin is
001150  001248  //       : set to an input, read the state of the input pin.
001151  001249  //       : If set to an output, read the state of the output latch.
001152  001250  //       : If set to analogue, read the 12 bit analogue value.
001153  001251        
001154  001252  func bus_Read(), 1;
001155  001253  // Syntax: bus_Read();
001156  001254  // Usage : arg1 := pin_ReadBus();
001157  001255  // Notes : Read the 16 bit port regardless of pin configurations.
001158  001256  //       : If a pin is configured as input or analogue, the pin is read directly as
001159  001257  //       : if it were a digital input. If a pin is configured as an output, the pin
001160  001258  //       : is also read directly, giving the output latch state.
001161  001259  //       : Bit 0 coresponds to PA0 through to bit15 which coresponds to PA15
001162  001260  //       : (Refer to 'port bit position masks')
001163  001261  //Returns: Returns the 16 bit value of the bus.
001164  001262        
001165  001263  func bus_SetPins("value"), 0;
001166  001264  // Syntax: bus_SetPins(value);
001167  001265  // Usage : arg1 := bus_SetPins(15); // set PA0 to PA3 to output bits, making them HI
001168  001266  // Notes : Any '1' bits in "value" set the coresponding port pin to an output
001169  001267  //       : and forces its state to a '1'. The state of its previous open drain
001170  001268  //       : configuration is not altered. Any zero bits in "value" will not affect the pin.
001171  001269  //       : pullup, pulldown, and change notification will be disable for the selected pins.
001172  001270  //       : Bit 0 coresponds to PA0 through to bit13 which coresponds to PA13
001173  001271        
001174  001272  func bus_ClearPins("value"), 0;
001175  001273  // Syntax: bus_ClearPins(value);
001176  001274  // Usage : bus_ClearPins(0x03F0); // set PA0 to PA5 to output bits, making them LO
001177  001275  // Notes : Any '1' bits in "value" set the coresponding port pin to an output
001178  001276  //       : and forces its state to a '0. The state of its previous open drain
001179  001277  //       : configuration is not altered. Any zero bits in "value" will not affect the pin.
001180  001278  //       : pullup, pulldown, and change notification will be disable for the selected pins.
001181  001279  //       : Bit 0 coresponds to PA0 through to bit13 which coresponds to PA13
001182  001280        
001183  001281  func bus_SetChangeInterrupt("function", "portmask"), 1;
001184  001282  // Syntax: bus_SetChangeInterrupt(value);
001185  001283  // Usage : bus_SetChangeInterrupt(scanKeypad, 0x00F0); // set PA4 to PA7 to interrupt on change
001186  001284  // Notes : Any '1' bits in "portmask" marks that pin to generate an interrupt on change.
001187  001285  //       : A level change on that pin will cause "function" to be executed. If "function" is
001188  001286  //       : zero, the display may be put into sleep mode, and any change will cause a wakeup reset.
001189  001287  //       : Wakeup will always re-start code running in FLASHBANK_0
001190  001288  //       : Bit 0 coresponds to PA0 through to bit15 which coresponds to PA15
001191  001289  //       : (Refer to 'port bit position masks')
001192  001290  //       : Once armed, "function" will only be executed once, it is necessary to
001193  001291  //       : re-arm for any further events.
001194  001292  //Returns: Return the current state of the pins that are selected in "portmask"
001195  001293  //       : This can be saved and later used in "function" to see which pin(s) actually changed.
001196  001294        
001197  001295  func bus_Write8("var"), 0;
001198  001296  // Syntax: bus_Write8(var);
001199  001297  // Usage : bus_Write8(arg1);
001200  001298  // Notes : The lower 8 bits of arg1 are placed on the BUS, then, after
001201  001299  //       : a settling delay of approx 50nsec, the BUS_WR(PA2) pin is strobed
001202  001300  //       : LO for approx 50nsec then set back HI.
001203  001301  //       : The upper 8 bits of arg1 are ignored.
001204  001302  //       : NB:- the BUS_WR(PA2) pin must be preset to the desired output state
001205  001303  //       : as must the bus pins to ensure BUS write integrity.
001206  001304  //       :
001207  001305  //       : BUS_0 is PA4
001208  001306  //       : BUS_1 is PA5
001209  001307  //       : BUS_2 is PA6
001210  001308  //       : BUS_3 is PA7
001211  001309  //       : BUS_4 is PA8
001212  001310  //       : BUS_5 is PA9
001213  001311  //       : BUS_6 is PA10
001214  001312  //       : BUS_7 is PA11
001215  001313        
001216  001314  func bus_Read8(), 1;
001217  001315  // Syntax: bus_Read();
001218  001316  // Usage : arg1 := bus_Read8();
001219  001317  // Notes : The BUS_RD(PA3) pin set to LO, then, after a settling delay
001220  001318  //       : of approx 50nsec, the BUS is read into the lower 8 bits of arg
001221  001319  //       : (the upper 8 bits being set to 0)
001222  001320  //       : the BUS_RD(PA3) pin is then set back to a HI level.
001223  001321  //       : NB:- the BUS_RD(PA3) pin must be preset to the desired output state
001224  001322  //       : as must the bus pins to ensure BUS read integrity.
001225  001323  //       :
001226  001324  //       : BUS_0 is PA4
001227  001325  //       : BUS_1 is PA5
001228  001326  //       : BUS_2 is PA6
001229  001327  //       : BUS_3 is PA7
001230  001328  //       : BUS_4 is PA8
001231  001329  //       : BUS_5 is PA9
001232  001330  //       : BUS_6 is PA10
001233  001331  //       : BUS_7 is PA11
001234  001332        
001235  001333  func __reserved13(), 0; // do not remove
001236  001334  func __reserved14(), 0; // do not remove
001237  001335  //------------------------------------------------------------------//
001238  001336  // Pin related constants                                            //
001239  001337  //------------------------------------------------------------------//
001240  001338        
001241  001339  // pin_Set(...) pin modes
001242  001340  #CONST
001243  001348  #END
001244  001349        
001245  001350        
001246  001351  // pin name             constant    connector H1 I/O Pin referencesnumbers
001247  001352  #CONST
001248  001372  #END
001249  001373        
001250  001374  // bit position masks
001251  001375  #CONST
001252  001392  #END
001253  001393        
001254  001394        
001255  001395        
001256  001396  //------------------------------------------------------------------//
001257  001397  //   Graphics Functions
001258  001398  //------------------------------------------------------------------//
001259  001399  func gfx_Set("mode", "value"), 0;            // set various graphics functions
001260  001400  // Syntax: gfx_Set(mode, value);
001261  001401  // Usage : gfx_Set(arg1, arg2);
001262  001402  // Notes : Sets various graphics parameters used by other functions
001263  001403  //       : This allows the features to be set programatically with a
001264  001404  //       : single function call.It is strongly recommended to use the
001265  001405  //       : pre-defined constants rather than the mode numbers.
001266  001406  //       : NB:- Although it is often required to be able to set graphics
001267  001407  //       : functions with a single function call for graphics engine
001268  001408  //       : related functions, there is a complete set of single parameter
001269  001409  //       : shortcut functions that have exactly the same function as
001270  001410  //       : each of the gfx_Set modes and saves 1 parameter / uses less memory
001271  001411  //       :
001272  001412  //       : mode = PEN_SIZE (mode 16)
001273  001413  //       : gfx_Set(PEN_SIZE, value);
001274  001414  //       : value = SOLID (value 0) rectangle and circle objects are solid
001275  001415  //       : value = OUTLINE (value 1) rectangle and circle objects are outlines
001276  001416  //       : Sets the mode of the Pen used by most graphics objects
001277  001417  //       :
001278  001418  //       : mode = BACKGROUND_COLOUR (mode 17)
001279  001419  //       : gfx_Set(BACKGROUND_COLOUR, value);
001280  001420  //       : value = 0 to 0xFFFF, Black to White
001281  001421  //       : Sets the Background colour of the screen
001282  001422  //       :
001283  001423  //       : mode = OBJECT_COLOUR (mode 18)
001284  001424  //       : gfx_Set(OBJECT_COLOUR, value);
001285  001425  //       : value = 0 to 0xFFFF, Black to White
001286  001426  //       : Sets the Object colour used in various functions
001287  001427  //       : LineTo(,,); LineRel(,,); BoxTo(,,); Dot(); etc.
001288  001428  //       :
001289  001429  //       : mode = CLIPPING (mode 19)
001290  001430  //       : gfx_Set(CLIPPING, value);
001291  001431  //       : value = OFF (value 0) Clipping disabled
001292  001432  //       : value = ON (value 1) Clipping enabled
001293  001433  //       : Enables/Disables the Clipping feature
001294  001434  //       :
001295  001435  //       : mode = TRANSPARENT_COLOUR (mode 20) : Image or Animation Transparency Colour.
001296  001436  //       : gfx_Set(TRANSPARENT_COLOUR, value);
001297  001437  //       : value = 0 to 0xFFFF Black to White
001298  001438  //       : Sets Bitmap, Image or Animation Transparency Colour.
001299  001439  //       : NB not implemented
001300  001440  //       :
001301  001441  //       : mode = TRANSPARENCY (mode 21) : Bitmap/Image/Animation Transparency
001302  001442  //       : gfx_Set(5, value);
001303  001443  //       : value = OFF (value 0) Transparency disabled
001304  001444  //       : value = ON (value 1) Transparency enabled
001305  001445  //       : Enables/Disables the Transparency feature
001306  001446  //       : NB not implemented
001307  001447  //       :
001308  001448  //       : mode = FRAME_DELAY (mode 22) : Inter-Frame Delay
001309  001449  //       : gfx_Set(FRAME_DELAY, value);
001310  001450  //       : value = 0 to 65535 ms
001311  001451  //       : Sets the Video/Animation clip inter-frame delay. This setting will
001312  001452  //       : over-ride the embedded frame delay of the clip. After the event,
001313  001453  //       : the setting will auto disable and if further inter-frame delays need
001314  001454  //       : overriding the setting must be re-issued.
001315  001455  //       :
001316  001456  //       : mode = SCREEN_MODE (mode 23) : Set required screen behaviour
001317  001457  //       : gfx_Set(SCREEN_MODE, value);
001318  001458  //       : value = LANDSCAPE   (value 0)
001319  001459  //       : value = LANDSCAPE_R (value 1)
001320  001460  //       : value = PORTRAIT    (value 2)
001321  001461  //       : value = PORTRAIT_R  (value 3)
001322  001462  //       :
001323  001463  //       : mode = OUTLINE_COLOUR (mode 24) : Outline Colour
001324  001464  //       : gfx_Set(OUTLINE_COLOUR, value);
001325  001465  //       : value = 1 to 0xFFFF, if 0, featre is OFF
001326  001466  //       : Sets the filled Rectangle or Circle objects outline colour
001327  001467  //       : If outline colour, is 0, OUTLINE_COLOUR feature is disabled
001328  001468  //       : gfx_Set(OUTLINE_COLOUR, OFF); may be used for this
001329  001469  //       :
001330  001470  //       : Only supports variable contrast for uOLED Modules
001331  001471  //       : mode = CONTRAST (mode 25) : Contrast
001332  001472  //       : gfx_Set(CONTRAST, value);
001333  001473  //       : value = 0 to 9, 0=off, 1=lowest, 8=highest contrast
001334  001474  //       : when contrast=0, display is placed in low power mode.
001335  001475  //       : This function should be called with contrast=0 when
001336  001476  //       : powering down the module.
001337  001477  //       :
001338  001478  //       : mode = LINE_PATTERN (mode 26) : Line Pattern
001339  001479  //       : gfx_Set(LINE_PATTERN, value);
001340  001480  //       : gfx_Set(LINE_PATTERN, 0b1111000011110000); // draw dotted line
001341  001481  //       : gfx_Set(LINE_PATTERN, OFF); // line patterning OFF
001342  001482  //       : a value of 0 turns the feature off
001343  001483  //       :
001344  001484  //       : mode = COLOUR_MODE (mode 27) : 8/16 bit colour mode
001345  001485  //       : gfx_Set(COLOUR_MODE , COLOUR16);   // set 16bit colour mode
001346  001486  //       : gfx_Set(COLOUR_MODE , COLOUR8);   // set 8bit colour mode
001347  001487  //       : NB not implemented, default is COLOUR16
001348  001488  //       :
001349  001489  //       : mode = BEVEL_WIDTH (mode 28) : set button and slider bevel width
001350  001490  //       : gfx_Set(BEVEL_WIDTH , 5);   // set bevel lines to 5 pixels wide
001351  001491  //       : sets the button and slider objects bevel width
001352  001492  //       :
001353  001493  //       : mode = BEVEL_SHADOW (mode 29) : set bevel shadowing depth for buttons and sliders
001354  001494  //       : gfx_Set(BEVEL_SHADOW , 5);
001355  001495  //       : sets the button and slider objects darken and lighten depth for the bevel colour
001356  001496  //       :
001357  001497  //       : mode = X_ORIGIN (mode 29) : set x offset for screen
001358  001498  //       : gfx_Set(X_ORIGIN , 25);  // object are offset 25 pixels from LHS
001359  001499  //       : sets the origin of drawn objects to a position other than 0,0
001360  001500  //       :
001361  001501  //       : mode = Y_ORIGIN (mode 29) : set y offset for screen
001362  001502  //       : gfx_Set(Y_ORIGIN , 30);  // object are offset 30 pixels from TOP
001363  001503  //       : sets the origin of drawn objects to a position other than 0,0
001364  001504        
001365  001505  //------------------------------------------------------------------------------
001366  001506  //gfx_Set() related constants
001367  001507  //------------------------------------------------------------------------------
001368  001508  #CONST
001369  001525  #END
001370  001526        
001371  001527        
001372  001528  func gfx_Cls(), 0;                    // clear the screen
001373  001529  // Syntax: gfx_Cls();
001374  001530  // Usage : gfx_Cls();
001375  001531  // Notes : Clears the screen with current background colour
001376  001532        
001377  001533  func gfx_MoveTo("x", "y"), 0;                // set glb_X1 and glb_Y1 to required co-ordinate
001378  001534  // Syntax: gfx_MoveTo(x, y);
001379  001535  // Usage : gfx_MoveTo(arg1, arg2);
001380  001536  // Notes : Moves the origin to a new x,y position
001381  001537        
001382  001538  func gfx_MoveRel("x", "y"), 0;                // set glb_X1 and glb_Y1 to new relative offset
001383  001539  // Syntax: gfx_MoveRel(x, y);
001384  001540  // Usage : gfx_MoveRel(arg1, arg2);
001385  001541  // Notes : Moves the origin to a new x,y position
001386  001542  //       : relative to the current origing
001387  001543        
001388  001544  func gfx_LineTo("x1", "y1"), 0;                     // draw line from current origin to new point
001389  001545  // Syntax: gfx_LineTo(x1, y1);
001390  001546  // Usage : gfx_LineTo(arg1, arg2);
001391  001547  // Notes : Draws a Line from the origin x,y to x1,y1.
001392  001548  //       : The new origin is then set to x1, y1. Line colour needs
001393  001549  //       : to be preset with "Set Object colour" using gfx_Set(mode=2, colour);
001394  001550        
001395  001551  func gfx_LineRel("x1", "y1"), 0;                    // draw line from current origin to new relative offset
001396  001552  // Syntax: gfx_LineRel(x1, y1);
001397  001553  // Usage : gfx_LineRel(arg1, arg2);
001398  001554  // Notes : Draws a Line from the origin x,y to x1,y1.
001399  001555  //       : Unlike gfx_MoveTo() the origin is not updated with x1, y1. Line colour needs
001400  001556  //       : to be preset with "Set Object colour" using gfx_Set(OBJECT_COLOUR, colour);
001401  001557        
001402  001558  func gfx_Line("x1", "y1", "x2", "y2", "colr"), 0;   // draw line, can be patterned
001403  001559  // Syntax: gfx_Line(x1, x2, y2, colr);
001404  001560  // Usage : gfx_Line(arg1, arg2, arg3, arg4, arg5);
001405  001561  // Notes : Plots a coloured Line from x1,y1 to x2,y2 on the screen
001406  001562        
001407  001563  func gfx_Hline("y", "x1", "x2", "colr"), 1;         // draw Hline, can be patterned
001408  001564  // Syntax: gfx_Line(x1, x2, y, colr);
001409  001565  // Usage : gfx_Line(arg1, arg2, arg3, arg4);
001410  001566  // Notes : Plots a coloured Horizontal line from x1,y to x2,y on the screen
001411  001567        
001412  001568  func gfx_Vline("x", "y1", "y2", "colr"), 1;         // draw Vline, can be patterned
001413  001569  // Syntax: gfx_Line(y1, y2, x, colr);
001414  001570  // Usage : gfx_Line(arg1, arg2, arg3, arg4);
001415  001571  // Notes : Plots a coloured Vertical line from x,y1 to x,y2 on the screen
001416  001572        
001417  001573  func gfx_Rectangle("x1" ,"y1", "x2", "y2", "colr"), 0;    // draw open rectangle,line can be patterned
001418  001574  // Syntax: gfx_Rectangle(x1, y1, x2, y2, colr);
001419  001575  // Usage : gfx_Rectangle(arg1, arg2, arg3, arg4, arg5);
001420  001576  // Notes : Plots a coloured Outline Rectangle from top corner (x1,y1) to
001421  001577  //       : bottom corner (x2,y2) on the screen.
001422  001578        
001423  001579  func gfx_RectangleFilled("x1","y1","x2","y2","colr"), 0;    // draw filled rectangle
001424  001580  // Syntax: gfx_Rectangle(x1, y1, x2, y2, colour);
001425  001581  // Usage : gfx_Rectangle(arg1, arg2, arg3, arg4, arg5);
001426  001582  // Notes : Plots a coloured Solid Rectangle from top corner (x1,y1) to
001427  001583  //       : bottom corner (x2,y2) on the screen.
001428  001584        
001429  001585  func gfx_Circle("x", "y", "rad", "colr"), 0;        // draw open circle
001430  001586  // Syntax: gfx_Circle(x, y, rad, colr);
001431  001587  // Usage : gfx_Circle(arg1, arg2, arg3, arg4);
001432  001588  // Notes : Plots a coloured outline Circle on the screen at centre x,y with radius = rad
001433  001589        
001434  001590  func gfx_CircleFilled("x", "y", "rad", "colr"), 0;    // draw filled circle
001435  001591  // Syntax: gfx_Circle(x, y, rad, colr);
001436  001592  // Usage : gfx_Circle(arg1, arg2, arg3, arg4);
001437  001593  // Notes : Plots a coloured Solid Circle on the screen at centre x,y with radius = rad
001438  001594        
001439  001595  func gfx_PutPixel("x", "y", "colr"), 0;            // set point at x y
001440  001596  // Syntax: gfx_PutPixel(x, y, colr);
001441  001597  // Usage : gfx_PutPixel(arg1, arg2, arg3);
001442  001598  // Notes : Plots a coloured pixel on the screen at x,y location
001443  001599        
001444  001600  func gfx_GetPixel("x", "y"), 1;                // read colour at point x y
001445  001601  // Syntax: gfx_GetPixel(x, y);
001446  001602  // Usage : var := gfx_GetPixel(arg1, arg2);
001447  001603  // Notes : Reads and returns the colour value of a pixel at location x,y
001448  001604        
001449  001605  func gfx_Triangle("x1","y1","x2","y2","x3","y3","colr"), 0; // draw an open triangle
001450  001606  // Syntax: gfx_Triangle(x1, y1, x2, y2, x3, y3, colr);
001451  001607  // Usage : gfx_Triangle(arg1, arg2, arg3, arg4, arg5, arg6, arg7);
001452  001608  // Notes : Plots a coloured outline Triangle from between 3 vertices: x1,y1 x2,y2 x3,y3
001453  001609  //       : Vertices must be specified in an anti-clockwise fashion
001454  001610        
001455  001611  func gfx_OrbitInit("&x_orb", "&y_orb"), 0;        // set result holders for orbit command
001456  001612  // Syntax: gfx_OrbitInit(&x_orb, &y_orb);
001457  001613  // Usage : gfx_OrbitInit(&arg1, &arg2);
001458  001614  // Notes : Sets up the Orbit function parameters.
001459  001615  //       : &x_orb, &y_orb: calcualted Orbit coordiantes. These are pointers to local
001460  001616  //       : variables that get updated after calling gfx_Orbit(,,) function.
001461  001617  //       : The coordiantaes are calculated relative to the origin
001462  001618  //       : obtained by using the gfx_MoveTo(x, y) function.
001463  001619        
001464  001620  func gfx_Orbit("angle", "distance"), 0;            // calculate point at angle, distance
001465  001621  // Syntax: gfx_Orbit(angle, distance);
001466  001622  // Usage : gfx_Orbit(arg1, arg2);
001467  001623  // Notes : The Orbit function calcualtes the x, y coordinates of a distant point whose
001468  001624  //       : only known parameters are the angle and the distance from the current origin.
001469  001625        
001470  001626  func gfx_Polyline("n", "&vx", "&vy", "colr"), 0;    // draw a polyline from a table of vertices
001471  001627  // Syntax: gfx_Polyline(numbVertices, &vertices_x, &vertices_y, colour);
001472  001628  // Usage : gfx_Polyline(arg1, x[array], y[array], arg2);
001473  001629  // Notes : This function is very similar to the Ploygon function
001474  001630  //       : with the exception of the 1st and the last vertices not joined.
001475  001631        
001476  001632  func gfx_Polygon("n", "&vx", "&vy", "colr"), 0;        // draw a polygon from a table of vertices
001477  001633  // Syntax: gfx_Polygon(numbVertices, &vx, &y, colour);
001478  001634  // Usage : gfx_Polygon(arg1, x[array], y[array], arg2);
001479  001635  // Notes : Plots a coloured outline Polygon between specified vertices: x1,y1 x2,y2 .. xn,yn
001480  001636  //       : Vertices must be minimum of 3 and can be specified in any fashion
001481  001637        
001482  001638  func gfx_Dot(), 0;                    // set point at glb_X glb_Y, default colour
001483  001639  // Syntax: gfx_Dot();
001484  001640  // Usage : gfx_Dot();
001485  001641  // Notes : Places a coloured dot at the origin
001486  001642        
001487  001643        
001488  001644  func gfx_Bullet("r"), 0;                // draw circle at glb_X glb_Y, default colour
001489  001645  // Syntax: gfx_Bullet();
001490  001646  // Usage : gfx_Bullet();
001491  001647  // Notes : Places a coloured circle at the origin
001492  001648  //       : filled or unfilled state is controlled by PenSize
001493  001649        
001494  001650  func gfx_IncX(), 1;                    // increment global origin glb_X, returning new value
001495  001651  // Syntax: gfx_IncX();
001496  001652  // Usage : var := gfx_IncX();
001497  001653  // Notes : Increments the x coordinate of the origin
001498  001654        
001499  001655  func gfx_IncY(), 1;                    // increment global origin glb_Y, returning new value
001500  001656  // Syntax: gfx_IncY();
001501  001657  // Usage : var := gfx_IncY();
001502  001658  // Notes : Increments the y coordinate of the origin
001503  001659        
001504  001660  func gfx_BoxTo("x1", "y1"), 0;                // draw rectangle from current origin to x1 y1
001505  001661  // Syntax: gfx_BoxTo(x1, y1);
001506  001662  // Usage : gfx_BoxTo(arg1, arg2);
001507  001663  // Notes : Draws a Rectangle from the origin x,y to x1,y1.
001508  001664  //       : The new origin is then set to x1,y1. Rectangle colour needs
001509  001665  //       : to be preset with "Set Object colour" using gfx_Set(mode=2, colour);
001510  001666  //       : and the PenSize setting determines if Box is solid or outline.
001511  001667        
001512  001668  func gfx_ClipWindow("x1" ,"y1", "x2", "y2"), 0;         // set the cipping area
001513  001669  // Syntax: gfx_ClipWindow(x1, y1, x2, y2);
001514  001670  // Usage : gfx_ClipWindow(arg1, arg2, arg3, arg4);
001515  001671  // Notes : Specifies a clipping window region on the screen such that any objects
001516  001672  //       : and text placed onto the screen will be clipped and displayed only
001517  001673  //       : within that region. For the clipping window to take effect, "Clipping"
001518  001674  //       : must be enabled seperately using the gfx_Set(CLIPPING, ON) command.
001519  001675        
001520  001676        
001521  001677  func gfx_ChangeColour("oldcolr", "newcolr"), 0;         // change pixel colour in clipping area
001522  001678  // Syntax: gfx_ChangeColour(oldcolr, newcolr);
001523  001679  // Usage : gfx_ChangeColour(0xFF00, 0XFFFF);
001524  001680  // *Notes:
001525  001681        
001526  001682  func gfx_SetClipRegion(), 0;                            // set clipping area to the most recent extents
001527  001683  // Syntax: gfx_SetClipRegion();
001528  001684  // Usage : var := gfx_SetClipRegion();
001529  001685  // *Notes:
001530  001686        
001531  001687  func gfx_Ellipse("x", "y", "xrad", "yrad", "colour"), 0;
001532  001688  // Syntax: gfx_Ellipse(x, y, xrad, yrad, colour);
001533  001689  // Usage : gfx_Ellipse(arg1, arg2, arg3, arg4, arg5);
001534  001690  // Notes : Plots a coloured Ellipse on the screen at centre x,y
001535  001691  //       : with xradius = xrad and yradius = yrad.
001536  001692  //       : if PenSize = 0 Ellipse is Solid
001537  001693  //       : if PenSize = 1 Ellipse is Outline
001538  001694        
001539  001695        
001540  001696  func gfx_EllipseFilled("x", "y", "xrad", "yrad", "colour"), 0;
001541  001697  // Syntax: gfx_EllipseFilled(x, y, xrad, yrad, colour);
001542  001698  // Usage : gfx_EllipseFilled(arg1, arg2, arg3, arg4, arg5);
001543  001699  // Notes : Plots a coloured Ellipse on the screen at centre x,y
001544  001700  //       : with xradius = xrad and yradius = yrad.
001545  001701        
001546  001702        
001547  001703  func gfx_Button("state", "x", "y", "buttonColour", "textColour", "font", "textWidth", "textHeight", "text"), 1;
001548  001704  // Syntax: gfx_Button(mode, x, y, buttonColour, textColour, font, textWidth, textHeight, text);
001549  001705  // Usage : gfx_Button(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
001550  001706  // Notes : Draws a 3 dimensional Text Button at screen location defined by
001551  001707  //       : x,y arguments (top left corner). The size of the button depends on
001552  001708  //       : the font, width, height and length of the text.
001553  001709  //       : The button appearance will depend on the state parameter setting:
001554  001710  //       :         state = 0 : Button Pressed
001555  001711  //       :         state = 1 : Button Raised
001556  001712  //       : The button is automatically sized, determined by text.
001557  001713        
001558  001714        
001559  001715  func gfx_Button2("state", "x", "y", "Width", "Height", "buttonColour", "textColour", "text"), 0;
001560  001716  // Syntax: gfx_Button2(mode, x, y, width, height, buttoncolour, textcolour, text);
001561  001717  // Usage : gfx_Button2(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
001562  001718  // Notes : Draws a 3 dimensional Text Button at screen location defined by
001563  001719  //       : x,y arguments (top left corner). The size of the button is defined by the width
001564  001720  //       : and height parameters. The text is centered within those bounds.
001565  001721  //       : The button appearance will depend on the state parameter setting:
001566  001722  //       :         state = 0 : Button Pressed
001567  001723  //       :         state = 1 : Button Raised
001568  001724  //       : The button has square corners.
001569  001725        
001570  001726  func gfx_Button3("state", "x", "y", "Width", "Height", "buttonColour", "textColour", "text"), 0;
001571  001727  // Syntax: gfx_Button3(mode, x, y, width, height, buttoncolour, textcolour, text);
001572  001728  // Usage : gfx_Button3(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
001573  001729  // Notes : Draws a 3 dimensional Text Button at screen location defined by
001574  001730  //       : x,y arguments (top left corner). The size of the button is defined by the width
001575  001731  //       : and height parameters. The text is centered within those bounds.
001576  001732  //       : The button appearance will depend on the state parameter setting:
001577  001733  //       :         state = 0 : Button Pressed
001578  001734  //       :         state = 1 : Button Raised
001579  001735  //       : The button has rounded corners depending upon gfx_BevelRadius.
001580  001736        
001581  001737  func gfx_CheckBox("state", "x", "y", "Width", "Height", "boxColour", "textColour", "text"), 0;
001582  001738  // Syntax: gfx_CheckBox(state, x, y, Width, Height, boxColour, textColour, text);
001583  001739  // Usage : gfx_CheckBox(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
001584  001740  // Notes : Draws a CheckBox at screen location defined by x,y arguments (top left corner).
001585  001741  //       : The size of the button is defined by the width and height parameters.
001586  001742  //       : The text is to the right of the checkbox and truncated if necessary.
001587  001743  //       : The check appearance will depend on the state parameter setting:
001588  001744  //       :         state = 0 = CHECKED    : Checkbox Checked
001589  001745  //       :         state = 1 = UNCHECKED  : CheckBox Unchecked
001590  001746        
001591  001747  func gfx_RadioButton("state", "x", "y", "Width", "Height", "boxColour", "textColour", "text"), 0;
001592  001748  // Syntax: gfx_RadioButton(state, x, y, Width, Height, boxColour, textColour, text);
001593  001749  // Usage : gfx_RadioButton(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
001594  001750  // Notes : Draws a RadioButton at screen location defined by x,y arguments (top left corner).
001595  001751  //       : The size of the button is defined by the width and height parameters.
001596  001752  //       : The text is to the right of the radiobutton and truncated if necessary.
001597  001753  //       : The check appearance will depend on the state parameter setting:
001598  001754  //       :         state = 0 = CHECKED    : Radiobutton Checked
001599  001755  //       :         state = 1 = UNCHECKED  : Radiobutton Unchecked
001600  001756        
001601  001757  func gfx_Slider2("mode", "x1", "y1", "width", "height", "colour", "scale", "value"), 1;
001602  001758  // Syntax: gfx_Slider2(mode, x, y, width, height, colour, scale, value);
001603  001759  // Usage : gfx_Slider(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
001604  001760  // Notes : Draws a 3 dimensional Slider Bar on the screen.
001605  001761  //       : Slider parameters are as follows:
001606  001762  //       :         mode = 0 : Slider recessed
001607  001763  //       :         mode = 1 : Slider raised
001608  001764  //       :         x1, y1 = top left corner
001609  001765  //       :         x2, y2 = bottom right corner
001610  001766  //       :         scale = n : sets the full scale range from 0 to n
001611  001767  //       :         value = m : sets the relative position of the thumb 0 <= m <= n
001612  001768  //returns: scaled value of thumb position
001613  001769        
001614  001770        
001615  001771        
001616  001772        
001617  001773  func gfx_Panel("state", "x", "y", "width", "height", "colour"), 0;
001618  001774  // Syntax: gfx_Panel(style, x, y, width, height, colour);
001619  001775  // Usage : gfx_Panel(PANEL_RAISED, x, y, w, h, GRAY);
001620  001776  // Notes : Draws a panel (groupbox) at screen location defined by
001621  001777  //       : x, y, width and height with colour "colour".
001622  001778  //       :         state = 0 : sunken
001623  001779  //       :         state = 1 : raised
001624  001780  //       :         state = 2 : hide (draw object in background colour)
001625  001781  //returns: nothing
001626  001782        
001627  001783        
001628  001784        
001629  001785  func gfx_Slider("mode", "x1", "y1", "x2", "y2", "colour", "scale", "value"), 1;
001630  001786  // Syntax: gfx_Slider(mode, x1, y1, x2, y2, colour, scale, value);
001631  001787  // Usage : gfx_Slider(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
001632  001788  // Notes : Draws a 3 dimensional Slider Bar on the screen.
001633  001789  //       : Slider parameters are as follows:
001634  001790  //       :         mode = 0 : Slider recessed
001635  001791  //       :         mode = 1 : Slider raised
001636  001792  //       :         x1, y1 = top left corner
001637  001793  //       :         x2, y2 = bottom right corner
001638  001794  //       :         scale = n : sets the full scale range from 0 to n
001639  001795  //       :         value = m : sets the relative position of the thumb 0 <= m <= n
001640  001796  //returns: scaled value of thumb position
001641  001797        
001642  001798        
001643  001799        
001644  001800  func gfx_ScreenCopyPaste("xs", "ys", "xd", "yd", "width", "height"), 0;
001645  001801  // Syntax: gfx_ScreenCopyPaste(xs, ys, xd, yd, width, height);
001646  001802  // Usage : gfx_ScreenCopyPaste(arg1, arg2, arg3, arg4, arg5, arg6);
001647  001803  // Notes : Copies an area of a screen from xs,ys of size given by width and height
001648  001804  //       : and pastes it to another location determined by xd, yd.
001649  001805        
001650  001806  func gfx_RGBto565("RED", "GREEN", "BLUE"), 1;
001651  001807  // Syntax: gfx_RGBto565(red, green, blue);
001652  001808  // Usage : gfx_RGBto565(arg1, arg2, arg3);
001653  001809  // Notes : Returns the 16bit (565 format) colour value of a 24bit (R,G,B format) colour
001654  001810        
001655  001811  func gfx_332to565("COLOUR8BIT"), 1;
001656  001812  // Syntax: gfx_332to565(colour);
001657  001813  // Usage : gfx_332to565(arg);
001658  001814  // Notes : Returns the 16bit (565 format) colour value of an 8 bit (332 format) colour
001659  001815        
001660  001816  func gfx_565to332("COLOUR16BIT"), 1;
001661  001817  // Syntax: gfx_565to332(colour);
001662  001818  // Usage : clor332 := gfx_565to332(arg);
001663  001819  // Notes : Returns the 8bit (332 format) colour value of an 16 bit (565 format) colour
001664  001820        
001665  001821  func gfx_TriangleFilled("x1","y1","x2","y2","x3","y3","colr"), 0; // draw a filled triangle
001666  001822  // Syntax: gfx_TriangleFilled(x1, y1, x2, y2, x3, y3, colr);
001667  001823  // Usage : gfx_TriangleFilled(arg1, arg2, arg3, arg4, arg5, arg6, arg7);
001668  001824  // Notes : Plots a coloured Solid Triangle from between 3 vertices: x1,y1 x2,y2 x3,y3
001669  001825  //       : Vertices must be specified in an anti-clockwise fashion
001670  001826        
001671  001827        
001672  001828  func gfx_PolygonFilled("n", "&vx", "&vy", "colr"), 0;        // draw a filled polygon from a table of vertices
001673  001829  // Syntax: gfx_PolygonFilled(numbVertices, &vx, &y, colour);
001674  001830  // Usage : gfx_PolygonFilled(arg1, x[array], y[array], arg2);
001675  001831  // Notes : Plots a solid Polygon between specified vertices: x1,y1 x2,y2 .. xn,yn
001676  001832  //       : Vertices must be minimum of 3 and can be specified in any fashion
001677  001833        
001678  001834        
001679  001835  func gfx_Origin("x", "y"), 0;            // set relative screen offset for graphics objects
001680  001836  // Syntax: gfx_Offset(x, y);
001681  001837  // Usage : gfx_Offset(arg1, arg2);
001682  001838  // Notes : Set the screen offset
001683  001839        
001684  001840        
001685  001841        
001686  001842  func gfx_FillPattern("patptr", "mode"), 1;
001687  001843  // Syntax  : gfx_FillPattern(patternpointer);
001688  001844  // Usage   : gfx_FillPattern(PTN_BRICKS);
001689  001845  //         : Provides graphics fill pattern, (8 linear bytes, 1=pixel off)
001690  001846  // Notes   : "patptr" points to an 8x8 tile for rendering filled areas.
001691  001847  //         : Rendering is turned off with gfx_FillPattern(0);
001692  001848  //         : or gfx_FillPattern(OFF);
001693  001849  //         : "mode" maybe TRANSPARENT or OPAQUE (0 or 1), for OPAQUE
001694  001850  //         : mode, the current screen colour is used for the 'off'
001695  001851  //         : pixels, for transparent mode, the 'off' pixels are not drawn.
001696  001852  //         : gfx_FillPattern affects all filled object, including polygons.
001697  001853  //         : There are 32 builtin patterns, these are obtained using the
001698  001854  //         : pre-defined constants FILLPATTERN_0 to FILLPATTERN_31, or the
001699  001855  //         : names, eg PTN_BRICKS, PTN_CARGONET, PTN_CIRCUITS, etc.
001700  001856  //         : Note that the constants range from 0xFFE0 to 0xFFFF, any
001701  001857  //         : other value is assumed to be a pointer to a users 8 byte
001702  001858  //         : block pattern.
001703  001859  // Returns : returns the handle of the previous pattern.
001704  001860        
001705  001861        
001706  001862  func gfx_PieSlice("cx", "cy", "spread", "radius", "step", "startangle", "endangle", "mode", "colour"), 0;
001707  001863  // Syntax  : gfx_PieSlice(cx, cy, spread, radius, step, startangle, endangle, mode, colour);
001708  001864  // Usage   : gfx_PieSlice(120, 120, 0, 100, 8, 75, 145, 0, YELLOW);
001709  001865  // Notes   : Draws a 'pie slice' (filled arc) at "cx":"cy" with radius "radius", starting at "startangle"
001710  001866  //         : and ending at "endangle". "spread" is used to offset the centrepoint of the pieslice
001711  001867  //         : to shift a pie chart piece away from the centrepoint.
001712  001868  //         : Rendering can be obtained with gfx_FillPattern(PATTRN);
001713  001869  //         : or gfx_FillPattern(OFF); for no fill pattern.
001714  001870  //         : Step is the stepping angle increment for the fineness of the pie Slice.
001715  001871  //         : "mode" has the following effect
001716  001872  //         :   if mode = 0, no outline
001717  001873  //         :   if mode = 1, outer circumference line (using current object colour)
001718  001874  //         :   if mode = 2, outer circumference and slice lines ( (using current object colour)
001719  001875  // Returns : nothing.
001720  001876        
001721  001877        
001722  001878  func gfx_Arc("xc", "yc", "radius", "step", "startangle", "endangle", "mode"), 0;
001723  001879  // Syntax  : gfx_Arc(cx, cy, radius, step, startangle, endangle, mode);
001724  001880  // Usage   : gfx_Arc(120, 120, 0, 100, 8, 75, 145, 0);
001725  001881  // Notes   : Draws an arc at "cx":"cy" with radius "radius", starting at "startangle"
001726  001882  //         : and ending at "endangle". Colour is determined by curent object colour.
001727  001883  //         : Step is the stepping angle increment for the fineness of the arc.
001728  001884  //         : "mode" has the following effect
001729  001885  //         :   if mode = 0, outer circumference line only
001730  001886  //         :   if mode = 1, outer circumference and lines back to cy:cy
001731  001887  // Returns : nothing.
001732  001888        
001733  001889        
001734  001890  func gfx_RoundRect("x1", "y1", "x2", "y2", "rad", "color"), 0;
001735  001891  // Syntax  : gfx_RoundRect(x1, y1, x2, y2, radius, colour);
001736  001892  // Usage   : gfx_RoundRect(120, 120, 160, 160, 8, GRAY); // draw a tab like object
001737  001893  // Notes   : Draws a filled rectangle at the given co-ordinates with rounded corners
001738  001894  //         : determined by "radius".
001739  001895  //         : Bounding rectangle is x1-rad, y1-rad, x2+rad, y2+rad.
001740  001896  // Returns : nothing.
001741  001897        
001742  001898        
001743  001899  func gfx_Surround("x1", "y1", "x2", "y2", "rad1", "rad2", "color"), 0;
001744  001900  // Syntax  : gfx_Surround(x1, y1, x2, y2, radius1, radius1, colour);
001745  001901  // Usage   : gfx_Surround(120, 120, 160, 160, 8, 0, GRAY); // rounded surround frame
001746  001902  // Notes   : Draws a outline rectangle at the given co-ordinates with rounded corners
001747  001903  //         : determined by "radius1". "radius2" sets the radius of the outer rounded rectangle.
001748  001904  //         : If "radius1" is zero, the inner rectangle will have square corners.
001749  001905  //         : Bounding rectangle is x1-rad1-rad2, y1-rad1-rad2, x2+rad1+rad2, y2+rad1+rad2.
001750  001906  // Returns : nothing.
001751  001907        
001752  001908        
001753  001909  func gfx_RoundPanel("state", "x", "y", "width", "height", "radius", "bevelwidth", "colour"), 0;
001754  001910  // Syntax  : gfx_RoundPanel(style, x, y, width, height, radius, bevelwidth, colour);
001755  001911  // Usage   : gfx_RoundPanel(PANEL_RAISED, 100, 100, 30, 20, GRAY);
001756  001912  // Notes   : Draws a rounded panel at x, y, width and height may be zero allowing the function
001757  001913  //         : to be used for rounded panels, rounded buttons, circular buttons.
001758  001914  //         :         state = 0 : sunken
001759  001915  //         :         state = 1 : raised
001760  001916  //         :         state = 2 : hide (draw object in background colour)
001761  001917  //         : Bounding rectangle is x1-radius-bevelwidth, y1-radius-bevelwidth, x2+radius+bevelwidth, y2+radius+bevelwidth.
001762  001918  // Returns : nothing.
001763  001919        
001764  001920        
001765  001921  func gfx_Gradient("style", "left", "top", "right", "bottom", "color1", "color2"), 0;
001766  001922  // Syntax  : gfx_Gradient(style, x1, y1, x2, y2, colr1, colr2);
001767  001923  // Usage   : gfx_Gradient(GRAD_WAVE_VER, 100, 100, 230, 120, BLACK, WHITE);
001768  001924  // Notes   : Draws a graduated colour rectangle at the specified co-ordinate.
001769  001925  //         : "style" specifies the drawing mode
001770  001926  //         :     GRAD_DOWN         // gradient changes in the vertical direction
001771  001927  //         :     GRAD_RIGHT        // gradient change in the horizontal direction
001772  001928  //         :     GRAD_UP           // gradient changes in the vertical direction
001773  001929  //         :     GRAD_LEFT         // gradient change in the horizontal direction
001774  001930  //         :     GRAD_WAVE_VER     // gradient wave in the vertical direction
001775  001931  //         :     GRAD_WAVE_HOR     // gradient wave in the horizontal direction
001776  001932  // Returns : nothing.
001777  001933        
001778  001934        
001779  001935  func gfx_RoundGradient("style", "left", "top", "right", "bottom", "radius", "color1", "color2"), 0;
001780  001936  // Syntax  : gfx_Gradient(style, x1, y1, x2, y2, radius, colr1, colr2);
001781  001937  // Usage   : gfx_Gradient(GRAD_WAVE_VER, 100, 100, 230, 120, BLACK, WHITE);
001782  001938  // Notes   : Draws a graduated colour rounded rectangle at the specified co-ordinate.
001783  001939  //         : X1 may equal X2, and Y1 = Y2 allowing allowing the function
001784  001940  //         : to be used for rounded panels, rounded buttons, circular buttons.
001785  001941  //         : "style" specifies the drawing mode
001786  001942  //         :     GRAD_DOWN         // gradient changes in the vertical direction
001787  001943  //         :     GRAD_RIGHT        // gradient change in the horizontal direction
001788  001944  //         :     GRAD_UP           // gradient changes in the vertical direction
001789  001945  //         :     GRAD_LEFT         // gradient change in the horizontal direction
001790  001946  //         :     GRAD_WAVE_VER     // gradient wave in the vertical direction
001791  001947  //         :     GRAD_WAVE_HOR     // gradient wave in the horizontal direction
001792  001948  //         : Bounding rectangle is x1-radius, y1-radius, x2+radius, y2+radius.
001793  001949  // Returns : nothing.
001794  001950        
001795  001951        
001796  001952  func gfx_ReadBresLine("x1", "y1", "x2", "y2", "ptr"), 1;
001797  001953  // Syntax  : gfx_readBrezLine(x1, y1, x2, y2, ptr);
001798  001954  // Usage   : anArrayPtr := gfx_readBrezLine(10, 10, 50, 50, 0);  // read arbitrary line to array, let the function make the array for me
001799  001955  // Notes   : reads an arbitrary line from the display to an array.
001800  001956  //         : If "ptr" is 0, the correctly sized array is created, in which case
001801  001957  //         : it is up to the caller to eventually destroy it. Otherwise "ptr"
001802  001958  //         : is expected to point to a correctly sized array.
001803  001959  //         : NB if an array is supplied, its size must be large enough, and may
001804  001960  //         : be calculated:-
001805  001961  //         : bytecount := (MAX(ABS(x2-x1), ABS(y2-y1) + 1) * 2; // calc array size for mem_Alloc (which allocates byte storage)
001806  001962  //         : wordcount := (MAX(ABS(x2-x1), ABS(y2-y1) + 1);     // calc array size for fixed word array
001807  001963  // Returns : A pointer to the created aray, or the users array.
001808  001964  //         : In the case of ptr=0, if there is insufficient
001809  001965  //         : memory to create the array, zero is returned
001810  001966        
001811  001967        
001812  001968  func gfx_WriteBresLine("x1", "y1", "x2", "y2", "ptr"), 0;
001813  001969  // Syntax  : gfx_writeBrezLine(x1, y1, x2, y2, ptr), 0;
001814  001970  // Usage   : gfx_writeBrezLine(20, 20, 50, 50, anArrayPtr);   // write an array back to the arbitrary line
001815  001971  // Notes   : cast pixel values from array to arbitrary line "x1", "y1", "x2", "y2"
001816  001972  //         : "ptr" points to the array to be written.
001817  001973  // Returns : nothing
001818  001974        
001819  001975        
001820  001976  func gfx_ReadGRAMarea("x1", "y1", "x2", "y2", "ptr"), 1;
001821  001977  // Syntax  : gfx_ReadGRAMarea(x1, y1, x2, y2, ptr);
001822  001978  // Usage   : anArrayPtr := gfx_ReadGRAMarea(10, 10, 50, 50, 0);  // read rectangular area to array, let the function make the array for me
001823  001979  // Notes   : reads an arbitrary rectangular area from the display to an array.
001824  001980  //         : If "ptr" is 0, the correctly sized array is created, in which case
001825  001981  //         : it is up to the caller to eventually destroy it. Otherwise "ptr"
001826  001982  //         : is expected to point to a correctly sized array.
001827  001983  //         : NB if an array is supplied, its size must be large enough, and may
001828  001984  //         : be calculated:-
001829  001985  //         : bytecount := ( (ABS(x2-x1)+1) * (ABS(y2-y1) + 1)) * 2;     // calc array size for mem_Alloc (which allocates byte storage)
001830  001986  //         : wordcount := ( (ABS(x2-x1)+1) *  ABS(y2-y1);             // calc array size for fixed word array
001831  001987  // Returns : A pointer to the created aray, or the users array.
001832  001988  //         : In the case of ptr=0, if there is insufficient
001833  001989  //         : memory to create the array, zero is returned
001834  001990        
001835  001991        
001836  001992  func gfx_WriteGRAMarea("x1", "y1", "x2", "y2", "ptr"), 0;
001837  001993  // Syntax  : gfx_WriteGRAMarea(x1, y1, x2, y2, ptr), 0;
001838  001994  // Usage   : gfx_WriteGRAMarea(20, 20, 50, 50, anArrayPtr);   // write an array back to the rectangular area
001839  001995  // Notes   : "ptr" points to the array to be written.
001840  001996  // Returns : nothing
001841  001997        
001842  001998        
001843  001999  func gfx_Get("mode"), 1;
001844  002000  // Syntax: gfx_Get(mode);
001845  002001  // Usage : arg1 := gfx_Get(arg);
001846  002002  // Notes : Returns various parameters to caller
001847  002003  //       :
001848  002004  //       : mode = X_MAX (mode 0) : current orientations maximum X value
001849  002005  //       : var := gfx_Get(X_MAX);
001850  002006  //       : Returns the maximum horizontal value of the display
001851  002007  //       :
001852  002008  //       : mode = Y_MAX (mode 1) : Vcurrent orientations maximum Y value
001853  002009  //       : var := gfx_Get(Y_MAX);
001854  002010  //       : Returns the maximum vertical value of the display
001855  002011  //       :
001856  002012  //       : mode = LEFT_POS (mode 2) : Left location of last Object
001857  002013  //       : var := gfx_Get(LEFT_POS);
001858  002014  //       : Returns the left location of the last drawn object
001859  002015  //       : such as a slider or button or an image/video
001860  002016  //       :
001861  002017  //       : mode = TOP_POS (mode 3) : Top location of Object
001862  002018  //       : var := gfx_Get(TOP_POS);
001863  002019  //       : Returns the top location of the last drawn object
001864  002020  //       : such as a slider or button or an image/video
001865  002021  //       :
001866  002022  //       : mode = RIGHT_POS (mode 4) : Right location of last Object
001867  002023  //       : var := gfx_Get(RIGHT_POS);
001868  002024  //       : Returns the right location of the last drawn object
001869  002025  //       : such as a slider or button or an image/video
001870  002026  //       :
001871  002027  //       : mode = BOTTOM_POS  (mode 5) : Bottom location of Object
001872  002028  //       : var := gfx_Get(BOTTOM_POS );
001873  002029  //       : Returns the bottom location of the last drawn object
001874  002030  //       : such as a slider or button or an image/video
001875  002031  //       :
001876  002032  //       : mode = X_ORG (mode 6) : get current internal X position
001877  002033  //       : var := gfx_Get(X_ORG);
001878  002034  //       : Returns the internal X position that was set with
001879  002035  //       : gfx_MoveTo(x, y); or gfx_Set(X_ORG, pos);
001880  002036  //       :
001881  002037  //       : mode = Y_ORG (mode 7) : get current internal Y position
001882  002038  //       : var := gfx_Get(Y_ORG);
001883  002039  //       : Returns the internal X position that was set with
001884  002040  //       : gfx_MoveTo(x, y); or gfx_Set(Y_ORG, pos);
001885  002041  //       :
001886  002042        
001887  002043        
001888  002044  //------------------------------------------------------------------//
001889  002045  // Single parameter short-cuts                                      //
001890  002046  // for the gfx_Set functions                                        //
001891  002047  // These functions return the existing value before                 //
001892  002048  // the change is made.                                              //
001893  002049  //------------------------------------------------------------------//
001894  002050  func gfx_PenSize("mode"), 1;                        // 0  graphics pen size, SOLD or OUTLINE
001895  002051  func gfx_BGcolour("colour"), 1;                     // 1  graphics background colour
001896  002052  func gfx_ObjectColour("colour"), 1;                 // 2  graphics object colour
001897  002053  func gfx_Clipping("mode"), 1;                       // 3  graphics clipping ON/OFF
001898  002054  func gfx_TransparentColour("colour"), 1;            // 4  graphics image transparent mask colour
001899  002055  func gfx_Transparency("mode"), 1;                   // 5  graphics image transparent mode ON/OFF
001900  002056  func gfx_FrameDelay("milliseconds"), 1;             // 6  graphics animation frame delay
001901  002057  func gfx_ScreenMode("mode"), 1;                     // 7  graphics orientation LANDSCAPE, LANDSCAPE_R, PORTRAIT, PORTRAIT_R
001902  002058  func gfx_OutlineColour("colour"), 1;                // 8  graphics rectangle/circle outline colour
001903  002059  func gfx_Contrast("value"), 1;                      // 9  graphics hardware value 0 to 9, 0=off, 1=lowest, 8=highest (only for AMOLED devices)
001904  002060  func gfx_LinePattern("value"), 1;                   // 10 graphics line draw tesselation pattern (16 linear bits, 1=pixel off)
001905  002061  func gfx_BevelRadius("radius"), 1;                  // 11 graphics button bevel radius
001906  002062  func gfx_BevelWidth("value"), 1;                    // 12 graphics button bevel width
001907  002063  func gfx_BevelShadow("value"), 1;                   // 13 graphics button bevel shadow depth
001908  002064  func gfx_Xorigin("offset"), 1;                      // 14 graphics  X origin
001909  002065  func gfx_Yorigin("offset"), 1;                      // 15 graphics  Y origin
001910  002066        
001911  002067        
001912  002068  func gfx_PointWithinBox("x", "y", "&rectr"), 1;
001913  002069  // Syntax   : gfx_PointWithinBox(x, y, rect);
001914  002070  // Usage    : var r[4]; r[0]:=100; r[1]:=200; r[2]:=20; r[3]:=30;
001915  002071  //          : result := gfx_PointWithinBox(x, y, r); // check area at 100,200,119,229
001916  002072  // Notes    : rect is an array of 4 vars, x1, y1, width, height - using width co-ordinates
001917  002073  // returns  : Returns true if last touch co-ordinates are within the box test area.
001918  002074        
001919  002075        
001920  002076  func gfx_PointWithinRectangle("x", "y", "&recta"), 1;
001921  002077  // Syntax   : gfx_PointWithinRectangle(x, y, recta);
001922  002078  // Usage    : var r[4]; r[0]:=100; r[1]:=200; r[2]:=119; r[3]:=129;
001923  002079  //          : result := gfx_PointWithinRectangle(x, y, r); // check if point within area at 100,200,119,229
001924  002080  // Notes    : rect is an array of 4 vars, x1, y1, x2, y2 using absolute co-ordinates
001925  002081  // returns  : Returns true if x:y co-ordinates are within the rectangle test area.
001926  002082        
001927  002083        
001928  002084  func __reserved17(), 0; // do not remove
001929  002085  func __reserved18(), 0; // do not remove
001930  002086  func __reserved19(), 0; // do not remove
001931  002087  func __reserved20(), 0; // do not remove
001932  002088  func __reserved21(), 0; // do not remove
001933  002089  func __reserved22(), 0; // do not remove
001934  002090        
001935  002091        
001936  002092  // built in fill pattern constants for function gfx_FillPattern
001937  002093  #CONST
001938  002126  #END
001939  002127        
001940  002128  #CONST
001941  002161  #END
001942  002162        
001943  002163  //------------------------------------------------------------------//
001944  002164  //     gradient control constants                                   //
001945  002165  //------------------------------------------------------------------//
001946  002166  #constant GRAD_DOWN         0x20    // gradient changes in the vertical direction
001947  002166  #constant GRAD_DOWN         0x20    // gradient changes in the vertical direction
001948  002167  #constant GRAD_RIGHT        0x30    // gradient change in the horizontal direction
001949  002167  #constant GRAD_RIGHT        0x30    // gradient change in the horizontal direction
001950  002168  #constant GRAD_UP           0x40    // gradient changes in the vertical direction
001951  002168  #constant GRAD_UP           0x40    // gradient changes in the vertical direction
001952  002169  #constant GRAD_LEFT         0x50    // gradient change in the horizontal direction
001953  002169  #constant GRAD_LEFT         0x50    // gradient change in the horizontal direction
001954  002170  #constant GRAD_WAVE_VER     0x60    // gradient wave in the vertical direction
001955  002170  #constant GRAD_WAVE_VER     0x60    // gradient wave in the vertical direction
001956  002171  #constant GRAD_WAVE_HOR     0x70    // gradient wave in the horizontal direction
001957  002171  #constant GRAD_WAVE_HOR     0x70    // gradient wave in the horizontal direction
001958  002172        
001959  002173        
001960  002174        
001961  002175        
001962  002176  //------------------------------------------------------------------//
001963  002177  // uSD/FLASH Function Prototypes                                    //
001964  002178  //------------------------------------------------------------------//
001965  002179  func media_Video("x", "y"), 0;                      // display movie at position x y
001966  002180  // Syntax: media_Video(x, y);
001967  002181  // Usage : media_Video(arg1, arg2);
001968  002182  // Notes : Play a Video/Animation clip from the uSD card at screen location
001969  002183  //       : specified by x,y (top left corner). The location of the clip in the
001970  002184  //       : uSD card must be specified by media_setSector(Video_Sector_Add) function.
001971  002185        
001972  002186  func media_VideoFrame("x", "y","framenumber"), 0;   // display required frame from a movie at x y
001973  002187  // Syntax: media_VideoFrame(Frame_number);
001974  002188  // Usage : arg1 := media_VideoFrame();
001975  002189  // Notes : After a pointer to a valid video has been set with media_SetSector,
001976  002190  //       : calling this function shows each fram sequentially, returning
001977  002191  //       : the number of frames remaining. The position of the image is
001978  002192  //     : at the current origin as set with gfx_MoveTo(...);
001979  002193        
001980  002194  func media_SetAdd("HiWord", "LoWord"), 0;           // set stream byte address
001981  002195  // Syntax: media_SetAdd(AddHiWord, AddLoWord);
001982  002196  // Usage : media_SetAdd(arg1, arg2);
001983  002197  // Notes : Set uSD internal Address pointer for bytewise access
001984  002198        
001985  002199  func media_SetSector("HiWord", "LoWord"), 0;        // set stream sector address
001986  002200  // Syntax: media_SetSector(SectHiWord, SectLoWord);
001987  002201  // Usage : media_SetSector(arg1, arg2);
001988  002202  // Notes : Set uSD internal Sector pointer for sector block access
001989  002203        
001990  002204  func media_RdSector("*destination"), 1;
001991  002205  // Syntax: media_RdSector(*destination);
001992  002206  // Usage : media_RdSector(rdblock);
001993  002207  // Notes : Reads and Returns 512 bytes (256 words) into a destination
001994  002208  //       : block (eg rdblock[256]) pointed to by the internal Sector pointer.
001995  002209  //       : After the read the Sector pointer is automatically incremented by 1.
001996  002210  //       : Returns TRUE if uSD response was TRUE
001997  002211        
001998  002212  func media_WrSector("*source"), 1;
001999  002213  // Syntax: media_WrSector(*source);
002000  002214  // Usage : media_WrSector(wrblock);
002001  002215  // Notes : Writes 512 bytes (256 words) from a source memory block
002002  002216  //       : (eg wrblock[256]) into the uSD card. After the write the Sector
002003  002217  //       : pointer is automatically incremented by 1.
002004  002218  //       : Returns TRUE if uSD response was TRUE
002005  002219        
002006  002220  func media_ReadByte(), 1;                // read a byte at the current stream position
002007  002221  // Syntax: media_RdByte();
002008  002222  // Usage : var := media_RdByte();
002009  002223  // Notes : Reads and Returns a single byte of data from the
002010  002224  //       : uSD card pointed to by the internal Address pointer.
002011  002225  //       : After the read the Address pointer is automatically
002012  002226  //       : incremented by 1.
002013  002227        
002014  002228  func media_ReadWord(), 1;                // read a word at the current stream position
002015  002229  // Syntax: media_ReadWord();
002016  002230  // Usage : var := media_ReadWord();
002017  002231  // *Notes : Reads and Returns a single word of data from the
002018  002232  //       : uSD card pointed to by the internal Address pointer.
002019  002233  //       : After the read the Address pointer is automatically
002020  002234  //       : incremented by 2.
002021  002235        
002022  002236  func media_WriteByte("byte"), 1;              // write a byte to the current stream position
002023  002237  // Syntax: media_WriteByte(arg1);
002024  002238  // Usage : var := media_WriteByte(arg1);
002025  002239  // *Notes : Writes and Returns xxxxx
002026  002240  //       : After the write the Address pointer is automatically
002027  002241  //       : incremented by 1.
002028  002242        
002029  002243  func media_WriteWord("word"), 1;            // write a word to the current stream position
002030  002244  // Syntax: media_WriteWord(arg1);
002031  002245  // Usage : var := media_WriteWord(arg1);
002032  002246  // *Notes : Writes and Returns xxxxx
002033  002247  //       : After the write the Address pointer is automatically
002034  002248  //       : incremented by 2.
002035  002249        
002036  002250  func media_Image("x", "y"), 0;            // display image at position x y
002037  002251  // Syntax: media_Image(x, y);
002038  002252  // Usage : media_Image(arg1, arg2);
002039  002253  // Notes : Display an image from the uSD card at screen location
002040  002254  //       : specified by x,y (top left corner). The location of the
002041  002255  //       : Image in the uSD card must be specified by
002042  002256  //       : media_setSector(Image_Sector_Add) function.
002043  002257        
002044  002258  func media_Flush(), 1;                    // after writing to media, flush the sector and write
002045  002259  // Syntax: media_Flush();
002046  002260  // Usage : var := media_Flush();
002047  002261  // *Notes : After writing any data to a sector, media_Flush() should be called to ensure that the current sector that
002048  002262  //       : is being written is correctly stored back to the media else write operations may be unpredictable.
002049  002263        
002050  002264  func media_Init(), 1;                    // initialize uSD card
002051  002265  // Usage : media_Init();
002052  002266  // Notes : Initialise uSD CARD
002053  002267  //       : Response: 0 = No Card
002054  002268  //       :           1 = Card Initialised
002055  002269        
002056  002270  func __reserved23(), 0; // do not remove
002057  002271  func __reserved24(), 0; // do not remove
002058  002272  func __reserved25(), 0; // do not remove
002059  002273  func __reserved26(), 0; // do not remove
002060  002274        
002061  002275  //==============================================//
002062  002276  // Communications Function Prototypes           //
002063  002277  // NB Primary COM port has fixed pins,          //
002064  002278  // COM1, COM2 and COM3 must have pins assigned. //
002065  002279  //==============================================//
002066  002280  func setbaud("baudnum"), 0;            // set baud rate of COM0
002067  002281  // Syntax: setbaud(baud_number);
002068  002282  // Usage : setbaud(BAUD_128000);        //Set baud rate to 128000bps
002069  002283  // *Notes : argument specifies the baud rate using pre-defined constant.
002070  002284  //       : The pre-defined constant is a value of 0-19 , and internally
002071  002285  //       : this is used as a table pointer to get the baud rate divisor
002072  002286  //       : value for one of the 20 selected baud rates, control is then
002073  002287  //       : passed to com_SetBaud(COM0, baudlookup[baud_number]);
002074  002288  //       : The pre-defined constants equate to a value of 0-19.
002075  002289  //       : If a value other than 0-19 is used, a run time error (eror 25)
002076  002290  //       : will occur.
002077  002291        
002078  002292  // baud divisor rates for legacy setbaud(n);
002079  002293  #CONST
002080  002315  #END
002081  002316        
002082  002317        
002083  002318  func com_SetBaud("comport","baudrate/10"), 1;
002084  002319  // Syntax: com_SetBaud("comport","baudrate/10");
002085  002320  // Usage : com_SetBaud(COM1, 960);   // set COM1 to 9600 baud
002086  002321  // Notes : sets to any viable baud rate from 160 to 655350
002087  002322  // return true if baud rate was acceptable
002088  002323        
002089  002324        
002090  002325  func COM1_RX_pin("pin"), 1;        // select the hardware pin for the COM1 receive line
002091  002326  // Usage : COM1_RX_pin(PA0); // set COM1 RX to PA0 pin
002092  002327  // Notes : Selects the hardware pin for COM1 receive line.
002093  002328  //       : Note that only a single pin can be mapped to COM1 RX.
002094  002329  //       : Pins that can be mapped to COMx TX are PA0 to PA13
002095  002330  //       : Pins that can't be mapped to COMx RX are PA14 and PA15
002096  002331  //       : If the pin argument is 0 the function has no effect
002097  002332  //       : The pin is automatically set to an input.
002098  002333  //       : If the COMx RX pin is set to same pin as COMx TX pin (eg for a loopback check)
002099  002334  //       : it is necessary to configure the input pin first, eg
002100  002335  //       :     COM1_RX_pin(PA7);     // configure COM1 RX to PA7 (this disconnects anything else)
002101  002336  //       :     COM1_TX_pin(PA7));    // configure COM1 TX to PA7
002102  002337  //       : Returns: Returns TRUE if function succeeded (usually ignored)
002103  002338        
002104  002339  func COM2_RX_pin("pin"), 1;        // select the hardware pin for the COM2 receive line
002105  002340  // Usage : COM2_RX_pin(PA0); // set COM2 RX to PA0 pin
002106  002341  // Notes : Selects the hardware pin for COM2 receive line.
002107  002342  //       : Note that only a single pin can be mapped to COM2 RX.
002108  002343  //       : Pins that can be mapped to COMx TX are PA0 to PA13
002109  002344  //       : Pins that can't be mapped to COMx RX are PA14 and PA15
002110  002345  //       : If the pin argument is 0 the function has no effect
002111  002346  //       : The pin is automatically set to an input.
002112  002347  //       : If the COMx RX pin is set to same pin as COMx TX pin (eg for a loopback check)
002113  002348  //       : it is necessary to configure the input pin first, eg
002114  002349  //       :     COM2_RX_pin(PA7);     // configure COM2 RX to PA7 (this disconnects anything else)
002115  002350  //       :     COM2_TX_pin(PA7));    // configure COM2 TX to PA7
002116  002351  //       : Returns: Returns TRUE if function succeeded (usually ignored)
002117  002352        
002118  002353  func COM3_RX_pin("pin"), 1;        // select the hardware pin for the COM3 receive line
002119  002354  // Usage : COM3_RX_pin(PA0); // set COM3 RX to PA0 pin
002120  002355  // Notes : Selects the hardware pin for COM3 receive line.
002121  002356  //       : Note that only a single pin can be mapped to COM3 RX.
002122  002357  //       : Pins that can be mapped to COMx TX are PA0 to PA13
002123  002358  //       : Pins that can't be mapped to COMx RX are PA14 and PA15
002124  002359  //       : If the pin argument is 0 the function has no effect
002125  002360  //       : The pin is automatically set to an input.
002126  002361  //       : If the COMx RX pin is set to same pin as COMx TX pin (eg for a loopback check)
002127  002362  //       : it is necessary to configure the input pin first, eg
002128  002363  //       :     COM3_RX_pin(PA7);     // configure COM3 RX to PA7 (this disconnects anything else)
002129  002364  //       :     COM3_TX_pin(PA7));    // configure COM3 TX to PA7
002130  002365  //       : Returns: Returns TRUE if function succeeded (usually ignored)
002131  002366        
002132  002367        
002133  002368  func COM1_TX_pin("pin"), 1;        // select the hardware pin for COM1 transmit line
002134  002369  // Syntax: COM1_TX_pin(pin);
002135  002370  // Usage : COM1_TX_pin(PA2); // set COM1 TX to PA2 pin
002136  002371  // Notes : Select the hardware pin for COMx transmit line.
002137  002372  //       : Pins that can be mapped to COMx TX are PA1, PA3 to PA9, and PA12 or PA13
002138  002373  //       : Pins that can't be mapped to COMx TX are PA0, PA2, PA10, PA11, PA14 and PA15
002139  002374  //       : If the pin argument is 0, COMx TX is disconnected from all pins.
002140  002375  //       : The pin is automatically set to an output.
002141  002376  //       : Returns: Returns TRUE if function succeeded (usually ignored)
002142  002377        
002143  002378  func COM2_TX_pin("pin"), 1;        // select the hardware pin for COM2 transmit line
002144  002379  // Syntax: COM2_TX_pin(pin);
002145  002380  // Usage : COM2_TX_pin(PA2); // set COM2 TX to PA2 pin
002146  002381  // Notes : Select the hardware pin for COMx transmit line.
002147  002382  //       : Pins that can be mapped to COMx TX are PA1, PA3 to PA9, and PA12 or PA13
002148  002383  //       : Pins that can't be mapped to COMx TX are PA0, PA2, PA10, PA11, PA14 and PA15
002149  002384  //       : If the pin argument is 0, COMx TX is disconnected from all pins.
002150  002385  //       : The pin is automatically set to an output.
002151  002386  //       : Returns: Returns TRUE if function succeeded (usually ignored)
002152  002387        
002153  002388  func COM3_TX_pin("pin"), 1;        // select the hardware pin for COM3 transmit line
002154  002389  // Syntax: COM3_TX_pin(pin);
002155  002390  // Usage : COM3_TX_pin(PA2); // set COM3 TX to PA2 pin
002156  002391  // Notes : Select the hardware pin for COMx transmit line.
002157  002392  //       : Pins that can be mapped to COMx TX are PA1, PA3 to PA9, and PA12 or PA13
002158  002393  //       : Pins that can't be mapped to COMx TX are PA0, PA2, PA10, PA11, PA14 and PA15
002159  002394  //       : If the pin argument is 0, COMx TX is disconnected from all pins.
002160  002395  //       : The pin is automatically set to an output.
002161  002396  //       : Returns: Returns TRUE if function succeeded (usually ignored)
002162  002397        
002163  002398  func com_Init("buf","bufsize","qualifier"), 0;  // set up a interrupt driven ring buffer for comms
002164  002399  // Syntax: com_Init(buffer, bufsize, qualifier);
002165  002400  // Usage1: com_Init(mybuf, 20, 0);
002166  002401  // Usage2: com_Init(mybuf, 20, ':');
002167  002402  // Notes : initialize a serial capture buffer for the comms input
002168  002403  //       : The program must declare a var array as a circular buffer.
002169  002404  //       : Usage1 declares a circular buffer which will continually
002170  002405  //       : buffer characters.
002171  002406  //       : Usage2 must receive ':' before any characters will
002172  002407  //       : accumulate in the buffer.
002173  002408        
002174  002409  func com1_Init("buf","bufsize","qualifier"), 0;
002175  002410  // Syntax: com1_Init(buffer, bufsize, qualifier);
002176  002411  // Usage1: com1_Init(mybuf, 20, 0);
002177  002412  // Usage2: com1_Init(mybuf, 20, ':');
002178  002413  // Notes : initialize a serial capture buffer for the comms input
002179  002414  //       : The program must declare a var array as a circular buffer.
002180  002415  //       : Usage1 declares a circular buffer which will continually
002181  002416  //       : buffer characters.
002182  002417  //       : Usage2 must receive ':' before any characters will
002183  002418  //       : accumulate in the buffer.
002184  002419        
002185  002420  func com2_Init("buf","bufsize","qualifier"), 0;
002186  002421  // Syntax: com2_Init(buffer, bufsize, qualifier);
002187  002422  // Usage1: com2_Init(mybuf, 20, 0);
002188  002423  // Usage2: com2_Init(mybuf, 20, ':');
002189  002424  // Notes : initialize a serial capture buffer for the comms input
002190  002425  //       : The program must declare a var array as a circular buffer.
002191  002426  //       : Usage1 declares a circular buffer which will continually
002192  002427  //       : buffer characters.
002193  002428  //       : Usage2 must receive ':' before any characters will
002194  002429  //       : accumulate in the buffer.
002195  002430        
002196  002431  func com3_Init("buf","bufsize","qualifier"), 0;
002197  002432  // Syntax: com3_Init(buffer, bufsize, qualifier);
002198  002433  // Usage1: com3_Init(mybuf, 20, 0);
002199  002434  // Usage2: com3_Init(mybuf, 20, ':');
002200  002435  // Notes : initialize a serial capture buffer for the comms input
002201  002436  //       : The program must declare a var array as a circular buffer.
002202  002437  //       : Usage1 declares a circular buffer which will continually
002203  002438  //       : buffer characters.
002204  002439  //       : Usage2 must receive ':' before any characters will
002205  002440  //       : accumulate in the buffer.
002206  002441        
002207  002442        
002208  002443  func serin(), 1;                // read a byte from primary com port COM0
002209  002444  // Syntax: serin();
002210  002445  // Usage : char := serin();
002211  002446  // Notes : Receives a character from the Serial Port COM0. The transmission format is:
002212  002447  //     : No Parity, 1 Stop Bit, 8 Data Bits (N,8,1).
002213  002448  //     : The default Baud Rate for COM0 is 115,200 bits per second or 115,200 baud.
002214  002449  //     : The baud rate can be changed under program control by using the setbaud(...)
002215  002450  //     : or the com_SetBaud(...) function.
002216  002451  //     : COM0 pins cannot be mapped, and are fixed as pins 42 and 33 (host adaptor / programming)
002217  002452  //     : serin may be buffered (refer to com_Init function above)
002218  002453  //     : Returns: -1 if no character is available
002219  002454  //     : Returns: -2 if a framing error or over-run has occurred (auto cleared)
002220  002455  //     : Returns: positive value 0 to 255 for a valid character received
002221  002456        
002222  002457  func serin1(), 1;
002223  002458  // Syntax: serinx();
002224  002459  // Usage : char := serinx();
002225  002460  // Notes : Receives a character from Serial Port COMx. The transmission format is:
002226  002461  //     : No Parity, 1 Stop Bit, 8 Data Bits (N,8,1).
002227  002462  //     : The default Baud Rate for COM1, COM2 and COM3 is 9600 baud.
002228  002463  //     : The baud rate can be changed under program control by using the com_SetBaud(...) function.
002229  002464  //     : serinx may be buffered (refer to comx_Init function above)
002230  002465  //     : serin RX pins must be mapped before use, (refer to COMx_RX_pin functions above)
002231  002466  //     : Returns: -1 if no character is available
002232  002467  //     : Returns: -2 if a framing error or over-run has occurred (auto cleared)
002233  002468  //     : Returns: positive value 0 to 255 for a valid character received
002234  002469        
002235  002470  func serin2(), 1;
002236  002471  // Syntax: serinx();
002237  002472  // Usage : char := serinx();
002238  002473  // Notes : Receives a character from Serial Port COMx. The transmission format is:
002239  002474  //     : No Parity, 1 Stop Bit, 8 Data Bits (N,8,1).
002240  002475  //     : The default Baud Rate for COM1, COM2 and COM3 is 9600 baud.
002241  002476  //     : The baud rate can be changed under program control by using the com_SetBaud(...) function.
002242  002477  //     : serinx may be buffered (refer to comx_Init function above)
002243  002478  //     : serin RX pins must be mapped before use, (refer to COMx_RX_pin functions above)
002244  002479  //     : Returns: -1 if no character is available
002245  002480  //     : Returns: -2 if a framing error or over-run has occurred (auto cleared)
002246  002481  //     : Returns: positive value 0 to 255 for a valid character received
002247  002482        
002248  002483  func serin3(), 1;
002249  002484  // Syntax: serinx();
002250  002485  // Usage : char := serinx();
002251  002486  // Notes : Receives a character from Serial Port COMx. The transmission format is:
002252  002487  //     : No Parity, 1 Stop Bit, 8 Data Bits (N,8,1).
002253  002488  //     : The default Baud Rate for COM1, COM2 and COM3 is 9600 baud.
002254  002489  //     : The baud rate can be changed under program control by using the com_SetBaud(...) function.
002255  002490  //     : serinx may be buffered (refer to comx_Init function above)
002256  002491  //     : serin RX pins must be mapped before use, (refer to COMx_RX_pin functions above)
002257  002492  //     : Returns: -1 if no character is available
002258  002493  //     : Returns: -2 if a framing error or over-run has occurred (auto cleared)
002259  002494  //     : Returns: positive value 0 to 255 for a valid character received
002260  002495        
002261  002496  func serout("char"), 0;                // write a byte to COM0
002262  002497  // Syntax: serout1("char");
002263  002498  // Usage : serout1(ch);
002264  002499  // Notes : send character to COM0
002265  002500        
002266  002501  func serout1("char"), 0;
002267  002502  // Syntax: seroutx("char");
002268  002503  // Usage : serout1(ch);
002269  002504  // Notes : send character to COMx
002270  002505        
002271  002506  func serout2("char"), 0;
002272  002507  // Syntax: seroutx("char");
002273  002508  // Usage : serout1(ch);
002274  002509  // Notes : send character to COMx
002275  002510        
002276  002511  func serout3("char"), 0;
002277  002512  // Syntax: seroutx("char");
002278  002513  // Usage : serout1(ch);
002279  002514  // Notes : send character to COMx
002280  002515        
002281  002516  func com_Reset(), 0;                 // reset the comms receiver
002282  002517  // Syntax: com_Reset();
002283  002518  // Usage : com_Reset();
002284  002519  // Notes : reset comms to default polled mode
002285  002520        
002286  002521  func com1_Reset(), 0;
002287  002522  // Syntax: com_Reset();
002288  002523  // Usage : com_Reset();
002289  002524  // Notes : reset comms to default polled mode
002290  002525        
002291  002526  func com2_Reset(), 0;
002292  002527  // Syntax: com_Reset();
002293  002528  // Usage : com_Reset();
002294  002529  // Notes : reset comms to default polled mode
002295  002530        
002296  002531  func com3_Reset(), 0;
002297  002532  // Syntax: com_Reset();
002298  002533  // Usage : com_Reset();
002299  002534  // Notes : reset comms to default polled mode
002300  002535        
002301  002536  func com_Count(), 1;                // return count of characters in receive buffer
002302  002537  // Syntax: com_Count();
002303  002538  // Usage : arg := com_Count();
002304  002539  // Notes : return count of buffered characters in buffer attachment
002305  002540        
002306  002541  func com1_Count(), 1;
002307  002542  // Syntax: com_Count();
002308  002543  // Usage : arg := com_Count();
002309  002544  // Notes : return count of buffered characters in buffer attachment
002310  002545        
002311  002546  func com2_Count(), 1;
002312  002547  // Syntax: com_Count();
002313  002548  // Usage : arg := com_Count();
002314  002549  // Notes : return count of buffered characters in buffer attachment
002315  002550        
002316  002551  func com3_Count(), 1;
002317  002552  // Syntax: com_Count();
002318  002553  // Usage : arg := com_Count();
002319  002554  // Notes : return count of buffered characters in buffer attachment
002320  002555        
002321  002556  func com_Full(), 1;                // return TRUE if receiver buffer filled to capcity
002322  002557  // Syntax: com_Full();
002323  002558  // Usage : if (com_Full() ,,,, go read buffer;
002324  002559  // Notes : return true if buffer full (not necessarily an error if
002325  002560  //       : buffer is sized to a packet size)
002326  002561        
002327  002562  func com1_Full(), 1;
002328  002563  // Syntax: com_Full();
002329  002564  // Usage : if (com_Full() ,,,, go read buffer;
002330  002565  // Notes : return true if buffer full (not necessarily an error if
002331  002566  //       : buffer is sized to a packet size)
002332  002567        
002333  002568  func com2_Full(), 1;
002334  002569  // Syntax: com_Full();
002335  002570  // Usage : if (com_Full() ,,,, go read buffer;
002336  002571  // Notes : return true if buffer full (not necessarily an error if
002337  002572  //       : buffer is sized to a packet size)
002338  002573        
002339  002574  func com3_Full(), 1;
002340  002575  // Syntax: com_Full();
002341  002576  // Usage : if (com_Full() ,,,, go read buffer;
002342  002577  // Notes : return true if buffer full (not necessarily an error if
002343  002578  //       : buffer is sized to a packet size)
002344  002579        
002345  002580  func com_Error(), 1;                // return comms errors comms error occurred
002346  002581  // Syntax: comx_Error();
002347  002582  // Usage : if (com_Error() ) ...... take recovery action;
002348  002583  // Notes : return non zero if any errors low level comms errors occured
002349  002584  // returns :
002350  002585  // bit0 = Receiver Overflow Error
002351  002586  // bit1 = Receiver Framing Error
002352  002587  // bit2 = Transmit Buffer Overflow
002353  002588        
002354  002589  func com1_Error(), 1;
002355  002590  // Syntax: comx_Error();
002356  002591  // Usage : if (com_Error() ) ...... take recovery action;
002357  002592  // Notes : return non zero if any errors low level comms errors occured
002358  002593  // returns :
002359  002594  // bit0 = Receiver Overflow Error
002360  002595  // bit1 = Receiver Framing Error
002361  002596  // bit2 = Transmit Buffer Overflow
002362  002597        
002363  002598  func com2_Error(), 1;
002364  002599  // Syntax: comx_Error();
002365  002600  // Usage : if (com_Error() ) ...... take recovery action;
002366  002601  // Notes : return non zero if any errors low level comms errors occured
002367  002602  // returns :
002368  002603  // bit0 = Receiver Overflow Error
002369  002604  // bit1 = Receiver Framing Error
002370  002605  // bit2 = Transmit Buffer Overflow
002371  002606        
002372  002607  func com3_Error(), 1;
002373  002608  // Syntax: comx_Error();
002374  002609  // Usage : if (com_Error() ) ...... take recovery action;
002375  002610  // Notes : return non zero if any errors low level comms errors occured
002376  002611  // returns :
002377  002612  // bit0 = Receiver Overflow Error
002378  002613  // bit1 = Receiver Framing Error
002379  002614  // bit2 = Transmit Buffer Overflow
002380  002615        
002381  002616  func com_Sync(), 1;                // returns TRUE if qualifier has been received
002382  002617  // Usage : comx_Sync();
002383  002618  // return true if sync character has been received in com_Init("...") mode
002384  002619        
002385  002620  func com1_Sync(), 1;
002386  002621  // Usage : comx_Sync();
002387  002622  // return true if sync character has been received in com_Init("...") mode
002388  002623        
002389  002624  func com2_Sync(), 1;
002390  002625  // Usage : comx_Sync();
002391  002626  // return true if sync character has been received in com_Init("...") mode
002392  002627        
002393  002628  func com3_Sync(), 1;
002394  002629  // Usage : comx_Sync();
002395  002630  // return true if sync character has been received in com_Init("...") mode
002396  002631        
002397  002632        
002398  002633  func com_TXbuffer("buf", "bufsize", "pin"), 0;    // sets the buffer location for buffered transmission
002399  002634  // Usage : com_TXbuffer(mybuf, 1024, PA0);    // set the TX buffer, using PA0 for turnaround
002400  002635  // Usage : com_TXbuffer(0, 0, 0);             // revert to non buffered service
002401  002636  // Notes : initialize a serial buffer for the COM0 output.
002402  002637  //       : The program must declare a var array as a circular buffer.
002403  002638  //       : When a TX buffer is declared for comms, the transmission
002404  002639  //       : of characters becomes non blocking. If the buffer has
002405  002640  //       : insufficient space to accept the next character from a
002406  002641  //       : serout_x() function, the excess characters will be ignored,
002407  002642  //       : and the com_Full_x() error will be asserted.   If the
002408  002643  //       : TX buffer is no longer required, just set the buffer pointer
002409  002644  //       : to zero, the size in this case doesnt matter and is ignored.
002410  002645  //       : The function can resize or reallocated to another buffer at
002411  002646  //       : any time. The buffer is flushed before any changes are made.
002412  002647  //       : "pin" designates an IO pin to control a bi-directional
002413  002648  //       : control device for half duplex mode. "pin" will go HI at the
002414  002649  //       : start of a transmission, and will return low after the final
002415  002650  //       : byte is transmitted. If not required, just set "pin" to zero.
002416  002651        
002417  002652  func com1_TXbuffer("buf", "bufsize", "pin"), 0;
002418  002653  // Usage : com1_TXbuffer(mybuf, 1024, PA0);    // set the TX buffer, using PA0 for turnaround
002419  002654  // Usage : com1_TXbuffer(0, 0, 0);              // revert to non buffered service
002420  002655  // Notes : initialize a serial buffer for the COM0 output.
002421  002656  //       : The program must declare a var array as a circular buffer.
002422  002657  //       : When a TX buffer is declared for comms, the transmission
002423  002658  //       : of characters becomes non blocking. If the buffer has
002424  002659  //       : insufficient space to accept the next character from a
002425  002660  //       : serout_x() function, the excess characters will be ignored,
002426  002661  //       : and the com_Full_x() error will be asserted.   If the
002427  002662  //       : TX buffer is no longer required, just set the buffer pointer
002428  002663  //       : to zero, the size in this case doesnt matter and is ignored.
002429  002664  //       : The function can resize or reallocated to another buffer at
002430  002665  //       : any time. The buffer is flushed before any changes are made.
002431  002666  //       : "pin" designates an IO pin to control a bi-directional
002432  002667  //       : control device for half duplex mode. "pin" will go HI at the
002433  002668  //       : start of a transmission, and will return low after the final
002434  002669  //       : byte is transmitted. If not required, just set "pin" to zero.
002435  002670        
002436  002671  func com2_TXbuffer("buf", "bufsize", "pin"), 0;
002437  002672  // Usage : com2_TXbuffer(mybuf, 1024, PA0);    // set the TX buffer, using PA0 for turnaround
002438  002673  // Usage : com2_TXbuffer(0, 0, 0);              // revert to non buffered service
002439  002674  // Notes : initialize a serial buffer for the COM0 output.
002440  002675  //       : The program must declare a var array as a circular buffer.
002441  002676  //       : When a TX buffer is declared for comms, the transmission
002442  002677  //       : of characters becomes non blocking. If the buffer has
002443  002678  //       : insufficient space to accept the next character from a
002444  002679  //       : serout_x() function, the excess characters will be ignored,
002445  002680  //       : and the com_Full_x() error will be asserted.   If the
002446  002681  //       : TX buffer is no longer required, just set the buffer pointer
002447  002682  //       : to zero, the size in this case doesnt matter and is ignored.
002448  002683  //       : The function can resize or reallocated to another buffer at
002449  002684  //       : any time. The buffer is flushed before any changes are made.
002450  002685  //       : "pin" designates an IO pin to control a bi-directional
002451  002686  //       : control device for half duplex mode. "pin" will go HI at the
002452  002687  //       : start of a transmission, and will return low after the final
002453  002688  //       : byte is transmitted. If not required, just set "pin" to zero.
002454  002689        
002455  002690  func com3_TXbuffer("buf", "bufsize", "pin"), 0;
002456  002691  // Usage : com3_TXbuffer(mybuf, 1024, PA0);    // set the TX buffer, using PA0 for turnaround
002457  002692  // Usage : com3_TXbuffer(0, 0, 0);              // revert to non buffered service
002458  002693  // Notes : initialize a serial buffer for the COM0 output.
002459  002694  //       : The program must declare a var array as a circular buffer.
002460  002695  //       : When a TX buffer is declared for comms, the transmission
002461  002696  //       : of characters becomes non blocking. If the buffer has
002462  002697  //       : insufficient space to accept the next character from a
002463  002698  //       : serout_x() function, the excess characters will be ignored,
002464  002699  //       : and the com_Full_x() error will be asserted.   If the
002465  002700  //       : TX buffer is no longer required, just set the buffer pointer
002466  002701  //       : to zero, the size in this case doesnt matter and is ignored.
002467  002702  //       : The function can resize or reallocated to another buffer at
002468  002703  //       : any time. The buffer is flushed before any changes are made.
002469  002704  //       : "pin" designates an IO pin to control a bi-directional
002470  002705  //       : control device for half duplex mode. "pin" will go HI at the
002471  002706  //       : start of a transmission, and will return low after the final
002472  002707  //       : byte is transmitted. If not required, just set "pin" to zero.
002473  002708        
002474  002709        
002475  002710  func com_TXcount(), 1;                // return count of characters in COM0 TX buffer
002476  002711  // Syntax: com_TXcount();
002477  002712  // Usage : arg := com_Count();
002478  002713  // Notes : return count of characters remaining in COM0 transmit buffer
002479  002714  //       : that was previously allocated with com_TXbuffer(...);
002480  002715        
002481  002716  func com1_TXcount(), 1;
002482  002717  // Syntax: com_TXcount();
002483  002718  // Usage : arg := com_Count();
002484  002719  // Notes : return count of characters remaining in COM0 transmit buffer
002485  002720  //       : that was previously allocated with com_TXbuffer(...);
002486  002721        
002487  002722  func com2_TXcount(), 1;
002488  002723  // Syntax: com_TXcount();
002489  002724  // Usage : arg := com_Count();
002490  002725  // Notes : return count of characters remaining in COM0 transmit buffer
002491  002726  //       : that was previously allocated with com_TXbuffer(...);
002492  002727        
002493  002728  func com3_TXcount(), 1;
002494  002729  // Syntax: com_TXcount();
002495  002730  // Usage : arg := com_Count();
002496  002731  // Notes : return count of characters remaining in COM0 transmit buffer
002497  002732  //       : that was previously allocated with com_TXbuffer(...);
002498  002733        
002499  002734  func com_TXemptyEvent("function"), 1;  // sets a function to be called when COM0 TX buffer empty
002500  002735  // Usage : arg := com_TXemptyEvent();
002501  002736  // Notes : If a comms TX buffer that was previously allocated with
002502  002737  //       : com_TXbuffer(...);, this function can be used to set up
002503  002738  //       : a function to be called when the COM0 TX buffer is empty.
002504  002739  //       : This is useful for either reloading the TX buffer, setting
002505  002740  //       : or clearing a pin to change the direction of eg a RS485
002506  002741  //       : line driver, or any other form of traffic control.
002507  002742  //       : The event function must not have any parameters.
002508  002743  //       : To disable the event, simply call com_TXemptyEvent(0).
002509  002744  //       : com_TXbuffer(...); also resets any active event.
002510  002745  //       : com_TXemptyEvent returns any previous event function
002511  002746  //       : address, or zero if there was no previous function.
002512  002747        
002513  002748  func com1_TXemptyEvent("function"), 1;
002514  002749  // Usage : arg := com1_TXemptyEvent();
002515  002750  // Notes : If a comms TX buffer that was previously allocated with
002516  002751  //       : com_TXbuffer(...);, this function can be used to set up
002517  002752  //       : a function to be called when the COM0 TX buffer is empty.
002518  002753  //       : This is useful for either reloading the TX buffer, setting
002519  002754  //       : or clearing a pin to change the direction of eg a RS485
002520  002755  //       : line driver, or any other form of traffic control.
002521  002756  //       : The event function must not have any parameters.
002522  002757  //       : To disable the event, simply call com_TXemptyEvent(0).
002523  002758  //       : com_TXbuffer(...); also resets any active event.
002524  002759  //       : com_TXemptyEvent returns any previous event function
002525  002760  //       : address, or zero if there was no previous function.
002526  002761        
002527  002762  func com2_TXemptyEvent("function"), 1;
002528  002763  // Usage : arg := com2_TXemptyEvent();
002529  002764  // Notes : If a comms TX buffer that was previously allocated with
002530  002765  //       : com_TXbuffer(...);, this function can be used to set up
002531  002766  //       : a function to be called when the COM0 TX buffer is empty.
002532  002767  //       : This is useful for either reloading the TX buffer, setting
002533  002768  //       : or clearing a pin to change the direction of eg a RS485
002534  002769  //       : line driver, or any other form of traffic control.
002535  002770  //       : The event function must not have any parameters.
002536  002771  //       : To disable the event, simply call com_TXemptyEvent(0).
002537  002772  //       : com_TXbuffer(...); also resets any active event.
002538  002773  //       : com_TXemptyEvent returns any previous event function
002539  002774  //       : address, or zero if there was no previous function.
002540  002775        
002541  002776  func com3_TXemptyEvent("function"), 1;
002542  002777  // Usage : arg := com3_TXemptyEvent();
002543  002778  // Notes : If a comms TX buffer that was previously allocated with
002544  002779  //       : com_TXbuffer(...);, this function can be used to set up
002545  002780  //       : a function to be called when the COM0 TX buffer is empty.
002546  002781  //       : This is useful for either reloading the TX buffer, setting
002547  002782  //       : or clearing a pin to change the direction of eg a RS485
002548  002783  //       : line driver, or any other form of traffic control.
002549  002784  //       : The event function must not have any parameters.
002550  002785  //       : To disable the event, simply call com_TXemptyEvent(0).
002551  002786  //       : com_TXbuffer(...); also resets any active event.
002552  002787  //       : com_TXemptyEvent returns any previous event function
002553  002788  //       : address, or zero if there was no previous function.
002554  002789        
002555  002790  func com_TXbufferHold("state"), 1; // hold or release a com_TXbuffer
002556  002791  // Usage : arg := com_TXbufferHold(OFF);  // start sending the buffer
002557  002792  // Notes : Expecting that a comms TX buffer that was previously allocated with
002558  002793  //       : com_TXbuffer(...);, com_TXbufferHold(ON) can be used to stop
002559  002794  //       : the buffer being sent wile it is being loaded. Mormally, when
002560  002795  //       : using buffered comms, the transmit process will begin
002561  002796  //       : immediately. This is often undesirable for 2 reasons,
002562  002797  //       : 1] you may wish to build a packet then send it later
002563  002798  //       : 2] when using com_TXemptyEvent erroneous empty events will occur
002564  002799  //       : as the FIFO buffer is constantly trying to empty while
002565  002800  //       : you are busy tring to fill it.
002566  002801  // return -1 if function is called illegally when TX comms is not buffered.
002567  002802  // return buffer count when called with argument of 1, eg com_TXbufferHold(ON)
002568  002803  // return 0 when argument is zero, eg com_TXbufferHold(OFF)
002569  002804        
002570  002805  func com1_TXbufferHold("state"), 1;
002571  002806  // Usage : arg := com1_TXbufferHold(OFF);  // start sending the buffer
002572  002807  // Notes : Expecting that a comms TX buffer that was previously allocated with
002573  002808  //       : com_TXbuffer(...);, com_TXbufferHold(ON) can be used to stop
002574  002809  //       : the buffer being sent wile it is being loaded. Mormally, when
002575  002810  //       : using buffered comms, the transmit process will begin
002576  002811  //       : immediately. This is often undesirable for 2 reasons,
002577  002812  //       : 1] you may wish to build a packet then send it later
002578  002813  //       : 2] when using com_TXemptyEvent erroneous empty events will occur
002579  002814  //       : as the FIFO buffer is constantly trying to empty while
002580  002815  //       : you are busy tring to fill it.
002581  002816  // return -1 if function is called illegally when TX comms is not buffered.
002582  002817  // return buffer count when called with argument of 1, eg com_TXbufferHold(ON)
002583  002818  // return 0 when argument is zero, eg com_TXbufferHold(OFF)
002584  002819        
002585  002820  func com2_TXbufferHold("state"), 1;
002586  002821  // Usage : arg := com2_TXbufferHold(OFF);  // start sending the buffer
002587  002822  // Notes : Expecting that a comms TX buffer that was previously allocated with
002588  002823  //       : com_TXbuffer(...);, com_TXbufferHold(ON) can be used to stop
002589  002824  //       : the buffer being sent wile it is being loaded. Mormally, when
002590  002825  //       : using buffered comms, the transmit process will begin
002591  002826  //       : immediately. This is often undesirable for 2 reasons,
002592  002827  //       : 1] you may wish to build a packet then send it later
002593  002828  //       : 2] when using com_TXemptyEvent erroneous empty events will occur
002594  002829  //       : as the FIFO buffer is constantly trying to empty while
002595  002830  //       : you are busy tring to fill it.
002596  002831  // return -1 if function is called illegally when TX comms is not buffered.
002597  002832  // return buffer count when called with argument of 1, eg com_TXbufferHold(ON)
002598  002833  // return 0 when argument is zero, eg com_TXbufferHold(OFF)
002599  002834        
002600  002835  func com3_TXbufferHold("state"), 1;
002601  002836  // Usage : arg := com3_TXbufferHold(OFF);  // start sending the buffer
002602  002837  // Notes : Expecting that a comms TX buffer that was previously allocated with
002603  002838  //       : com_TXbuffer(...);, com_TXbufferHold(ON) can be used to stop
002604  002839  //       : the buffer being sent wile it is being loaded. Mormally, when
002605  002840  //       : using buffered comms, the transmit process will begin
002606  002841  //       : immediately. This is often undesirable for 2 reasons,
002607  002842  //       : 1] you may wish to build a packet then send it later
002608  002843  //       : 2] when using com_TXemptyEvent erroneous empty events will occur
002609  002844  //       : as the FIFO buffer is constantly trying to empty while
002610  002845  //       : you are busy tring to fill it.
002611  002846  // return -1 if function is called illegally when TX comms is not buffered.
002612  002847  // return buffer count when called with argument of 1, eg com_TXbufferHold(ON)
002613  002848  // return 0 when argument is zero, eg com_TXbufferHold(OFF)
002614  002849        
002615  002850  func com_Mode("8" ,"N", "1", "comport"), 1 ;
002616  002851  // Syntax   : comx_Mode("databits", "parity", "Stopbits", "comport");
002617  002852  // Usage    : comx_Mode(8, 'N', 1, COM0);                        // set COM0 to 8N1
002618  002853  // *Notes   : Data Bits must be 8
002619  002854  //          : Parity may be 'N', 'O' or 'E'.
002620  002855  //          : Stop Bits may be 1 or 2.
002621  002856  // returns true if mode was acceptable
002622  002857        
002623  002858  func com_TXblock("buf", "bufsize"), 0;                       // commence a block transmission
002624  002859  // Syntax   : com_TXblock("buf", "bufsize");
002625  002860  // Usage    : com_TXblock(mybuf, 30);                         // point to the TX buffer and send 30 character
002626  002861  // *Notes   : Bufsize bytes are transmitted to the serial port from the string pointer "buf".
002627  002862  //          : if a transmit buffer is active and space is available this function will return almost
002628  002863  //          : immediately otherwise it will block until until the space is available, or the data is transmitted.
002629  002864        
002630  002865  func com_RXblock("buf", "bufsize"), 0;                       // commence a block reception
002631  002866  // Syntax   : com_RXblock("buf", "bufsize");
002632  002867  // Usage    : com_RXblock(mybuf, 30);                        // point to the RX buffer and receive 30 character
002633  002868  // *Notes   : Bufsize bytes are received from the serial port to the string pointer "buf".
002634  002869  //          : if a receive buffer is active and bufsize characters are available this function will return almost
002635  002870  //          : immediately otherwise it will block until until the required bytes are received.
002636  002871        
002637  002872  func __reserved30(), 0; // do not remove
002638  002873        
002639  002874  //------------------------------------------------------------------//
002640  002875  //        Function Prototypes for I2C
002641  002876  //------------------------------------------------------------------//
002642  002877  func I2C1_Open("speed", "SCLpin", "SDApin"), 1;
002643  002878  // Syntax : I2C1_Openx(speed, SCLpin, SDApin),
002644  002879  // Usage  : I2C1_Open(I2C_MED, PA2, PA3);
002645  002880  // Notes  : configures the required I2C module
002646  002881  //        : see 'I2C timing related constants' and 'pin constants'
002647  002882  //        : Pins that can be mapped to SCLpin and SDApin are PA0 to PA13
002648  002883  //        : Pins that can't be mapped to SCLpin or SDApin are PA14 and PA15
002649  002884  //        : For I2C speeds of I2C_MED and I2C_FAST SCLpin may be PA14 and SDApin may be PA15
002650  002885  //        : This is a 'special case' to support Slew rate control for I2C_MED and also properly support I2C_FAST
002651  002886  //        : For other pin combinations I2C_MED does not support Slew rate control and I2C_FAST does not fully run at 1Mhz
002652  002887  // Returns: True if successful
002653  002888        
002654  002889        
002655  002890  func I2C2_Open("speed", "SCLpin", "SDApin"), 1;
002656  002891  // Syntax : I2C2_Openx(speed, SCLpin, SDApin),
002657  002892  // Usage  : I2C2_Open(I2C_MED, PA2, PA3);
002658  002893  // Notes  : configures the required I2C module
002659  002894  //        : see 'I2C timing related constants' and 'pin constants'
002660  002895  //        : Pins that can be mapped to SCLpin and SDApin are PA0 to PA13
002661  002896  //        : Pins that can't be mapped to SCLpin or SDApin are PA14 and PA15
002662  002897  //        : For I2C speeds of I2C_MED and I2C_FAST SCLpin may be PA14 and SDApin may be PA15
002663  002898  //        : This is a 'special case' to support Slew rate control for I2C_MED and also properly support I2C_FAST
002664  002899  //        : For other pin combinations I2C_MED does not support Slew rate control and I2C_FAST does not fully run at 1Mhz
002665  002900  // Returns: True if successful
002666  002901        
002667  002902        
002668  002903  func I2C3_Open("speed", "SCLpin", "SDApin"), 1;
002669  002904  // Syntax : I2C3_Openx(speed, SCLpin, SDApin),
002670  002905  // Usage  : I2C3_Open(I2C_MED, PA2, PA3);
002671  002906  // Notes  : configures the required I2C module
002672  002907  //        : see 'I2C timing related constants' and 'pin constants'
002673  002908  //        : Pins that can be mapped to SCLpin and SDApin are PA0 to PA13
002674  002909  //        : Pins that can't be mapped to SCLpin or SDApin are PA14 and PA15
002675  002910  //        : For I2C speeds of I2C_MED and I2C_FAST SCLpin may be PA14 and SDApin may be PA15
002676  002911  //        : This is a 'special case' to support Slew rate control for I2C_MED and also properly support I2C_FAST
002677  002912  //        : For other pin combinations I2C_MED does not support Slew rate control and I2C_FAST does not fully run at 1Mhz
002678  002913  // Returns: True if successful
002679  002914        
002680  002915        
002681  002916  func I2C1_Close(), 0;
002682  002917  // Usage : I2C1_Close();
002683  002918  // Notes : disables the I2C1 module.
002684  002919        
002685  002920  func I2C2_Close(), 0;
002686  002921  // Usage : I2C2_Close();
002687  002922  // Notes : disables the I2C2 module.
002688  002923        
002689  002924  func I2C3_Close(), 0;
002690  002925  // Usage : I2C3_Close();
002691  002926  // Notes : disables the I2C3 module.
002692  002927        
002693  002928  func I2C1_Start(), 1;
002694  002929  // Syntax: I2C1_Start();
002695  002930  // Usage : I2C1_Start();
002696  002931  // Notes : generates a Start condition.
002697  002932  //       : returns true if successful (usually ignored)
002698  002933        
002699  002934  func I2C2_Start(), 1;
002700  002935  // Syntax: I2C2_Start();
002701  002936  // Usage : I2C2_Start();
002702  002937  // Notes : generates a Start condition.
002703  002938  //       : returns true if successful (usually ignored)
002704  002939        
002705  002940  func I2C3_Start(), 1;
002706  002941  // Syntax: I2C3_Start();
002707  002942  // Usage : I2C3_Start();
002708  002943  // Notes : generates a Start condition.
002709  002944  //       : returns true if successful (usually ignored)
002710  002945        
002711  002946  func I2C1_Stop(), 1;
002712  002947  // Syntax: I2C1_Stop();
002713  002948  // Usage : I2C1_Stop();
002714  002949  // Notes : generates a Stop condition.
002715  002950  //       : returns true if successful (usually ignored)
002716  002951        
002717  002952  func I2C2_Stop(), 1;
002718  002953  // Syntax: I2C2_Stop();
002719  002954  // Usage : I2C2_Stop();
002720  002955  // Notes : generates a Stop condition.
002721  002956  //       : returns true if successful (usually ignored)
002722  002957        
002723  002958  func I2C3_Stop(), 1;
002724  002959  // Syntax: I2C3_Stop();
002725  002960  // Usage : I2C3_Stop();
002726  002961  // Notes : generates a Stop condition.
002727  002962  //       : returns true if successful (usually ignored)
002728  002963        
002729  002964  func I2C1_Restart(), 1;
002730  002965  // Syntax: I2C1_Restart();
002731  002966  // Usage : I2C1_Restart();
002732  002967  // Notes : generates a Restart condition.
002733  002968  //       : returns true if successful (usually ignored)
002734  002969        
002735  002970  func I2C2_Restart(), 1;
002736  002971  // Syntax: I2C2_Restart();
002737  002972  // Usage : I2C2_Restart();
002738  002973  // Notes : generates a Restart condition.
002739  002974  //       : returns true if successful (usually ignored)
002740  002975        
002741  002976  func I2C3_Restart(), 1;
002742  002977  // Syntax: I2C3_Restart();
002743  002978  // Usage : I2C3_Restart();
002744  002979  // Notes : generates a Restart condition.
002745  002980  //       : returns true if successful (usually ignored)
002746  002981        
002747  002982  func I2C1_Read(), 1;
002748  002983  // Syntax: I2C1_Read();
002749  002984  // Usage : ch := I2C1_Read();
002750  002985  // Notes : reads a single byte from the I2C Bus.
002751  002986        
002752  002987  func I2C2_Read(), 1;
002753  002988  // Syntax: I2C2_Read();
002754  002989  // Usage : ch := I2C2_Read();
002755  002990  // Notes : reads a single byte from the I2C Bus.
002756  002991        
002757  002992  func I2C3_Read(), 1;
002758  002993  // Syntax: I2C3_Read();
002759  002994  // Usage : ch := I2C3_Read();
002760  002995  // Notes : reads a single byte from the I2C Bus.
002761  002996        
002762  002997  func I2C1_Write("byte"), 1;
002763  002998  // Syntax: I2C1_Write(byte);
002764  002999  // Usage : r := I2C1_Write(ch);
002765  003000  // Notes : is used to write a byte to the I2C bus.
002766  003001  //       : Returns 0 if failed, 1 if no ack, 2 if ack
002767  003002        
002768  003003  func I2C2_Write("byte"), 1;
002769  003004  // Syntax: I2C2_Write(byte);
002770  003005  // Usage : r := I2C2_Write(ch);
002771  003006  // Notes : is used to write a byte to the I2C bus.
002772  003007  //       : Returns 0 if failed, 1 if no ack, 2 if ack
002773  003008        
002774  003009  func I2C3_Write("byte"), 1;
002775  003010  // Syntax: I2C3_Write(byte);
002776  003011  // Usage : r := I2C3_Write(ch);
002777  003012  // Notes : is used to write a byte to the I2C bus.
002778  003013  //       : Returns 0 if failed, 1 if no ack, 2 if ack
002779  003014        
002780  003015  func I2C1_Ack(), 0;
002781  003016  // Syntax: I2C1_Ack();
002782  003017  // Usage : I2C1_Ack();
002783  003018  // Notes : generates the acknowledge condition.
002784  003019        
002785  003020  func I2C2_Ack(), 0;
002786  003021  // Syntax: I2C2_Ack();
002787  003022  // Usage : I2C2_Ack();
002788  003023  // Notes : generates the acknowledge condition.
002789  003024        
002790  003025  func I2C3_Ack(), 0;
002791  003026  // Syntax: I2C3_Ack();
002792  003027  // Usage : I2C3_Ack();
002793  003028  // Notes : generates the acknowledge condition.
002794  003029        
002795  003030  func I2C1_Nack(), 0;
002796  003031  // Syntax: I2C1_Nack();
002797  003032  // Usage : I2C1_Nack();
002798  003033  // Notes : generates the negative acknowledge condition.
002799  003034        
002800  003035  func I2C2_Nack(), 0;
002801  003036  // Syntax: I2C2_Nack();
002802  003037  // Usage : I2C2_Nack();
002803  003038  // Notes : generates the negative acknowledge condition.
002804  003039        
002805  003040  func I2C3_Nack(), 0;
002806  003041  // Syntax: I2C3_Nack();
002807  003042  // Usage : I2C3_Nack();
002808  003043  // Notes : generates the negative acknowledge condition.
002809  003044        
002810  003045  func I2C1_AckStatus(), 1;
002811  003046  // Syntax: I2C1_AckStatus();
002812  003047  // Usage : r := I2C1_AckStatus();
002813  003048  // Notes : returns the ACK status from the device.
002814  003049        
002815  003050  func I2C2_AckStatus(), 1;
002816  003051  // Syntax: I2C2_AckStatus();
002817  003052  // Usage : r := I2C2_AckStatus();
002818  003053  // Notes : returns the ACK status from the device.
002819  003054        
002820  003055  func I2C3_AckStatus(), 1;
002821  003056  // Syntax: I2C3_AckStatus();
002822  003057  // Usage : r := I2C3_AckStatus();
002823  003058  // Notes : returns the ACK status from the device.
002824  003059        
002825  003060  func I2C1_AckPoll("control"), 1;
002826  003061  // Syntax: I2C1_AckPoll();
002827  003062  // Usage : r := I2C1_AckPoll(0xA0);
002828  003063  // Notes : waits for a device to return from ACK polling.
002829  003064        
002830  003065  func I2C2_AckPoll("control"), 1;
002831  003066  // Syntax: I2C2_AckPoll();
002832  003067  // Usage : r := I2C2_AckPoll(0xA0);
002833  003068  // Notes : waits for a device to return from ACK polling.
002834  003069        
002835  003070  func I2C3_AckPoll("control"), 1;
002836  003071  // Syntax: I2C3_AckPoll();
002837  003072  // Usage : r := I2C3_AckPoll(0xA0);
002838  003073  // Notes : waits for a device to return from ACK polling.
002839  003074        
002840  003075  func I2C1_Idle(), 1;
002841  003076  // Syntax : I2C1_Idle();
002842  003077  // Usage  : r := I2C1_Idle();
002843  003078  // Notes  : waits until the I2C Bus is Inactive.
002844  003079  //        : Times out if bus not idle within 1 second
002845  003080  // Returns: TRUE if successful, else failed (timed out)
002846  003081        
002847  003082  func I2C2_Idle(), 1;
002848  003083  // Syntax : I2C2_Idle();
002849  003084  // Usage  : r := I2C2_Idle();
002850  003085  // Notes  : waits until the I2C Bus is Inactive.
002851  003086  //        : Times out if bus not idle within 1 second
002852  003087  // Returns: TRUE if successful, else failed (timed out)
002853  003088        
002854  003089  func I2C3_Idle(), 1;
002855  003090  // Syntax : I2C3_Idle();
002856  003091  // Usage  : r := I2C3_Idle();
002857  003092  // Notes  : waits until the I2C Bus is Inactive.
002858  003093  //        : Times out if bus not idle within 1 second
002859  003094  // Returns: TRUE if successful, else failed (timed out)
002860  003095        
002861  003096        
002862  003097  func I2C1_Gets("buffer", "size"), 1;
002863  003098  // Syntax: I2C1_Gets("buffer", "size");
002864  003099  // Usage : r := I2C1_Gets(mybuf, 16);
002865  003100  // Notes : only reads up to "size" characters into "buffer"
002866  003101  //       : Reads up to asciiz terminator including terminator
002867  003102        
002868  003103  func I2C2_Gets("buffer", "size"), 1;
002869  003104  // Syntax: I2C2_Gets("buffer", "size");
002870  003105  // Usage : r := I2C2_Gets(mybuf, 16);
002871  003106  // Notes : only reads up to "size" characters into "buffer"
002872  003107  //       : Reads up to asciiz terminator including terminator
002873  003108        
002874  003109  func I2C3_Gets("buffer", "size"), 1;
002875  003110  // Syntax: I2C3_Gets("buffer", "size");
002876  003111  // Usage : r := I2C3_Gets(mybuf, 16);
002877  003112  // Notes : only reads up to "size" characters into "buffer"
002878  003113  //       : Reads up to asciiz terminator including terminator
002879  003114        
002880  003115  func I2C1_Getn("buffer", "size"), 1;
002881  003116  // Syntax: I2C1_Gets("buffer", "size");
002882  003117  // Usage : r := I2C1_Gets(mybuf, 16);
002883  003118  // Notes : reads "size" bytes into "buffer"
002884  003119  //       :
002885  003120        
002886  003121  func I2C2_Getn("buffer", "size"), 1;
002887  003122  // Syntax: I2C2_Gets("buffer", "size");
002888  003123  // Usage : r := I2C2_Gets(mybuf, 16);
002889  003124  // Notes : reads "size" bytes into "buffer"
002890  003125  //       :
002891  003126        
002892  003127  func I2C3_Getn("buffer", "size"), 1;
002893  003128  // Syntax: I2C3_Gets("buffer", "size");
002894  003129  // Usage : r := I2C3_Gets(mybuf, 16);
002895  003130  // Notes : reads "size" bytes into "buffer"
002896  003131  //       :
002897  003132        
002898  003133  func I2C1_Puts("buffer"), 1;
002899  003134  // Syntax: I2C1_Puts("buffer");
002900  003135  // Usage : r := I2C1_Puts(mybuf);
002901  003136  // Notes : writes an asciiz string to the I2C device
002902  003137  //       : returns count of characters written
002903  003138        
002904  003139  func I2C2_Puts("buffer"), 1;
002905  003140  // Syntax: I2C2_Puts("buffer");
002906  003141  // Usage : r := I2C2_Puts(mybuf);
002907  003142  // Notes : writes an asciiz string to the I2C device
002908  003143  //       : returns count of characters written
002909  003144        
002910  003145  func I2C3_Puts("buffer"), 1;
002911  003146  // Syntax: I2C3_Puts("buffer");
002912  003147  // Usage : r := I2C3_Puts(mybuf);
002913  003148  // Notes : writes an asciiz string to the I2C device
002914  003149  //       : returns count of characters written
002915  003150        
002916  003151  func I2C1_Putn("buffer", "count"), 1;
002917  003152  // Syntax: I2C1_Putn("buffer","count");
002918  003153  // Usage : r := I2C1_Puts(mybuf,10);
002919  003154  // Notes : writes up to "size" bytes to the I2C device
002920  003155  //       : returns number of bytes written
002921  003156        
002922  003157  func I2C2_Putn("buffer", "count"), 1;
002923  003158  // Syntax: I2C2_Putn("buffer","count");
002924  003159  // Usage : r := I2C2_Puts(mybuf,10);
002925  003160  // Notes : writes up to "size" bytes to the I2C device
002926  003161  //       : returns number of bytes written
002927  003162        
002928  003163  func I2C3_Putn("buffer", "count"), 1;
002929  003164  // Syntax: I2C3_Putn("buffer","count");
002930  003165  // Usage : r := I2C3_Puts(mybuf,10);
002931  003166  // Notes : writes up to "size" bytes to the I2C device
002932  003167  //       : returns number of bytes written
002933  003168        
002934  003169        
002935  003170  func spi_ReadBlock("buf", "bufsize"), 0;                       // commence a block reception
002936  003171  // Syntax   : spi_ReadBlock("buf", "bufsize");
002937  003172  // Usage    : spi_ReadBlock(mybuf, 30);                        // point to the buffer and read 30 characters
002938  003173  // *Notes   : Bufsize bytes are read from the SPI port to the string pointer "buf".
002939  003174        
002940  003175  func spi1_ReadBlock("buf", "bufsize"), 0;                       // commence a block reception
002941  003176  // Syntax   : spi1_ReadBlock("buf", "bufsize");
002942  003177  // Usage    : spi1_ReadBlock(mybuf, 30);                        // point to the buffer and read 30 characters
002943  003178  // *Notes   : Bufsize bytes are read from the SPI port to the string pointer "buf".
002944  003179        
002945  003180  func spi2_ReadBlock("buf", "bufsize"), 0;                       // commence a block reception
002946  003181  // Syntax   : spi2_ReadBlock("buf", "bufsize");
002947  003182  // Usage    : spi2_ReadBlock(mybuf, 30);                        // point to the buffer and read 30 characters
002948  003183  // *Notes   : Bufsize bytes are read from the SPI port to the string pointer "buf".
002949  003184        
002950  003185  func spi3_ReadBlock("buf", "bufsize"), 0;                       // commence a block reception
002951  003186  // Syntax   : spi3_ReadBlock("buf", "bufsize");
002952  003187  // Usage    : spi3_ReadBlock(mybuf, 30);                        // point to the buffer and read 30 characters
002953  003188  // *Notes   : Bufsize bytes are read from the SPI port to the string pointer "buf".
002954  003189        
002955  003190  // I2C timing related constants
002956  003191  #CONST
002957  003199  #END
002958  003200        
002959  003201        
002960  003202        
002961  003203  //------------------------------------------------------------------//
002962  003204  // Direct uSD (SPI0) card SPI functions                             //
002963  003205  //------------------------------------------------------------------//
002964  003206  func spi_Init("speed","ip_mode","op_mode"), 0;  // set the SPI port, not used if uSD active
002965  003207  func spi_Read(), 1;                             // read a raw byte from SPI (lowers CS)
002966  003208  func spi_Write("byte"), 0;                      // write a raw byte to SPI (lowers CS)
002967  003209  func spi_Disable(), 0;                          // disable SPI reading or writing (raise CS)
002968  003210                                                  //
002969  003211        
002970  003212  //------------------------------------------------------------------//
002971  003213  // Function prototypes for SPI1, SPI2 and SPI3                      //
002972  003214  //------------------------------------------------------------------//
002973  003215  func SPI1_SDO_pin("pin"), 1;                // select the hardware pin for SPI1 transmit line
002974  003216  // Syntax: SPI_SDO_pin(pin);
002975  003217  // Usage : SPI_SDO_pin(PA1); // set SPI SDO to PA1 pin
002976  003218  // Notes : Select the hardware pin for SPIx transmit line.
002977  003219  //       : Note that multiple pins can be connected simmultaneously.
002978  003220  //       : Pins that can be mapped to SPIx TX are PA1, PA3 to PA9, PA12 or PA13
002979  003221  //       : Pins that can't be mapped to SPIx SDO are PA0, PA2, PA10, PA11, PA14 and PA15
002980  003222  //       : If the pin argument is 0, SPIx SDO is disconnected from all pins.
002981  003223  //       : The pin is automatically set to an output.
002982  003224  //       : Returns: Returns TRUE if function succeeded (usually ignored)
002983  003225        
002984  003226  func SPI2_SDO_pin("pin"), 1;                // select the hardware pin for SPI2 transmit line
002985  003227  // Syntax: SPI2_SDO_pin(pin);
002986  003228  // Usage : SPI2_SDO_pin(PA1); // set SPI2 SDO to PA1 pin
002987  003229  // Notes : Select the hardware pin for SPIx transmit line.
002988  003230  //       : Note that multiple pins can be connected simmultaneously.
002989  003231  //       : Pins that can be mapped to SPIx TX are PA1, PA3 to PA9, PA12 or PA13
002990  003232  //       : Pins that can't be mapped to SPIx SDO are PA0, PA2, PA10, PA11, PA14 and PA15
002991  003233  //       : If the pin argument is 0, SPIx SDO is disconnected from all pins.
002992  003234  //       : The pin is automatically set to an output.
002993  003235  //       : Returns: Returns TRUE if function succeeded (usually ignored)
002994  003236        
002995  003237  func SPI3_SDO_pin("pin"), 1;                // select the hardware pin for SPI3 transmit line
002996  003238  // Syntax: SPI3_SDO_pin(pin);
002997  003239  // Usage : SPI3_SDO_pin(PA1); // set SPI3 SDO to PA1 pin
002998  003240  // Notes : Select the hardware pin for SPIx transmit line.
002999  003241  //       : Note that multiple pins can be connected simmultaneously.
003000  003242  //       : Pins that can be mapped to SPIx TX are PA1, PA3 to PA9, PA12 or PA13
003001  003243  //       : Pins that can't be mapped to SPIx SDO are PA0, PA2, PA10, PA11, PA14 and PA15
003002  003244  //       : If the pin argument is 0, SPIx SDO is disconnected from all pins.
003003  003245  //       : The pin is automatically set to an output.
003004  003246  //       : Returns: Returns TRUE if function succeeded (usually ignored)
003005  003247        
003006  003248  func SPI1_SDI_pin("pin"), 1;                // select the hardware pin for SPI1 receive line
003007  003249  // Syntax: SPI1_SDI_pin(pin);
003008  003250  // Usage : SPI1_SDI_pin(PA3); // set SPI1 SDI to PA3 pin
003009  003251  // Notes : Selects the hardware pin for SPIx receive line.
003010  003252  //       : Note that only a single pin can be mapped to SPI SDI.
003011  003253  //       : Pins that can be mapped to SPIx SDI are PA0 to PA13
003012  003254  //       : Pins that can't be mapped to SPIx SDI are PA14 and PA15
003013  003255  //       : If the pin argument is 0 the function has no effect
003014  003256  //       : The pin is automatically set to an input.
003015  003257  //       : If the SPIx SDI pin is set to same pin as SPIx SDO pin (eg for a loopback check)
003016  003258  //       : it is necessary to configure the SDI pin first, eg
003017  003259  //       :     SPI1_SDI_pin(PA3);     // configure SPI1 SDI to PA3 (this disconnects anything else)
003018  003260  //       :     SPI1_SDO_pin(PA3));    // configure SPI1 SDO to PA3
003019  003261  //       : Returns: Returns TRUE if function succeeded (usually ignored)
003020  003262        
003021  003263  func SPI2_SDI_pin("pin"), 1;                // select the hardware pin for SPI2 receive line
003022  003264  // Syntax: SPI2_SDI_pin(pin);
003023  003265  // Usage : SPI2_SDI_pin(PA3); // set SPI2 SDI to PA3 pin
003024  003266  // Notes : Selects the hardware pin for SPIx receive line.
003025  003267  //       : Note that only a single pin can be mapped to SPI SDI.
003026  003268  //       : Pins that can be mapped to SPIx SDI are PA0 to PA13
003027  003269  //       : Pins that can't be mapped to SPIx SDI are PA14 and PA15
003028  003270  //       : If the pin argument is 0 the function has no effect
003029  003271  //       : The pin is automatically set to an input.
003030  003272  //       : If the SPIx SDI pin is set to same pin as SPIx SDO pin (eg for a loopback check)
003031  003273  //       : it is necessary to configure the SDI pin first, eg
003032  003274  //       :     SPI2_SDI_pin(PA3);     // configure SPI2 SDI to PA3 (this disconnects anything else)
003033  003275  //       :     SPI2_SDO_pin(PA3));    // configure SPI2 SDO to PA3
003034  003276  //       : Returns: Returns TRUE if function succeeded (usually ignored)
003035  003277        
003036  003278  func SPI3_SDI_pin("pin"), 1;                // select the hardware pin for SPI2 receive line
003037  003279  // Syntax: SPI3_SDI_pin(pin);
003038  003280  // Usage : SPI3_SDI_pin(PA3); // set SPI3 SDI to PA3 pin
003039  003281  // Notes : Selects the hardware pin for SPIx receive line.
003040  003282  //       : Note that only a single pin can be mapped to SPI SDI.
003041  003283  //       : Pins that can be mapped to SPIx SDI are PA0 to PA13
003042  003284  //       : Pins that can't be mapped to SPIx SDI are PA14 and PA15
003043  003285  //       : If the pin argument is 0 the function has no effect
003044  003286  //       : The pin is automatically set to an input.
003045  003287  //       : If the SPIx SDI pin is set to same pin as SPIx SDO pin (eg for a loopback check)
003046  003288  //       : it is necessary to configure the SDI pin first, eg
003047  003289  //       :     SPI3_SDI_pin(PA3);     // configure SPI3 SDI to PA3 (this disconnects anything else)
003048  003290  //       :     SPI3_SDO_pin(PA3));    // configure SPI3 SDO to PA3
003049  003291  //       : Returns: Returns TRUE if function succeeded (usually ignored)
003050  003292        
003051  003293  func SPI1_SCK_pin("pin"), 1;                // select the hardware pin for SPI1 clock line
003052  003294  // Syntax: SPI1_SCK_pin(pin);
003053  003295  // Usage : SPI1_SCK_pin(PA0); // set SPI1 SCK to PA0 pin
003054  003296  // Notes : Selects the hardware pin for SPI clock line.
003055  003297  //       : Note that only a single pin should be mapped to spi SCK.
003056  003298  //       : Pins that can be mapped to SPIx SCK are PA1, PA3 to PA9, PA12 or PA13
003057  003299  //       : Pins that can't be mapped to SPIx SCK are PA0, PA2, PA10, PA11, PA14 and PA15
003058  003300  //       : If the pin argument is 0 the SPIx SCK pin is disconnected
003059  003301  //       : The pin is automatically set to an output.
003060  003302  //       : Returns: Returns TRUE if finction succeeded (usually ignored)
003061  003303        
003062  003304  func SPI2_SCK_pin("pin"), 1;                // select the hardware pin for SPI2 clock line
003063  003305  // Syntax: SPI2_SCK_pin(pin);
003064  003306  // Usage : SPI2_SCK_pin(PA0); // set SPI1 SCK to PA0 pin
003065  003307  // Notes : Selects the hardware pin for SPI clock line.
003066  003308  //       : Note that only a single pin should be mapped to spi SCK.
003067  003309  //       : Pins that can be mapped to SPIx SCK are PA1, PA3 to PA9, PA12 or PA13
003068  003310  //       : Pins that can't be mapped to SPIx SCK are PA0, PA2, PA10, PA11, PA14 and PA15
003069  003311  //       : If the pin argument is 0 the SPIx SCK pin is disconnected
003070  003312  //       : The pin is automatically set to an output.
003071  003313  //       : Returns: Returns TRUE if finction succeeded (usually ignored)
003072  003314        
003073  003315  func SPI3_SCK_pin("pin"), 1;                // select the hardware pin for SPI3 clock line
003074  003316  // Syntax: SPI3_SCK_pin(pin);
003075  003317  // Usage : SPI3_SCK_pin(PA0); // set SPI1 SCK to PA0 pin
003076  003318  // Notes : Selects the hardware pin for SPI clock line.
003077  003319  //       : Note that only a single pin should be mapped to spi SCK.
003078  003320  //       : Pins that can be mapped to SPIx SCK are PA1, PA3 to PA9, PA12 or PA13
003079  003321  //       : Pins that can't be mapped to SPIx SCK are PA0, PA2, PA10, PA11, PA14 and PA15
003080  003322  //       : If the pin argument is 0 the SPIx SCK pin is disconnected
003081  003323  //       : The pin is automatically set to an output.
003082  003324  //       : Returns: Returns TRUE if finction succeeded (usually ignored)
003083  003325        
003084  003326        
003085  003327  func SPI1_Init("speed","mode"), 1;              // set the SPI1 port
003086  003328  func SPI2_Init("speed","mode"), 1;              // set the SPI2 port
003087  003329  func SPI3_Init("speed","mode"), 1;              // set the SPI3 port
003088  003330        
003089  003331        
003090  003332  //------------------------------------------------------------------------------
003091  003333  // Constants for SPI1, SPI2 an SPI3 "mode"
003092  003334  //------------------------------------------------------------------------------
003093  003335  #CONST
003094  003352  #END
003095  003353        
003096  003354  //------------------------------------------------------------------------------
003097  003355  // Constants for SPI1, SPI2 an SPI3 "speed"
003098  003356  //------------------------------------------------------------------------------
003099  003357  #CONST
003100  003374  #END
003101  003375        
003102  003376        
003103  003377  func SPI1_Read(), 1;                                 // read a raw byte from SPI1
003104  003378  func SPI2_Read(), 1;                                 // read a raw byte from SPI2
003105  003379  func SPI3_Read(), 1;                                 // read a raw byte from SPI3
003106  003380        
003107  003381  func SPI1_Write("byte"), 1;                          // write a raw byte to SPI1
003108  003382  func SPI2_Write("byte"), 1;                          // write a raw byte to SPI2
003109  003383  func SPI3_Write("byte"), 1;                          // write a raw byte to SPI3
003110  003384        
003111  003385  func spi_WriteBlock("buf", "bufsize"), 0;                       // commence a block write
003112  003386  // Syntax   : spi_WriteBlock("buf", "bufsize");
003113  003387  // Usage    : spi_WriteBlock(mybuf, 30);                         // point to the Write buffer and send 30 characters
003114  003388  // *Notes   : Bufsize bytes are transmitted to the SPI port from the string pointer "buf".
003115  003389        
003116  003390  func spi1_WriteBlock("buf", "bufsize"), 0;                       // commence a block write
003117  003391  // Syntax   : spi1_WriteBlock("buf", "bufsize");
003118  003392  // Usage    : spi1_WriteBlock(mybuf, 30);                         // point to the Write buffer and send 30 characters
003119  003393  // *Notes   : Bufsize bytes are transmitted to the SPI port from the string pointer "buf".
003120  003394        
003121  003395  func spi2_WriteBlock("buf", "bufsize"), 0;                       // commence a block write
003122  003396  // Syntax   : spi2_WriteBlock("buf", "bufsize");
003123  003397  // Usage    : spi2_WriteBlock(mybuf, 30);                         // point to the Write buffer and send 30 characters
003124  003398  // *Notes   : Bufsize bytes are transmitted to the SPI port from the string pointer "buf".
003125  003399        
003126  003400  func spi3_WriteBlock("buf", "bufsize"), 0;                       // commence a block write
003127  003401  // Syntax   : spi3_WriteBlock("buf", "bufsize");
003128  003402  // Usage    : spi3_WriteBlock(mybuf, 30);                         // point to the Write buffer and send 30 characters
003129  003403  // *Notes   : Bufsize bytes are transmitted to the SPI port from the string pointer "buf".
003130  003404        
003131  003405  //------------------------------------------------------------------//
003132  003406  // Display Access                                                   //
003133  003407  //------------------------------------------------------------------//
003134  003408  func disp_SetReg("register", "data"), 0;
003135  003409  // Syntax: display_SetReg(register, data);
003136  003410  // Usage : display_SetReg(arg1, arg2);
003137  003411  // Notes : Sets uLCD specific display driver registers. Refer
003138  003412  //       : to appropriate display driver data sheet.
003139  003413        
003140  003414  func disp_setGRAM("x1","y1","x2","y2"), 0;    // set GRAM window
003141  003415  // Syntax: disp_setGRAM(x1, y1, x2, y2);
003142  003416  // Usage : disp_setGRAM(arg1, arg2, arg3, arg4);
003143  003417  // Notes : Prepares the GRAM area for user access.
003144  003418  //       : Data can now be written with disp_GRAM.
003145  003419  //       : GRAM will be set accordingly for the correct screen mode.
003146  003420  //       : the LO word of the 32 bit pixel count is returned. This is
003147  003421  //       : usually all that is needed unlse GRAM area exceeds 256^2
003148  003422  //       : A copy of the 32bit value can be found in
003149  003423  //       : GRAM_PIXEL_COUNT_LO and GRAM_PIXEL_COUNT_HI
003150  003424        
003151  003425  func disp_WrGRAM("colour"), 0;
003152  003426  // Syntax: display_WrGRAM(colour);
003153  003427  // Usage : display_WrGRAM(arg);
003154  003428  // Notes : Data can be written to the GRAM consecutively using
003155  003429  //       : this function once the GRAM access window has been setup.
003156  003430        
003157  003431  func disp_WriteControl("value"), 0;             // write a control byte to the display
003158  003432        
003159  003433  func disp_WriteWord("value"), 0;                // write a word to the display
003160  003434        
003161  003435        
003162  003436  func disp_ReadWord(), 1;                        // read a word from the display
003163  003437  // Syntax: disp_ReadWord();
003164  003438  // Usage : x:=disp_ReadWord();
003165  003439  // Notes : Read a word from the controller
003166  003440  // Eg:   : disp_WriteControl(0);         // select Ilitek ID register
003167  003441  //       : print(disp_ReadWord());        // print ID
003168  003442  //       : (Many displays are write only)
003169  003443        
003170  003444        
003171  003445  // NB only available on certain displays, check individual data sheets
003172  003446  func sys_StoreTouchCalibration(), 1;
003173  003447  // Syntax: sys_StoreTouchCalibration();
003174  003448  // Usage : r := sys_StoreTouchCalibration();
003175  003449  // Notes : Store the touch calibration values in non-volatile memory.
003176  003450  //       : Returns true if the values have been accepted and stored,
003177  003451  //       : else returns false if write could not be performed, or
003178  003452  //       : touch calibration values are improbable.
003179  003453  //       : The values that are stored are obtained from:-
003180  003454  //       : TOUCH_XMINCAL             78  // touch calibration value
003181  003455  //       : TOUCH_YMINCAL             79  // touch calibration value
003182  003456  //       : TOUCH_XMAXCAL             80  // touch calibration value
003183  003457  //       : TOUCH_YMAXCAL             81  // touch calibration value
003184  003458  //       : refer to the 4DGL example touchCalibrate.4DG for further information.
003185  003459  //       : This function is not supported on uVGA, Capacitive touch
003186  003460  //       : and 4.3" resistive touch modules.
003187  003461        
003188  003462  // NB only available on certain displays, check individual data sheets
003189  003463  func disp_Sync("line"), 0;                      //  (uVGA only)  wait till scanline reaches "line"
003190  003464  // Syntax: disp_Sync(line);
003191  003465  // Usage : disp_Sync(480);
003192  003466  // Notes : Waits till the hardware gets to a certain line.
003193  003467  //       : Allows the program to synchronise writing to the hardware for flicker free operation.
003194  003468  //       : Some experimentation may be needed to find an optimum line for disp_Sync
003195  003469  //       : depending on the graphics operation. The higher the value, the slower
003196  003470  //       : the throughput. A cetain point will be reached (number of scanlines + blanking lines
003197  003471  //       : within the vertical retrace period) where it will just 'hang up' stopping the
003198  003472  //       : entire process. Eg, in 640x480 mode, if the 'lines' value is 507, operation will
003199  003473  //       : be slowest (as its actually right at the end of the blanking period) and 508
003200  003474  //       : will cause a hangup situation as it is above the highes scanline value.
003201  003475  //       : Currently, this function is only supported on displays with SSD1963 driver.
003202  003476        
003203  003477  func disp_Init(), 0;                           // initialize display with required tables. New in v0.7
003204  003478  // Syntax: disp_Init();                        New in v0.7
003205  003479  // Usage : disp_Init();
003206  003480  // Notes : Initialises or reinitialises the display.
003207  003481  //       : Normally used after restoration of peripheral power
003208  003482  //       : and after DeepSleep.
003209  003483        
003210  003484  func disp_Disconnect(), 0;                     // Disconnect display to ensure reduced power after disabling peripheral power. New in v0.7
003211  003485  // Syntax: disp_Disconnect();                  New in v0.7
003212  003486  // Usage : disp_Disconnect();
003213  003487  // Notes : Disconnects the display driver pins and/or reconfigures it to achieve
003214  003488  //       : its lowest possible power consumption. Use after disabling peripheral power
003215  003489  //       : to ensure the minimal power usage by the display.
003216  003490  //       : disp_Init() should be used to reinitialise the display.
003217  003491        
003218  003492  func disp_BlitPixelsFromCOM0(), 0;                     // Writes current GRAM window pixels to the display from the COM port
003219  003493  // Syntax: disp_BlitPixelsFromCOM0();                  New in v1.1
003220  003494  // Usage : disp_BlitPixelsFromCOM0();
003221  003495  // Notes : Writes the number of pixels defined by the last disp_setGRAM() call to the
003222  003496  //       : display from the specified com port.
003223  003497        
003224  003498  func __reserved42(), 0; // do not remove
003225  003499        
003226  003500        
003227  003501  //------------------------------------------------------------------//
003228  003502  //        Image Control Function Prototypes                         //
003229  003503  //------------------------------------------------------------------//
003230  003504  func img_SetPosition("handle", "index", "xpos", "ypos"), 1;
003231  003505  // Syntax: img_SetPosition(handle, index, xpos, ypos);
003232  003506  // Usage : r := img_SetPosition(hImageList, imagenum, x, y);
003233  003507  // Notes : set the position where the image will be displayed
003234  003508  //       : returns true if index was ok and function was successful.
003235  003509  //       : you may turn off an image so when img_Refresh is called,
003236  003510  //       : the image will not be shown
003237  003511        
003238  003512  func img_Enable("handle", "index"), 1;
003239  003513  // Syntax: img_Enable(handle, index);
003240  003514  // Usage : r := img_Enable(hImageList, imagenum);
003241  003515  // Notes : enable image in a image list
003242  003516  //       : returns true if index was ok and function was successful.
003243  003517  //       : this is the default state so when img_Refresh is called,
003244  003518  //       : all the images in the list will be shown
003245  003519  //       : if index is set to -1, all of the images are enabled
003246  003520        
003247  003521  func img_Disable("handle", "index"), 1;
003248  003522  // Syntax: img_Disable(handle, index);
003249  003523  // Usage : r := img_Disable(hImageList, imagenum);
003250  003524  // Notes : disable image in a image list
003251  003525  //       : returns true if index was ok and function was successful.
003252  003526  //       : you must turn off an image so when img_Refresh is called,
003253  003527  //       : the image will not be shown.
003254  003528  //       : if index is set to -1, all of the images are disabled
003255  003529        
003256  003530        
003257  003531  func img_Darken("handle", "index"), 1;
003258  003532  // Syntax: img_Darken(handle, index);
003259  003533  // Usage : r := img_Darken(hImageList, imagenum);
003260  003534  // Notes : darken image in a image list
003261  003535  //       : returns true if index was ok and function was successful.
003262  003536  //       : if index is set to -1, all of the images are darkened
003263  003537  //       : NB:- this feature will only work for the next refresh, then
003264  003538  //       : the image reverts back to normal when displayed again.
003265  003539        
003266  003540        
003267  003541  func img_Lighten("handle", "index"), 1;
003268  003542  // Syntax: img_Lighten(handle, index);
003269  003543  // Usage : r := img_Lighten(hImageList, imagenum);
003270  003544  // Notes : lighten image in a image list
003271  003545  //       : returns true if index was ok and function was successful.
003272  003546  //       : if index is set to -1, all of the images are lightened
003273  003547  //       : NB:- this feature will only work for the next refresh, then
003274  003548  //       : the image reverts back to normal when displayed again.
003275  003549        
003276  003550  func img_SetWord("handle", "index", "offset", "word"), 1;
003277  003551  // Syntax: img_SetWord(handle, index, offset, word);
003278  003552  // Usage : img_SetWord(hndl, 5, IMAGE_XPOS, 10);
003279  003553  // Notes : set specified word (0-7) in a image entry
003280  003554  //       : returns TRUE if successful, return value usually ignored.
003281  003555        
003282  003556  func img_GetWord("handle", "index", "offset"), 1;
003283  003557  // Syntax: myvar := img_GetWord("handle", "index", "offset");
003284  003558  // Usage : myvar := img_GetWord(hndl, 5, IMAGE_YPOS);
003285  003559  // Notes : returns specified word (0-14) from an image entry
003286  003560  //       : refer to image control entry offsets.
003287  003561        
003288  003562  func img_Show("handle", "index"), 1;
003289  003563  // Syntax: img_Show(handle, index);
003290  003564  // Usage : display image entry (regardless of enable/disable)
003291  003565  //       : returns TRUE if successful, return value usually ignored.
003292  003566        
003293  003567  func img_SetAttributes("handle", "index","value"), 1;
003294  003568  // Syntax: img_SetAttributes("handle", "index","offset");
003295  003569  // Usage : img_SetAttributes(hndl, 5, I_TOPMOST);
003296  003570  // Notes : This function SETS one or more bits in the IMAGE_FLAGS field
003297  003571  //       : of an image control entry. "value" refers to various bits in
003298  003572  //       : the image control entry (see image attribute flags).
003299  003573  //       : A '1' bit in the "value" field SETS the respective bit
003300  003574  //       : in the IMAGE_FLAGS field of the image control entry.
003301  003575  //       : returns TRUE if successful, return value usually ignored.
003302  003576        
003303  003577  func img_ClearAttributes("handle", "index","value"), 1;
003304  003578  // Syntax: img_ClearAttributes("handle", "index","offset");
003305  003579  // Usage : img_ClearAttributes(hndl, 5, I_TOPMOST);
003306  003580  // Notes : This function CLEARS one or more bits in the IMAGE_FLAGS field
003307  003581  //       : of an image control entry. "value" refers to various bits in
003308  003582  //       : the image control entry (see image attribute flags)
003309  003583  //       : a '1' bit in the "value" field CLEARS the respective bit
003310  003584  //       : in the IMAGE_FLAGS field of the image control entry.
003311  003585  //       : returns TRUE if successful, return value usually ignored.
003312  003586        
003313  003587  func img_Touched("handle", "index"), 1;
003314  003588  // Syntax: r := img_Touched(handle, index);
003315  003589  // Usage : img_Touched(hndl, 17);
003316  003590  //       : returns -1 if image not touched, or returns index
003317  003591  // Notes : if index is passed as -1, function tests all images,
003318  003592  //       : and returns -1 if image not touched, or returns index.
003319  003593        
003320  003594        
003321  003595  func img_SelectReadPosition("handle", "index", "frame", "x", "y"), 1;
003322  003596  // Syntax: img_SelectReadPosition(handle, index, frame, xpos, ypos);
003323  003597  // Usage : r := img_SelectReadPosition(hImageList, imagenum, frame, x, y);
003324  003598  // Notes : set a position in an image control for sequential reading
003325  003599  //       : of pixels from the uSD card (fat16 or raw modes supported)
003326  003600  //       : No image window area is set, the image will not be shown
003327  003601  //       : This function provides a means of preparing to load an image,
003328  003602  //       : or part of an image, to an array. (see img_SequentialRead)
003329  003603  //Returns: returns true if index was ok and function was successful.
003330  003604        
003331  003605        
003332  003606  func img_SequentialRead("count", "ptr"), 1;  // read pixels from selected read position of an image
003333  003607  // Syntax: img_SequentialRead(count, ptr);
003334  003608  // Usage1: r := img_SequentialRead(imgwidth, myArray);    // read 1 line from image control to array
003335  003609  // Usage2: r := img_SequentialRead(123, 0);            // skip 123 words from sequential stream
003336  003610  // Usage3: r := img_SequentialRead(20, 1);            // write 20 pixels to current GRAM position from stream
003337  003611  // Notes : once a position has ben set with the img_SelectReadPosition function,
003338  003612  //       : this function can then used for sequential reading of pixels from
003339  003613  //       : image storage.
003340  003614  //       : if "ptr" is 0, "count" pixels from the stream are simply skipped.
003341  003615  //       : if "ptr" is 1, "count" pixels are written to the GRAM area,
003342  003616  //       : else "ptr" must point to a valid array that is at least
003343  003617  //       : the size of "count".
003344  003618  //       : or part of an image, to an array. (see img_SequentialRead)
003345  003619  //       : returns TRUE if function succeded.
003346  003620        
003347  003621  func __reserved43(), 0; // do not remove
003348  003622  func __reserved44(), 0; // do not remove
003349  003623  func __reserved45(), 0; // do not remove
003350  003624  func __reserved46(), 0; // do not remove
003351  003625        
003352  003626  // image control header offsets
003353  003627  #CONST
003354  003634  #END
003355  003635        
003356  003636  // image control entry offsets
003357  003637  #CONST
003358  003652  #END
003359  003653        
003360  003654  // image attribute flags (in IMAGE_FLAGS)
003361  003655  // for img_SetAttributes(...) and img_ClearAttributes(...)
003362  003656  #CONST
003363  003670  #END
003364  003671        
003365  003672        
003366  003673  //------------------------------------------------------------------//
003367  003674  //        Timer Function Prototypes
003368  003675  //------------------------------------------------------------------//
003369  003676  func sys_T(), 1;
003370  003677  // Syntax: sys_T();
003371  003678  // Usage : t := sys_T();
003372  003679  // Notes : return the current value of the rolling system timer (1msec) LO word
003373  003680        
003374  003681  func sys_T_HI(), 1;
003375  003682  // Syntax: sys_T_HI();
003376  003683  // Usage : t := sys_T_HI();
003377  003684  // Notes : return the current value of the rolling system timer (1msec) HI word
003378  003685        
003379  003686  func sys_SetTimer("timernum","value"), 0;
003380  003687  // Syntax: sys_SetTimer("timernum", "value");
003381  003688  // Usage : sys_SetTimer(TIMER5, 10000);
003382  003689  // Notes : set a countdown on the selected timer, or 'top up' if required.
003383  003690  //       : There ar 8 timers TIMER0 to TIMER7 which stop at the count of 0
003384  003691  //       : Maximum timeout period is 65.535 seconds
003385  003692  //       : A timer can be read with the sys_GetTimer("timernum") function
003386  003693        
003387  003694  func sys_GetTimer("timernum"), 1;
003388  003695  // Syntax: t := sys_GetTimer("timernum");
003389  003696  // Usage : t := sys_GetTimer(TIMER3);
003390  003697  // Notes : returns 0 if timer has expired, or the current countdown value.
003391  003698  //       : There ar 8 timers TIMER0 to TIMER7 which stop at the count of 0
003392  003699  //       : Maximum timeout period is 65.535 seconds
003393  003700  //       : A timer must be set with the sys_SetTimer("timernum","value") function
003394  003701        
003395  003702  func sys_SetTimerEvent("timernum","function"), 1;
003396  003703  // Syntax: sys_SetTimerFunction("timernum", "function");
003397  003704  // Usage : sys_SetTimer(TIMER5, myfunc);
003398  003705  // Notes : set a function to be called for selected timer.
003399  003706  //       : When the timer reaches zero, the function is called.
003400  003707  //       : The called function must not have any parameters
003401  003708  //       : sys_SetTimerEvent returns any previous event function
003402  003709  //       : address, or zero if there was no previous function.
003403  003710        
003404  003711  func sys_EventQueue(), 1;
003405  003712  // Syntax: sys_EventQueue();
003406  003713  // Usage : tasks := sys_EventQueue();
003407  003714  // Notes : returns the max number of events that were pending
003408  003715  //       : in the timer queue since the last call to this function.
003409  003716  //       : This can be used to assess timer event overhead burden,
003410  003717  //       : especially after or during a sys_EventsPostpone action.
003411  003718        
003412  003719  func sys_EventsPostpone(), 0;
003413  003720  // Syntax: sys_EventPostpone();
003414  003721  // Usage : sys_EventPostpone();   // postpone the event queue
003415  003722  // Notes : postpone any events until the sys_EventResume function is executed
003416  003723  //       : The timer event queue will continue to queue events, but no action
003417  003724  //       : will take place untill a sys_EventResume function is encountered.
003418  003725  //       : The queue will continue to receive up to 32 events before discarding
003419  003726  //       : any further events. This function is required to allow a sequence of
003420  003727  //       : instructions or functions to occur that would otherwise be corrupted
003421  003728  //       : by an event occuring during the sequence of instructions or functions.
003422  003729  //       : A good example of this is when you set a position to print, if there
003423  003730  //       : was no way of locking the current sequence, an event may occur which
003424  003731  //       : does a similar thing, and a contention would occur - printing to
003425  003732  //       : the wrong position. This function should be used wisely, if any action
003426  003733  //       : that is required would take considerable time, it is better to disable
003427  003734  //       : any conflicting event functions with a bypass flag, then restart the
003428  003735  //       : conflicting event by re-issuing a timer value.
003429  003736        
003430  003737  func sys_EventsResume(), 0;
003431  003738  // Syntax: sys_EventsResume();
003432  003739  // Usage : sys_EventsResume();   // resume the event queue
003433  003740  // Notes : resume any postponed events. The queue will try to execute any timer
003434  003741  //       : events that were incurred during the postponed period.
003435  003742        
003436  003743        
003437  003744  func sys_GetTime(), 0;
003438  003745  // Syntax: sys_GetTime();
003439  003746  // Usage : to(mystring); sys_GetTime();   // save current time string to buffer
003440  003747  // Notes : print the system time in the format eg "6:10:45"
003441  003748  //       : Can be captured to a buffer using the to( function
003442  003749  //       : Returns nothing.
003443  003750        
003444  003751  func sys_SetTime("hours", "mins", "secs"), 1;
003445  003752  // Syntax: sys_SetTime(h, m, s);
003446  003753  // Usage : sys_SetTime(10, 0, 0);   // set the system time
003447  003754  // Notes : Used to set clock to correct time after power up or suspension
003448  003755  //Returns: Returns true if valid time.
003449  003756        
003450  003757  func sys_GetDate(), 0;
003451  003758  // Syntax: sys_GetDate();
003452  003759  // Usage : to(mystring); sys_GetDate();   // save current time string to buffer
003453  003760  // Notes : print the system date in the format eg "25-09-2012"
003454  003761  //       : Can be captured to a buffer using the to( function
003455  003762  //       : Returns nothing.
003456  003763        
003457  003764  func sys_SetDate("year", "month", "day"), 1;
003458  003765  // Syntax: sys_SetDate(y, m, d);
003459  003766  // Usage : sys_SetDate(10, 0, 0);   // set the system time
003460  003767  // Notes : Used to set clock to correct date after power up or suspension
003461  003768  //Returns: Returns true if valid date.
003462  003769        
003463  003770  func sys_Sleep("units"), 1;
003464  003771  // Syntax: t := sys_Sleep("units");
003465  003772  // Usage : t := sys_Sleep(10);
003466  003773  // Notes : sets the display into low power mode for a period of time.
003467  003774  //       : Touching the touch screen will also wake from sleep.
003468  003775  //       : as will bus Change Interrupts.
003469  003776  //       : Returns remaining sleep units.
003470  003777        
003471  003778  func iterator("offset"), 0;
003472  003779  // Syntax: t :=  iterator("offset");
003473  003780  // Usage : t :=  iterator(10);
003474  003781  // Notes : set the iterator size for ++/--
003475  003782  //       : The next postinc,postdec,preinc of predec will alter
003476  003783  //       : by the specified value.
003477  003784  //       : The offset will return to 1 after the next operation.
003478  003785        
003479  003786  func sys_DeepSleep("units"), 1;               // put the module into its lowest power consumption mode. New in v0.7
003480  003787  // Syntax: t := sys_DeepSleep("units");    New in v0.7
003481  003788  // Usage : t := sys_DeepSleep(10);
003482  003789  // Notes : sets the display and processor into lowest power mode for a period of time.
003483  003790  //       : When returning from DeepSleep the display should be reinitialised
003484  003791  //       : with disp_Init().
003485  003792  //       : Touching the touch screen will also wake from sleep.
003486  003793  //       : Returns remaining sleep units.
003487  003794        
003488  003795  //------------------------------------------------------------------//
003489  003796  //         Touch Screen Function Prototypes
003490  003797  //------------------------------------------------------------------//
003491  003798        
003492  003799  func touch_DetectRegion("x1" ,"y1", "x2", "y2"), 0;
003493  003800  // Syntax: touch_DetectRegion(x1, y1, x2, y2);
003494  003801  // Usage : touch_DetectRegion(arg1, arg2, arg3, arg4);
003495  003802  // Notes : Specifies a new touch detect region on the screen
003496  003803  //       : such that only touch activity in that region will
003497  003804  //       : be reported by the status poll touch_Get(TOUCH_STATUS);
003498  003805        
003499  003806  func touch_Set("mode"), 0;
003500  003807  // Syntax: touch_Set(mode);
003501  003808  // Usage : touch_Set(arg);
003502  003809  // Notes : Sets various Touch Screen related parameters
003503  003810  //       :
003504  003811  //       : mode = TOUCH_ENABLE (mode 0)  Enable Touch Screen
003505  003812  //       : touch_Set(TOUCH_ENABLE);
003506  003813  //       : Enables and initialises Touch Screen hardware
003507  003814  //       :
003508  003815  //       : mode = TOUCH_DISABLE (mode 1)  Disable Touch Screen
003509  003816  //       : touch_Set(TOUCH_DISABLE );
003510  003817  //       : Disables the Touch Screen
003511  003818  //       : Note: Touch Screen runs in the background and disabling
003512  003819  //       : it when not in use will free up extra resources
003513  003820  //       : such as 4DVM CPU cycles.
003514  003821  //       :
003515  003822  //       : mode = TOUCH_REGIONDEFAULT (mode 2)  Default Touch Region
003516  003823  //       : touch_Set(TOUCH_REGIONDEFAULT);
003517  003824  //       : This will reset the current active region to default
003518  003825  //       : to the full screen without the application having to
003519  003826  //       : set a new active region for the full screen.
003520  003827  //       : (NB for 'no touch' devices - like uVGAII or OLED's/LCD's
003521  003828  //       : that requre to be interfaced with an external pointing
003522  003829  //       : device, values that are poked into TOUCH_DRIVE will be
003523  003830  //       : read with the touch_Get() function)
003524  003831        
003525  003832        
003526  003833  func touch_Get("mode"), 1;
003527  003834  // Syntax: touch_Get(mode);
003528  003835  // Usage : arg1 := touch_Get(arg);
003529  003836  // Notes : Returns various Touch Screen parameters to caller
003530  003837  //       :
003531  003838  //       : mode = TOUCH_STATUS  (mode 0)
003532  003839  //       : var := touch_Get(TOUCH_STATUS);
003533  003840  //       : Returns the various states of the touch screen
003534  003841  //       : 0 = NOTOUCH
003535  003842  //       : 1 = TOUCH_PRESSED
003536  003843  //       : 2 = TOUCH_RELEASED
003537  003844  //       : 3 = TOUCH_MOVING
003538  003845  //       :
003539  003846  //       : mode = TOUCH_GETX   (mode 1)
003540  003847  //       : var := touch_Get(TOUCH_GETX);
003541  003848  //       : Returns the X coordinates of the touch
003542  003849  //       :
003543  003850  //       : mode = TOUCH_GETY   (mode 2)
003544  003851  //       : var := touch_Get(TOUCH_GETY);
003545  003852  //       : Returns the Y coordinates of the touch
003546  003853        
003547  003854        
003548  003855  //touch_Set() related constants
003549  003856  #CONST
003550  003860  #END
003551  003861        
003552  003862  //touch_Get() related constants
003553  003863  #CONST
003554  003871  #END
003555  003872        
003556  003873  func touch_TestBox("&rect"), 1;
003557  003874  // Syntax   : touch_Test(rect);
003558  003875  // Usage    : var r[4]; r[0]:=100; r[1]:=200; r[2]:=20; r[3]:=30;
003559  003876  //          : result := touch_Test(r); // check area at 100,200,119,229
003560  003877  // Notes    : rect is an array of 4 vars, x1, y1, width, height (using boxed co-ordinates)
003561  003878  // returns  : Returns true if last touch co-ordinates are within the boxed test area.
003562  003879        
003563  003880  func touch_TestArea("&rect"), 1;
003564  003881  // Syntax   : touch_Test(rect);
003565  003882  // Usage    : var r[4]; r[0]:=100; r[1]:=200; r[2]:=119; r[3]:=129;
003566  003883  //          : result := touch_Test(r); // check area at 100,200,119,229
003567  003884  // Notes    : rect is an array of 4 vars, x1, y1, x2, y2 (using absolute co-ordinates)
003568  003885  // returns  : Returns true if last touch co-ordinates are within the absolute co-ordinate test area.
003569  003886        
003570  003887        
003571  003888  func __reserved51(), 0; // do not remove
003572  003889  func __reserved52(), 0; // do not remove
003573  003890        
003574  003891  //------------------------------------------------------------------//
003575  003892  //        Memory Allocation Function Prototypes
003576  003893  //------------------------------------------------------------------//
003577  003894        
003578  003895  func mem_Alloc("size"), 1;
003579  003896  // Syntax: mem_Alloc(bytesize);
003580  003897  // Usage : myvar := mem_Alloc(100);
003581  003898  // Notes : Allocate a block of memory to pointer myvar
003582  003899  //       : The allocated memory contains garbage but is a fast allocation.
003583  003900  //       : The block must later be released with mem_Free();
003584  003901  //       : returns 0 if function fails
003585  003902        
003586  003903  func mem_AllocV("size"), 1;
003587  003904  // Syntax: mem_AllocV(bytesize);
003588  003905  // Usage : myvar := mem_AllocV(100);
003589  003906  // Notes : Allocate a block of memory to pointer myvar
003590  003907  //       : The block of memory is filled with signature values
003591  003908  //       : the block starts with A5,5A then fills with incrementing
003592  003909  //       : number eg:- A5,5A,00,01,02,03...FF,00,11....
003593  003910  //       : This can be helpful when debugging
003594  003911  //       : The block must later be released with mem_Free();
003595  003912  //       : returns 0 if function fails
003596  003913        
003597  003914  func mem_AllocZ("size"), 1;
003598  003915  // Syntax: mem_AllocZ(bytesize);
003599  003916  // Usage : myvar := mem_AllocC(100);
003600  003917  // Notes : Allocate a zeroed block of memory to pointer myvar
003601  003918  //       : The block of memory is filled with zeroes
003602  003919  //       : The block must later be released with mem_Free();
003603  003920  //       : returns 0 if function fails
003604  003921        
003605  003922  func mem_Realloc("ptr", "size"), 1;
003606  003923  // Syntax: myvar := mem_Realloc("ptr", "size");
003607  003924  // Usage : myvar := mem_Realloc(ptr, size);
003608  003925  // Notes : The function may move the memory block to a new location,
003609  003926  //       : in which case the new location is returned.
003610  003927  //       : The content of the memory block is preserved up to the lesser
003611  003928  //       : of the new and old sizes, even if the block is moved.
003612  003929  //       : If the new size is larger, the value of the newly allocated
003613  003930  //       : portion is indeterminate. In case that ptr is NULL,
003614  003931  //       : the function behaves exactly as mem_Alloc, assigning a new block
003615  003932  //       : of size bytes and returning a pointer to the beginning of it.
003616  003933  //       : In case that the size is 0, the memory previously allocated in
003617  003934  //       : ptr is deallocated as if a call to mem_Free()was made, and a NULL
003618  003935  //       : pointer is returned.
003619  003936        
003620  003937  func mem_Free("allocation"), 1;
003621  003938  // Syntax: myvar := mem_Free(allocation);
003622  003939  // Usage : myvar := mem_Free(myvar);
003623  003940  // Notes : De-allocate a block of memory previously created with
003624  003941  //       : mem_Alloc(...), mem_AllocV(...); or mem_AllocZ(...);
003625  003942  //       : returns 0 if function fails
003626  003943        
003627  003944  func mem_Heap(), 1;
003628  003945  // Syntax: myvar := mem_Heap();
003629  003946  // Usage : myvar := mem_Heap();
003630  003947  // Notes : returns bytecount available in heap
003631  003948  //       :
003632  003949        
003633  003950  func mem_Set("ptr","char","size"), 1;
003634  003951  // Syntax: mem_Set(ptr,char,bytesize);
003635  003952  // Usage : mem_Set(p, 'A', 100);
003636  003953  // Notes : fill a block of memory with a byte value
003637  003954  //       : Note that count is a byte count, this facilitates
003638  003955  //       : clearing word aligned byte arrays when using word
003639  003956  //       : aligned packed strings.
003640  003957  //       : returns ptr
003641  003958        
003642  003959  func mem_Copy("src", "dest", "bytecount"), 1;
003643  003960  // Syntax: myvar := mem_Copy(src, dest, bytesize);
003644  003961  // Usage : myvar := mem_Copy(p1, p2, 100);
003645  003962  // Notes : copy a word aligned block of memory from src to dest
003646  003963  //       : Note that count is a byte count, this facilitates
003647  003964  //       : copying word aligned byte arrays when using word
003648  003965  //       : aligned packed strings.
003649  003966  //       : returns src
003650  003967        
003651  003968  func mem_Compare("ptr1","ptr2","count"), 1;
003652  003969  // Syntax: myvar := mem_Compare(ptr1,ptr2,bytesize);
003653  003970  // Usage : myvar := mem_Compare(p1, p2, 100);
003654  003971  // Notes : compare word aligned blocks of memory at src, dest
003655  003972  //       : Note that count is a byte count, this facilitates
003656  003973  //       : comparing word aligned byte arrays when using word
003657  003974  //       : aligned packed strings.
003658  003975  //       : returns 0 if we have a match
003659  003976        
003660  003977  func __reserved53(), 0; // do not remove
003661  003978  func __reserved54(), 0; // do not remove
003662  003979        
003663  003980  //------------------------------------------------------------------//
003664  003981  //        FAT16 Function Prototypes
003665  003982  //------------------------------------------------------------------//
003666  003983        
003667  003984  func file_Error(), 1;
003668  003985  // Syntax: myvar := file_Error();
003669  003986  // Usage : e := file_Error();
003670  003987  // Notes : return the most recent file error.
003671  003988  //       :
003672  003989        
003673  003990  func file_Count("filename"), 1;
003674  003991  // Syntax: count := file_Count("filename");
003675  003992  // Usage : count := file_Count("*.4dg");
003676  003993  // Notes : returns number of files found that match the criteria
003677  003994        
003678  003995  func file_Dir("filename"), 1;
003679  003996  // Syntax: count := file_Dir("filename");
003680  003997  // Usage : count := file_Dir("*.4dg");
003681  003998  // Notes : streams a string of filenames that agree with the search key
003682  003999  //       : returns number of files found that match the criteria
003683  004000        
003684  004001  func file_FindFirst("fname"), 1;
003685  004002  // Syntax: res := file_FindFirst("fname");
003686  004003  // Usage : if (file_FindFirst("*.4xe") ....
003687  004004  // Notes : returns true if at least 1 file exists
003688  004005  //       : that satisfies the file argument.
003689  004006  //       : Wildcards are usually used so if
003690  004007  //       : file_FindFirst returns true, further
003691  004008  //       : tests can be made using file_FindNext();
003692  004009  //       : to find all the files that match the
003693  004010  //       : wildcard class. Note that the stream behaviour
003694  004011  //       : is the same as file_Dir.
003695  004012  //       :
003696  004013        
003697  004014  func file_FindNext(), 1;
003698  004015  // Syntax: res := file_FindNext();
003699  004016  // Usage : while ((file_FindNext()) ....
003700  004017  // Notes : returns true if more file exists
003701  004018  //       : that satisfies the file argument
003702  004019  //       : that was given for  file_FindFirst.
003703  004020  //       : Wildcards must be used for
003704  004021  //       : file_FindFirst, else this function will
003705  004022  //       : always return zero as the only occurence
003706  004023  //       : will have already been found.
003707  004024  //       : Note that the stream behaviour
003708  004025  //       : is the same as file_Dir.
003709  004026  //       :
003710  004027        
003711  004028  func file_Exists("fname"), 1;
003712  004029  // Syntax: res := file_Exists("fname"),
003713  004030  // Usage : if(file_Exists("myfile") ....
003714  004031  // Notes : returns true if file exists
003715  004032  //       :
003716  004033        
003717  004034  func file_Open("fname", "mode"), 1;
003718  004035  // Syntax: handle := file_Open("fname","mode"),
003719  004036  // Usage : handle := file_Open("myfile.txt", 'r');
003720  004037  // Notes : returns handle if file exists
003721  004038  //       :
003722  004039        
003723  004040  func file_Close("handle"), 1;
003724  004041  // Syntax: res := file_Close("handle");
003725  004042  // Usage : res := file_Close(hnd1);
003726  004043  // Notes : returns true if file closed ok
003727  004044  //       :
003728  004045        
003729  004046  func file_Read("*dest", "size", "handle"), 1;
003730  004047  // Syntax: res := file_Read("*dest", "size", "handle"),
003731  004048  // Usage : res := file_Read(memblock,20,hnd1);
003732  004049  // Notes : returns number of characters read
003733  004050  //       : if "dest" is zero, data is read direct to GRAM window
003734  004051  //       :
003735  004052        
003736  004053        
003737  004054  func file_Seek("handle", "HiWord", "LoWord"), 1;
003738  004055  // Syntax: res := file_Seek("handle", "HiWord", "LoWord")
003739  004056  // Usage : res := file_Seek(hSource, 0, 0x1234);
003740  004057  // Notes : set file position to 0x00001234 (byte position 4660)
003741  004058  //       : for the file handle so subsequent data may be read
003742  004059  //       : from that position onwards with file_GetC(...),
003743  004060  //       : file_GetW(...) or file_GetS(...), or an image
003744  004061  //       : can be displayed with file_Image(...)
003745  004062  // Notes : returns true if ok, usually ignored
003746  004063        
003747  004064  func file_Index("handle", "HiSize", "LoSize","recordnum"), 1;
003748  004065  // Syntax: file_Index("handle", "HiSize", "LoSize","recordnum"), 1;
003749  004066  // Usage : res := file_Index(hsource, 0, 1000, 123), 1;
003750  004067  // Notes : set file seek position to 123000
003751  004068  //       : for the file handle so subsequent data may be read
003752  004069  //       : from that record position onwards with file_GetC(...),
003753  004070  //       : file_GetW(...) or file_GetS(...), or an image
003754  004071  //       : can be displayed with file_Image(...)
003755  004072  // Notes : returns true if ok, usually ignored
003756  004073        
003757  004074  func file_Tell("handle", "&HiWord", "&LoWord"), 1;
003758  004075  // Syntax: file_Tell("handle", &HiWord, &LoWord);
003759  004076  // Usage : file_Tell(fhndl, &SizeHi, &SizeLo);
003760  004077  // Notes : Reads the 32 bit file pointer and stores it into 2 variables.
003761  004078  //       : returns true if function succeeded
003762  004079        
003763  004080  func file_Write("*source", "size", "handle"), 1;
003764  004081  // Syntax: res := fwrite("*source", "size", "handle"),
003765  004082  // Usage : res := fwrite(memblock, 20, hnd1);
003766  004083  // Notes : returns number of bytes written
003767  004084  //       :
003768  004085        
003769  004086  func file_Size("handle", "&HiWord", "&LoWord"), 1;
003770  004087  // Syntax: file_Size("handle", &HiWord, &LoWord);
003771  004088  // Usage : file_Size(fhndl, &SizeHi, &SizeLo);
003772  004089  // Notes : Reads the 32 bit file size and stores it into 2 variables.
003773  004090  //       : returns true if function succeeded
003774  004091        
003775  004092  func file_Image("x", "y", "handle"), 1;
003776  004093  // Syntax: file_Image(x, y, handle);
003777  004094  // Usage : file_Image(10, 10, hnd1);
003778  004095  // Notes : Display an image from a file at the current file position.
003779  004096  //       : The image is displayed at x,y (with respect to top left corner).
003780  004097  //       : If there is more than 1 image in the file, it can be
003781  004098  //       : accessed with file_Seek(...)
003782  004099        
003783  004100  func file_ScreenCapture("x", "y", "width", "height", "handle"), 1;
003784  004101  // Syntax: file_ScreenCapture(x, y, w, h, handle);
003785  004102  // Usage : file_ScreenCapture(10, 10, 50,50, hnd1);
003786  004103  // Notes : Save a image from screen to file at the current file position.
003787  004104  //       : The image can later be displayed with file_Image(...);
003788  004105  //       : The file may be opened in append mode to accumulate multiple
003789  004106  //       : images. Later, the images can be accessed with file_Seek(...);
003790  004107  //       : Note that the image will be sector aligned.
003791  004108  //       : All image headers must start on a sector boundary.
003792  004109  //       : The image is saved from x, y (with respect to top left corner)
003793  004110  //       : and the capture area is determined by "width" and "height".
003794  004111  //       : returns 0 if function succeeded
003795  004112        
003796  004113  func file_PutC("char","handle"), 1;
003797  004114  // Syntax: file_PutC("char", "handle");
003798  004115  // Usage : file_PutC('x', hndl);
003799  004116  // Notes : returns true if function succeeded
003800  004117        
003801  004118  func file_GetC("handle"), 1;
003802  004119  // Syntax: file_GetC("handle");
003803  004120  // Usage : mychar := fgetC("handle");
003804  004121  // Notes : returns next char from file
003805  004122        
003806  004123  func file_PutW("word","handle"), 1;
003807  004124  // Syntax: file_PutW("word","handle");
003808  004125  // Usage : file_PutW(0x1234, hndl);
003809  004126  // Notes : returns true if function succeeded
003810  004127        
003811  004128  func file_GetW("handle"), 1;
003812  004129  // Syntax: file_GetW("handle");
003813  004130  // Usage : myword := fgetW("handle");
003814  004131  // Notes : returns next word in file
003815  004132        
003816  004133  func file_PutS("*source", "handle"), 1;
003817  004134  // Syntax: res := file_Puts("*source", "handle"),
003818  004135  // Usage : res := file_Puts(mystring, hnd1);
003819  004136  // Notes : returns number of characters written
003820  004137  //       :
003821  004138        
003822  004139  func file_GetS("*string", "size", "handle"), 1;
003823  004140  // Syntax: res := file_Gets("*string", "size", "handle");
003824  004141  // Usage : res := file_Gets(mystr , 81, hnd1); // read up to 80 chars
003825  004142  // Notes : get a string from a file
003826  004143  //       : returns pointer to string or null if failed.
003827  004144  //       : file_GetS(...) automatically appends a null-terminator to the data read.
003828  004145  //       : NB:- only reads up to "size-1" characters into "string"
003829  004146  //       : file_GetS(...) will stop reading when any of the following conditions are true:
003830  004147  //       : A] It has read n-1 bytes (one character is reserved for the null-terminator)
003831  004148  //       : B] It encounters a newline character (a line-feed in the compilers tested here), or
003832  004149  //       : C] It reaches the end of file
003833  004150  //       : D] A read error occurs.
003834  004151        
003835  004152        
003836  004153  func file_Erase("fname"), 1;
003837  004154  // Syntax: res := file_Erase("fname");
003838  004155  // Usage : res := file_Erase("myfile.txt");
003839  004156  // Notes : returns true if successful
003840  004157  //       :
003841  004158        
003842  004159  func file_Rewind("handle"), 1;
003843  004160  // Syntax: res := file_Rewind("handle");
003844  004161  // Usage : res := file_Rewind(hnd1);
003845  004162  // Notes : returns true if file rewound ok (usually ignored)
003846  004163  //       : resets the file pointer the the beginning of the open file.
003847  004164        
003848  004165  func file_LoadFunction("fname.4xe"), 1;
003849  004166  // Syntax: res := file_LoadFunction("fname.4fn");
003850  004167  // Usage : myfunc := file_LoadFunction(myfuncname);
003851  004168  // Notes : Load a function or program from disk and
003852  004169  //       : return a function pointer to the allocation.
003853  004170  //       : The function can then be invoked just like any other
003854  004171  //       : function would be called via a function pointer.
003855  004172  //       : Parameters may be passed to it in a conventional way.
003856  004173  //       : The function may be discarded at any time when no
003857  004174  //       : longer required, thus freeing its memory resources.
003858  004175  //       : The loaded function can be discarded with mem_Free(..)
003859  004176  //       : eg:
003860  004177  //       : popupWindow := file_LoadFunction("popupWindow1.4fn");
003861  004178  //       : if(!popupWindow) goto LoadFunctionFailed; // could not load the function !!!
003862  004179  //       : then elsewhere in your program:-
003863  004180  //       : res := popupWindow(MYMODE,"My Title","My Popup Text");
003864  004181  //       : if(res == QUIT_APPLICATION) goto exitApp;
003865  004182  //       : Later in your program, when popupWindow is no longer
003866  004183  //       : required for the application:-
003867  004184  //       : res := mem_Free(popupWindow);
003868  004185  //       : if(!res) goto FreeFunctionFailed; // should never happen if memory not corrupted
003869  004186  //       : The callers stack is shared by the loaded function,
003870  004187  //       : however any global variables in the loaded function
003871  004188  //       : are private to that function.
003872  004189  //
003873  004190        
003874  004191  func file_Run("fname.4xe", "arglistptr"), 1;
003875  004192  // Syntax: res := file_Run("fname.4xe","arglistptr");
003876  004193  // Usage : res := file_Run(fname, argptr);
003877  004194  // Notes : current program releases any allocated memory but
003878  004195  //       : retains the stack and global memory.
003879  004196  //       : If arglistptr is 0, no arguments are passed, else
003880  004197  //       : arglist points to an array, the first element being
003881  004198  //       : the number of elements in the array.
003882  004199  //       : func 'main' in the called program accepts
003883  004200  //       : the arguments, if any. The arguments can only
003884  004201  //       : be passed by value, no pointers or references can be
003885  004202  //       : used as all memory is cleared before the file
003886  004203  //       : is loaded. Refer to file_Exec and file_LoadFunction
003887  004204  //       : for functions that can pass by reference.
003888  004205        
003889  004206  func file_Exec("fname.4xe", "arglistptr"), 1;
003890  004207  // Syntax: res := file_Exec("fname.4xe","arglistptr");
003891  004208  // Usage : res := file_Exec("fname.4xe","arglistptr");
003892  004209  // Notes : returns like a function, current program
003893  004210  //       : calling program is kept active and control returns to it.
003894  004211  //       : If arglistptr is 0, no arguments are passed, else
003895  004212  //       : arglist points to an array, the first element being
003896  004213  //       : the number of elements in the array.
003897  004214  //       : func 'main' in the called program accepts the arguments.
003898  004215  //       : This function is similar to file_LoadFunction(...), however,
003899  004216  //       : the function argument list is passed by pointer, and
003900  004217  //       : the memory consumed by the function is released as
003901  004218  //       : soon as the function completes.
003902  004219        
003903  004220  func file_LoadImageControl("fname1", "fname2", "mode"), 1;
003904  004221  // Syntax: hImagelist := file_LoadImageControl ("controlfile", "imagefile", "mode"),
003905  004222  // Usage : hImagelist := file_LoadImageControl ("resource.dat", "resource.gci", 0);
003906  004223  // Notes : Reads a control file to create an image list.
003907  004224  //       : Returns NULL if function fails.
003908  004225  //       : Returns a handle (pointer to the memory allocation) to the
003909  004226  //       : image control list that has been created.
003910  004227  //       : "fname1" is the control list filename "*.dat"
003911  004228  //       : "fname2" is the image filename "*.gci"
003912  004229        
003913  004230  // Notes : This function Calculates the size of a chunk of memory required for
003914  004231  //       : a image list and populates it from the image control file ("*.dat")
003915  004232  //       : therefore, when imagelist is no longer required, you must de-allocate
003916  004233  //       : the image list memory by using eg:- mem_Free(hImagelist);
003917  004234  //       : to restore the heap.
003918  004235  //       :
003919  004236  //       : mode 0:- it is assumed that there is a graphics file with the
003920  004237  //       : file extension "fname2.gci". In this case, the images have been stored
003921  004238  //       : in a FAT16 file concurrently, and the offsets that ar derived from the
003922  004239  //       : "fname1.dat" file are saved in the image control so that the image control
003923  004240  //       : can open the file (*.gci) and us file_Seek to get to the position of the
003924  004241  //       : image which can then automatically be displayed using file_Image(xpos, ypos, hSource);
003925  004242  //       : mode 0 builds the image control quickly as it only scans the *.dat file
003926  004243  //       : for the file offsets and save them in the relevant entries in the image control.
003927  004244  //       : The penalty is that images take longer to find when displayed due to file_Seek
003928  004245  //       : overheads.
003929  004246  //
003930  004247  //       : mode 1:- it is assumed that there is a graphics file with the
003931  004248  //       : file extension "fname2.gci". In this case, the images have been stored
003932  004249  //       : in a FAT16 file concurrently, and the offset of the images are saved
003933  004250  //       : in the image control so that image file (*.gci) can be mapped to directly.
003934  004251  //       : The absolute cluster/sector is mapped so file seek does not need to be called
003935  004252  //       : internally. This means that there is no seek time penalty, however, the
003936  004253  //       : image list takes a lot longer to build, as all the seeking is done at control
003937  004254  //       : build time.
003938  004255        
003939  004256  //       : mode 2:- the graphics file with the is placed in a partitioned area
003940  004257  //       : In this case, the images have been stored in a in a known raw area of the FAT16
003941  004258  //       : disk, and the absolute address of the images are saved in the DAT file
003942  004259  //       : This is the fastest operation of the image control as there is no seeking
003943  004260  //       : or other disk activity taking place.
003944  004261        
003945  004262  func file_Mount(), 1;
003946  004263  // Syntax: r := file_Mount();
003947  004264  // Usage : r := file_Mount();
003948  004265  // Notes : Create a control block for FAT16 and mount the File System
003949  004266        
003950  004267  func file_Unmount(), 0;
003951  004268  // Syntax: file_Unmount();
003952  004269  // Usage : file_Unmount();
003953  004270  // Notes : release any control block and buffers for FAT16
003954  004271  //       : and unmount the File System
003955  004272        
003956  004273  func file_PlayWAV("fname1"), 1;
003957  004274  // Syntax: file_PlayWAV("fname1");
003958  004275  // Usage : file_PlayWAV("ding.wav");
003959  004276  // Notes : Play a wave file with filename "fname1"
003960  004277  //       : This function automatically grabs a chunk
003961  004278  //       : of memory for a file buffer, and a wave
003962  004279  //       : buffer. The minimum memory requirement is
003963  004280  //       : about 580 bytes for the disk io service and
003964  004281  //       : a minimum wave buffer size of 1024. The siz
003965  004282  //       : of the wave buffer allocation
003966  004283  //       : can be increased by the snd_BufSize function.
003967  004284  //       : The default size 1024 bytes.
003968  004285  //       : NB the memory is only required during the
003969  004286  //       : duration of play, and is automatically
003970  004287  //       : released while not in use.
003971  004288  //       : See the Sound Class services for other associated controls.
003972  004289  //       : If there are no errors, returns number of blocks to play (1 to 32767)
003973  004290  //       : If errors occured, the folling is returned
003974  004291  //       : -7  : Insufficient memory available for WAV buffer and file
003975  004292  //       : -6  : cant play this rate
003976  004293  //       : -5  : no data chunk found in first rsector
003977  004294  //       : -4  : no format data
003978  004295  //       : -3  : no wave chunk signature
003979  004296  //       : -2  : bad wave file format
003980  004297  //       : -1  : file not found
003981  004298        
003982  004299  func file_Rename("fname1", "fname2"), 1;     // rename a file
003983  004300  // Syntax: file_Rename ("oldname", "newname"),
003984  004301  // Usage : file_Rename ("file.txt", "file.bak");
003985  004302  // Notes : Renames a file on uSD.
003986  004303  //       : Returns FALSE if function fails. (file does not exist, or new filename already exists)
003987  004304  //       : Returns TRUE, if successful.
003988  004305        
003989  004306  func file_SetDate("handle", "year", "month", "day", "hour", "Minute", "Second") , 1; // Sets date and time for an open file
003990  004307  // Syntax: res := file_SetDate("handle", "year", "month", "day", "hour", "Minute", "Second) ;
003991  004308  // Usage : res := file_SetDate(hndl, 2014, 10, 31, 10, 0, 0)
003992  004309  // Notes : year is a 4 digit year
003993  004310  //       : Due to limitations of FAT16 only even seconds are stored
003994  004311  //       : The handle must be closed before the file information is updated
003995  004312  //       : returns TRUE if date + time + handle valid
003996  004313  //       : returns FLAST if handle invalid, or date or time not valid (only simple checking performed).
003997  004314        
003998  004315  func __reserved57(), 0; // do not remove
003999  004316  func __reserved58(), 0; // do not remove
004000  004317        
004001  004318  //------------------------------------------------------------------------------
004002  004319  // FILEIO Error Code Constants
004003  004320  //------------------------------------------------------------------------------
004004  004321  #CONST
004005  004347  #END
004006  004348        
004007  004349  //------------------------------------------------------------------------------
004008  004350  // DISK struct offsets
004009  004351  //------------------------------------------------------------------------------
004010  004352  #CONST
004011  004369  #END
004012  004370        
004013  004371  //------------------------------------------------------------------------------
004014  004372  // FILE struct offsets
004015  004373  //------------------------------------------------------------------------------
004016  004374  #CONST
004017  004393  #END
004018  004394        
004019  004395        
004020  004396  //------------------------------------------------------------------//
004021  004397  //        Sound Class Services
004022  004398  //------------------------------------------------------------------//
004023  004399        
004024  004400  func snd_Volume("var"), 0;
004025  004401  // Syntax: snd_Volume("var");
004026  004402  // Usage : snd_Volume(30);
004027  004403  // Notes : set sound playback volume.  Var must
004028  004404  //       : be in the range from 8 (min volume)
004029  004405  //       : to 127 (max volume). If var is less
004030  004406  //       : than 8 volume is set to 8, and if
004031  004407  //       : var > 127 it is set to 127.
004032  004408        
004033  004409  func snd_Pitch("pitch"), 1;
004034  004410  // func snd_Pitch("freq"), 1;
004035  004411  // func snd_Pitch(7000), 1; // play the wave file with a sample frequency of 7khz
004036  004412  // Notes : sets the samples playback rate to a different frequency
004037  004413  //       : The minimum value is 4khz
004038  004414  //       : Setting the pitch to zero restores the original sample rate
004039  004415  //       : Return value is the samples original sample rate.
004040  004416        
004041  004417  func snd_BufSize("var"), 0;
004042  004418  // Syntax: snd_BufSize("var");
004043  004419  // Usage : snd_BufSize(2);
004044  004420  // Notes : specify the a memory chunk size for the wavefile buffer.
004045  004421  //       : default size 1024 bytes.
004046  004422  //       : 0 = 1024 bytes (default)
004047  004423  //       : 1 = 2048 bytes
004048  004424  //       : 2 = 4096 bytes
004049  004425  //       : 3 = 8192 bytes
004050  004426        
004051  004427  func snd_Stop(), 0;
004052  004428  // Syntax: snd_Stop();
004053  004429  // Usage : snd_Stop();
004054  004430  // Notes : stop any sound that is playing, releasing
004055  004431  //       : buffers and closes any open wav file.
004056  004432        
004057  004433  func snd_Pause(), 0;
004058  004434  // Syntax: snd_Pause();
004059  004435  // Usage : snd_Pause();
004060  004436  // Notes : pauses any sound that is playing, does nothing
004061  004437  //       : until sound is resumed with snd_Continue().
004062  004438  //       : The sample cam be terminated with snd_Stop.
004063  004439  //       : buffers and closes any open wav file.
004064  004440        
004065  004441  func snd_Continue(), 0;
004066  004442  // Syntax: snd_Continue();
004067  004443  // Usage : snd_Continue();
004068  004444  // Notes : resume any sound that is paused by snd_Pause.
004069  004445        
004070  004446  func snd_Playing(), 1;
004071  004447  // Syntax: snd_Playing();
004072  004448  // Usage : r := snd_Playing();
004073  004449  // Notes : returns 0 if sound has finished playing,
004074  004450  //       : else return number of 512 byte blocks to go.
004075  004451        
004076  004452  func snd_Freq("Freq", "Duration"), 1;
004077  004453  // Syntax: snd_Freq("Freq", "Duration");
004078  004454  // Usage : r := snd_Freq(1000, 2000);
004079  004455  // Notes : Returns 0 if note cannot be played because a wav file is playing
004080  004456  //       : else return True.
004081  004457  //       : Minimum Freq is 20
004082  004458  //       : This will produce a pure Square wave and is designed for driving
004083  004459  //       : Piezo transducers which require this sort of drive. It can also be
004084  004460  //       : used to drive the amp on displays with audio.
004085  004461        
004086  004462        
004087  004463  func __reserved60(), 0; // do not remove
004088  004464  func __reserved61(), 0; // do not remove
004089  004465  func __reserved62(), 0; // do not remove
004090  004466        
004091  004467  //=========================================================================================================
004092  004468  // String functions
004093  004469  //=========================================================================================================
004094  004470        
004095  004471  func str_Ptr("&var"), 1;
004096  004472  // Syntax: str_Ptr(&var);
004097  004473  // Usage : p := str_Ptr(&var);
004098  004474  // Notes : return a byte pointer to a word region
004099  004475        
004100  004476  func str_GetD("&ptr", "&var"), 1;
004101  004477  // Syntax: str_GetD(&ptr, &var);
004102  004478  // Usage : ok := str_GetD(&ptr, &var);
004103  004479  // Notes : convert number in a string to DWORD ( myvar[2] )
004104  004480  //       : returns true if function succeeds, advancing ptr
004105  004481        
004106  004482  func str_GetW("&ptr", "&var"), 1;
004107  004483  // Syntax: str_GetW(&ptr, &var);
004108  004484  // Usage : ok := str_GetW(&ptr, &var);
004109  004485  // Notes : convert number in a string to WORD ( myvar )
004110  004486  //       : returns true if function succeeds, advancing ptr
004111  004487        
004112  004488  func str_GetHexW("&ptr", "&var"), 1;
004113  004489  // Syntax: str_GetHexW(&ptr, &var);
004114  004490  // Usage : ok := str_GetHexW(&ptr, &var);
004115  004491  // Notes : convert HEX number in a string to WORD ( myvar )
004116  004492  //       : returns true if function succeeds, advancing ptr
004117  004493        
004118  004494  func str_GetC("&ptr", "&var"), 1;
004119  004495  // Syntax: str_GetC(&ptr, &var);
004120  004496  // Usage : ok := str_GetC(&ptr, &var);
004121  004497  // Notes : get a valid ascii char in a string to WORD ( myvar )
004122  004498  //       : returns true if function succeeds, advancing ptr
004123  004499        
004124  004500  func str_GetByte("ptr"), 1;
004125  004501  // Syntax: str_GetByte(ptr);
004126  004502  // Usage : myvar := str_GetByte(ptr);
004127  004503  // Notes : get a byte to myvar
004128  004504  //       : returns value
004129  004505        
004130  004506  func str_GetWord("ptr"), 1;
004131  004507  // Syntax: GetWord(ptr);
004132  004508  // Usage : GetWord(ptr);
004133  004509  // Notes : get a word to myvar
004134  004510  //       : returns value
004135  004511        
004136  004512  func str_PutByte("ptr","val"), 0;
004137  004513  // Syntax: str_PutByte(ptr);
004138  004514  // Usage : myvar := str_PutByte(ptr);
004139  004515  // Notes : put a byte at ptr
004140  004516  //       : returns value
004141  004517        
004142  004518  func str_PutWord("ptr","val"), 0;
004143  004519  // Syntax: str_PutWord("ptr","val");
004144  004520  // Usage : str_PutWord(p,100);
004145  004521  // Notes : put word 100 at current pointer location
004146  004522  //       : returns value
004147  004523        
004148  004524  func str_Match("&ptr", "*str"), 1;
004149  004525  // Syntax: str_Match(&ptr, *str);
004150  004526  // Usage : r := str_Match(&p, "hello");
004151  004527  // Notes : Case sensitive match
004152  004528  //       : returns true if function succeded, andvancing pointer to position past
004153  004529  //       : the matched item. Note that any whitespace characters are skipped
004154  004530  //       : in the source string prior to the test.
004155  004531        
004156  004532  func str_MatchI("&ptr", "*str"), 1;
004157  004533  // Syntax: str_MatchI(&ptr, *str);
004158  004534  // Usage : r := str_MatchI(&p, "hello");
004159  004535  // Notes : Case insensitive match
004160  004536  //       : returns true if function succeded, andvancing pointer to position past
004161  004537  //       : the matched item. Note that any whitespace characters are skipped
004162  004538  //       : in the source string prior to the test.
004163  004539        
004164  004540  func str_Find("&ptr", "*str"), 1;
004165  004541  // Syntax: str_Find(&ptr, *str);
004166  004542  // Usage : n := str_Find(&p, "hello");
004167  004543  // Notes : given the address of a pointer to a source string as the
004168  004544  //       : first argument, and a pointer to a test string as the second
004169  004545  //       : argument, attempt to find the position of the matching string
004170  004546  //       : in the source string. The test is performed with case sensitivity.
004171  004547  //       : return 0 if not found, else returns the address of the first
004172  004548  //       : character of the match. NB:- The source pointer is not altered.
004173  004549        
004174  004550  func str_FindI("&ptr", "*str"), 1;
004175  004551  // Syntax: str_Find(&ptr, *str);
004176  004552  // Usage : n := str_Find(&p, "hello");
004177  004553  // Notes : given the address of a pointer to a source string as the
004178  004554  //       : first argument, and a pointer to a test string as the second
004179  004555  //       : argument, attempt to find the position of the matching string
004180  004556  //       : in the source string. The test is performed with no case
004181  004557  //       : sensitivity, eg upper and lower case chars are accepted.
004182  004558  //       : return 0 if not found, else returns the address of the first
004183  004559  //       : character of the match. NB:- The source pointer is not altered.
004184  004560        
004185  004561  func str_Length("ptr"), 1;
004186  004562  // Syntax: str_Length(ptr);
004187  004563  // Usage : len := str_Ptr(mystring);
004188  004564  // Notes : return the length of a byte aligned string excluding terminator
004189  004565        
004190  004566  func str_Printf("&ptr", "*format"), 1;
004191  004567  // Syntax: str_Printf("&ptr", "*format");
004192  004568  // Usage : r := str_Printf(&p, "hello");
004193  004569  // Notes : refer to documentation
004194  004570  //       :
004195  004571        
004196  004572  func str_Cat("dest","src"), 1;
004197  004573  // Syntax: str_Append("&dest","&src");
004198  004574  // Usage : str_Append(&buf,"Hello");
004199  004575  // Notes : Appends a copy of the source string to the destination string.
004200  004576  //       : The terminating null character in destination is overwritten by
004201  004577  //       : the first character of source, and a new null-character is appended
004202  004578  //       : at the end of the new string formed by the concatenation of both in destination.
004203  004579  //       : returns destination.
004204  004580        
004205  004581  func str_CatN("dest","src","count"), 1;
004206  004582  // Syntax: str_Append("&dest","&src","count");
004207  004583  // Usage : str_Append(&buf,"Monday",3);
004208  004584  // Notes : Appends a copy of the source string to the destination string.
004209  004585  //       : The number of characters copied is limited by "count".
004210  004586  //       : The terminating null character in destination is overwritten by
004211  004587  //       : the first character of source, and a new null-character is appended
004212  004588  //       : at the end of the new string formed by the concatenation of both in destination.
004213  004589  //       : returns destination.
004214  004590        
004215  004591        
004216  004592  func str_ByteMove("src", "dest", "count"), 1;
004217  004593  // Syntax   : str_ByteMove(src, dest, bytecount);
004218  004594  // Input    : STR *source points to byte aligned source.
004219  004595  //          : STR *dest   points to byte aligned destination.
004220  004596  //          : VAR count   number of bytes to transfer.
004221  004597  // Usage    : nextpos := str_ByteMove(s, d, 100);
004222  004598  // Notes    : copy bytes from "src" to "dest", stopping only
004223  004599  //          : when "count" is exhausted.
004224  004600  //          : No terminator is appended, it is purely a
004225  004601  //          : byte copy, and any zeroes encountered will
004226  004602  //          : also be copied.
004227  004603  // Returns  : returns a pointer to the end of the destination
004228  004604  //          : (which is "dest" + "count")
004229  004605        
004230  004606        
004231  004607  func str_Copy("dest", "src"), 1;
004232  004608  // Syntax   : str_Copy(dest, src);
004233  004609  // Input    : STR *dest   points to byte aligned destination.
004234  004610  //          : STR *source points to byte aligned source.
004235  004611  // Usage    : nextplace := str_Copy(d, s);
004236  004612  // Notes    : copy a string from "src" to "dest", stopping only
004237  004613  //          : when the end of source string "src" is encountered
004238  004614  //          : (0x00 terminator).
004239  004615  //          : The terminator is always appended, even if "src" is
004240  004616  //          : an empty string.
004241  004617  // Returns  : returns a pointer to the 0x00 string terminator at
004242  004618  //          : end of "dest" (which is "dest" + str_Length(src); )
004243  004619        
004244  004620        
004245  004621  func str_CopyN("dest", "src", "count"), 1;
004246  004622  // Syntax   : str_CopyN(dest, src, bytecount);
004247  004623  // Input    : STR *dest   points to byte aligned destination.
004248  004624  //          : STR *source points to byte aligned source.
004249  004625  //          : VAR count   max number of chars to copy.
004250  004626  // Usage    : nextplace := str_CopyN(d, s, 100);
004251  004627  // Notes    : copy a string from "src" to "dest", stopping only
004252  004628  //          : when "count" is exhausted, or end of source
004253  004629  //          : string "str" is encountered (0x00 string terminator).
004254  004630  //          : The terminator is always appended, even if
004255  004631  //          : "count" is zero, or "src" is a null string.
004256  004632  // Returns  : returns a pointer to the 0x00 string terminator
004257  004633  //          : (which is "dest" + whatever was copied)
004258  004634        
004259  004635        
004260  004636  func __reserved63(), 0; // do not remove
004261  004637  func __reserved64(), 0; // do not remove
004262  004638  func __reserved65(), 0; // do not remove
004263  004639  func __reserved66(), 0; // do not remove
004264  004640        
004265  004641  //=========================================================================================================
004266  004642  // FLASH memory functions
004267  004643  //=========================================================================================================
004268  004644  func flash_GetByte("bank", "ptr"), 1;
004269  004645  // Syntax   : flash_GetByte(bank, ptr);
004270  004646  // Usage    : myvar := flash_GetByte(FLASHBANK_2, 0x0017); // read first byte in data statement of bank 2
004271  004647  // Notes    : Reads a single byte from any flash location.
004272  004648  //          : If the bank is read protected, only the first 2 bytes can be read (0x55, 0xAA)
004273  004649  //          : which is the header signature for a valid program.
004274  004650  // Returns  : the byte value from the location
004275  004651        
004276  004652        
004277  004653  func flash_GetWord("bank", "ptr"), 1;
004278  004654  // Syntax   : flash_GetWord(bank, ptr);
004279  004655  // Usage    : myvar := flash_GetWord(FLASHBANK_2, 0x0000); // read first word in flash bank  (0xAA55)
004280  004656  // Notes    : Reads a single word from any flash location.
004281  004657  //          : The pointer is byte aligned.
004282  004658  //          : If the bank is read protected, only the first word can be read
004283  004659  //          : which is the header signature for a valid program (0xAA55).
004284  004660  // Returns  : the byte value from the location
004285  004661        
004286  004662        
004287  004663  func flash_Copy("bank", "ptr", "dest", "count"), 1;
004288  004664  // Syntax   : flash_Copy(bank, ptr);
004289  004665  // Usage    : myvar := flash_Copy(FLASHBANK_2, 0x1234, mybuf, 20); // read 20 bytes from FLASHBANK_2 starting from 0x1234
004290  004666  // Notes    : Copies bytes from any flash locations to a user buffer.
004291  004667  //          : The destination pointer is byte aligned, so a str_Ptr must be raised to get correct address.
004292  004668  //          : If the bank is read protected, 0 bytes will be read
004293  004669  //          : which is the header signature for a valid program (0xAA55).
004294  004670  // Returns  : the count of bytes transferred.
004295  004671        
004296  004672        
004297  004673  func flash_Run("bank"), 1;
004298  004674  // Syntax    : flash_Run(bankx);
004299  004675  // Usage     : res := flash_Run(FLASHBANK_5);
004300  004676  // Notes     : Restarts the processor, running code from the required
004301  004677  //           : flash bank. bank may be a variable, or one of the
004302  004678  //           : pre-defined constants:-
004303  004679  //           :    FLASHBANK_0                 //0x00
004304  004680  //           :    FLASHBANK_1                 //0x01
004305  004681  //           :    FLASHBANK_2                 //0x02
004306  004682  //           :    FLASHBANK_3                 //0x03
004307  004683  //           :    FLASHBANK_4                 //0x04
004308  004684  //           :    FLASHBANK_5                 //0x05
004309  004685  // returns    : This function should net return as it restarts
004310  004686  //        : the processor and jumps to the required bank,
004311  004687  //        : If it does return, -1 indicates incorrect/invalid
004312  004688  //        : bank number, and -2 indicates no valid program
004313  004689  //        : in the selected bank.
004314  004690        
004315  004691  func flash_Bank(), 1;
004316  004692  // Syntax   : flash_Bank();
004317  004693  // Usage    : myvar := flash_Bank();
004318  004694  // Notes    : Identifies which flash bank the code is running from.
004319  004695  // Returns  : The FLASH bank that code is currently running from, 0-5.
004320  004696        
004321  004697        
004322  004698  func flash_EraseBank("bank", "confirmation"), 1;
004323  004699  // Syntax   : flash_EraseBank(bank, confirmation);
004324  004700  // Usage    : result := flash_EraseBank(FLASHBANK_3, 0xDEAD); // erase an entire flash bank, confirm overwrite of protected program
004325  004701  // Notes    : This function should be used with extreme caution.
004326  004702  //          : The selected bank will be completely erased regardless of FLASH_WRITE_PROTECT status
004327  004703  //          : if the confirmation value is set to hex 0xDEAD. If confirmation is any other value,
004328  004704  //          : a protected bank will not be erased, and function will return with 0
004329  004705  //          : If the destination bank is the same as the execution bank, the processor will reset
004330  004706  //          : upon completion of erase. If the "bank" argument is set to ALL (-1) and confirmation is set to 0xDEAD
004331  004707  //          : FLASHBANK_0 thru FLASHBANK_5 are cleared.
004332  004708  //          : Used with caution, this is a good way to 'clean up' the entire flash when starting new projects.
004333  004709  // Returns  : returns true if the function succeeded
004334  004710  //          : NB:- reset processor if program is erasing itself, or the ALL bank option is selected.
004335  004711        
004336  004712  func flash_LoadFile("bank", "filename"), 1;
004337  004713  // Syntax   : flash_LoadFile(bank, ptr);
004338  004714  // Usage    : result := flash_LoadFile(FLASHBANK_2, "TETRIS10.EXE"); // load the file from disk into FLASHBANK_2
004339  004715  // Notes    : Copies a file from uSD to the required flashbank.
004340  004716  //          : The destination bank cannont be the execution bank, or a bank that is write protected
004341  004717  // Returns  : returns true if the function succeeded.
004342  004718        
004343  004719        
004344  004720  func flash_WriteBlock("sourceptr", "bank", "page"), 1;
004345  004721  // Syntax   : flash_WriteBlock(pbuf, bank, page);
004346  004722  // Usage    : result := flash_WriteBlock(buffer, FLASHBANK_5, 8); // store the 2k buffer to FLASHBANK_5, location 16384
004347  004723  // Notes    : Copies a 2kbyte buffer to the required flashbank in block 0-15.
004348  004724  //          : The address of each block is 0, 2048, 4096 etc, determined by the page number 0-15.
004349  004725  //          : The destination bank cannot be an execution bank, or a program bank that is write protected.
004350  004726  // Returns  : returns true if the function succeeded.
004351  004727        
004352  004728        
004353  004729  func flash_putstr("bank", "ptr"), 1;
004354  004730  // Syntax   : flash_putstr(bank, ptr);
004355  004731  // Usage    : flash_Copy(FLASHBANK_2, 350); // print a string from FLASHBANK_2, location 350
004356  004732  // Notes    : Works the same as putstr, however, the source of the asciiz string is in FLASH storage
004357  004733  //          : Output may be redirected with the to(..) function. Bit15 of ptr is assumed 0.
004358  004734  // Returns  : True if function succeeds, usually ignored. 0 if bank is read protected
004359  004735        
004360  004736  func flash_Blit16("bank", "offset", "count"), 1;
004361  004737  // Syntax   : flash_Blit16(bank, offset, pixelcount);
004362  004738  // Usage    : disp_setGRAM(10,10,29,29); flash_Blit16(FLASHBANK_5, 2048, 400); // display image at 10,10 (20 pixels square) from FLASH image source (800 bytes)
004363  004739  // Notes    : Blit an image to a GRAM window from FLASH storage.
004364  004740  //          : Image is stored 16bits per pixel (565) in a linear fashion to suit the GRAM mechanism
004365  004741  // Returns  : actual count (normally same as count, will be lower if bank bounds exceeded)
004366  004742        
004367  004743  func flash_Blit8("bank", "offset", "count"), 1;
004368  004744  // Syntax   : flash_Blit8(bank, offset, pixelcount);
004369  004745  // Usage    : disp_setGRAM(10,10,29,29); flash_Blit8(FLASHBANK_5, 2048, 400); // display image at 10,10 (20 pixels square) from FLASH image source (400 bytes)
004370  004746  // Notes    : Blit an image to a GRAM window from FLASH storage.
004371  004747  //          : Image is stored 8 bits per pixel (332 format) in a linear fashion to suit the GRAM mechanism
004372  004748  // Returns  : actual count (normally same as count, will be lower if bank bounds exceeded)
004373  004749        
004374  004750  func flash_Blit4("bank", "offset", "count", "palette16colour"), 1;
004375  004751  // Syntax   : flash_Blit16(bank, offset, pixelcount, pal16);
004376  004752  // Usage    : disp_setGRAM(10,10,29,29); flash_Blit4(FLASHBANK_5, 2048, 400); // display image at 10,10 (20 pixels square) from FLASH image source (200 bytes packed 4:4)
004377  004753  // Notes    : Blit an image to a GRAM window from FLASH storage.
004378  004754  //          : Image is stored in a linear fashion to suit the GRAM mechanism, palette is 16 x 16bit colours
004379  004755  // Returns  : actual count (normally same as count, will be lower if bank bounds exceeded)
004380  004756        
004381  004757  func flash_Blit2("bank", "offset", "count", "palette4colour"), 1;
004382  004758  // Syntax   : flash_Blit16(bank, offset, pixelcount, pal4);
004383  004759  // Usage    : disp_setGRAM(10,10,29,29); flash_Blit2(FLASHBANK_5, 2048, 400); // display image at 10,10 (20 pixels square) from FLASH image source (100 bytes packed 2:2:2:2)
004384  004760  // Notes    : Blit an image to a GRAM window from FLASH storage.
004385  004761  //          : Image is stored in a linear fashion to suit the GRAM mechanism, palette is 4 x 16bit colours
004386  004762  // Returns  : actual count (normally same as count, will be lower if bank bounds exceeded)
004387  004763        
004388  004764  func flash_Blit1("bank", "offset", "count", "pallete2colour"), 1;
004389  004765  // Syntax   : flash_Blit1(bank, offset, pixelcount, pal2);
004390  004766  // Usage    : disp_setGRAM(10,10,29,29); flash_Blit1(FLASHBANK_5, 2048, 400); // display image at 10,10 (20 pixels square) from FLASH image source (50 bytes packed 1:1:1:1:1:1:1:1)
004391  004767  // Notes    : Blit an image to a GRAM window from FLASH storage.
004392  004768  //          : Image is stored in a linear fashion to suit the GRAM mechanism, palette is 2 x 16bit colours
004393  004769  // Returns  : actual count (normally same as count, will be lower if bank bounds exceeded)
004394  004770        
004395  004771  func flash_Exec("bank", "arglistptr"), 1;
004396  004772  // Syntax: res := flash_Exec("bank","arglistptr");
004397  004773  // Usage : res := flash_Exec("bank","arglistptr");
004398  004774  // Notes : returns like a function, current program
004399  004775  //       : calling program is kept active and control returns to it.
004400  004776  //       : If arglistptr is 0, no arguments are passed, else
004401  004777  //       : arglist points to an array, the first element being
004402  004778  //       : the number of elements in the array.
004403  004779  //       : func 'main' in the called bank accepts the arguments.
004404  004780  // WARNING Not currently implemented!
004405  004781        
004406  004782        
004407  004783  func __reserved68(), 0; // do not remove
004408  004784  func __reserved69(), 0; // do not remove
004409  004785  func __reserved70(), 0; // do not remove
004410  004786        
004411  004787  //=========================================================================================================
004412  004788  // I/O and hardware functions
004413  004789  //=========================================================================================================
004414  004790        
004415  004791        
004416  004792        
004417  004793        
004418  004794  func pin_Pulseout("pin", "value"), 1;        // non blocking (program execution continues during pulse)
004419  004795  func pin_PulseoutB("pin", "value"), 1;    // blocking (program execution suspended during pulse)
004420  004796  // Syntax: pin_Pulseout(pin, value);
004421  004797  // Usage : pin_Pulseout(PA3, 100);                 // output 100msec pulse on PA3
004422  004798  // Notes : only available on PA0 to PA9
004423  004799  //       : Invert the state of an output for "value" milliseconds.
004424  004800  //       : pulseout is non blocking, that is, code execution may continue while
004425  004801  //       : a pulse is occuring, and pulses can occur on multiple pins simultaneously.
004426  004802  //       : If not already an output, pin is automatically made a push/pull output,
004427  004803  //       : and the last state of its output latch will determine pulse polarity.
004428  004804  //       : It's its open drain state is not altered if the pin was already an output.
004429  004805  //       : If pulseout is called while pulseout is still active, the pulse timer
004430  004806  //       : will simply be updated with the new "value" and the pulse will continue
004431  004807  //       : with the extended value.
004432  004808  //       : returns true if the pin number is legal (usually ignored)
004433  004809        
004434  004810        
004435  004811  func pin_Counter("pin", "mode", "OVFfunction"), 1;
004436  004812  // Syntax: pin_Counter(pin, mode, userfunc);
004437  004813  // Usage : pin_Counter(PA5, 1, stopfunc);         // count rising edge pulses on pin PA5, call stopfunc on overflow
004438  004814  // Notes : only available on PA4 to PA9
004439  004815  //       : Connect a counter to a pin to count transistions, and optionally call an event function
004440  004816  //       : when the 16bit counter wraps from 0xFFFF to zero. The counter can be read or written
004441  004817  //       : to at any time with peekW and pokeW, therefore, the count may be set to eg 0xFFF0 so that eg:
004442  004818  //       : user function "OVFfuction" will be called after 16 pulses. If "OVFfunction" is set to zero, only the
004443  004819  //       : counter will increment, and simply wrap back to zero from 0xFFFF. If "OVFfunction" points to a user
004444  004820  //       : function, wnen the event fires, pin_Counter will be disabled, and will need to be re-armed (ie '1shot' operation)
004445  004821  //       : The pin may be configured as an input or output, the function behaves the same.
004446  004822  //       : All six pin counters may be active simultaneously, and the maximum frequency of pin transistions
004447  004823  //       : should not exceed a few Khz in mode 1 and 2and are usually used for simple process control counting.
004448  004824  //       : "mode" has the following effect:-
004449  004825  //       : mode COUNT_OFF(0)  = disconnect the counter from the pin, "OVFfunction" therefore ignored, and counting is inhibited.
004450  004826  //       : mode COUNT_RISE(1) = increment on every rising edge
004451  004827  //       : mode COUNT_FALL(2) = increment on every falling edge
004452  004828  //       : mode COUNT_EDGE(3) = increment on every rising and falling edge
004453  004829        
004454  004830  //------------------------------------------------------------------//
004455  004831  // pin counter mode constants                                       //
004456  004832  //------------------------------------------------------------------//
004457  004833  #CONST
004458  004838  #END
004459  004839        
004460  004840  func Qencoder1("PHApin", "PHBpin", "mode"), 1;
004461  004841  // Syntax: Qencoder1(pinA, pinB, mode);
004462  004842  // Usage : Qencoder1(PA4, PA5, stopfunc);         // connect PA4 and PA5 pins to qudrature encoder module #1
004463  004843  // Notes : not available on pins PA14 and PA15
004464  004844  //       : Connect a quadrature encoder to a pair of pins The position counter and delta can be read
004465  004845  //       : or written to at any time with peekW and pokeW using the following constants:-
004466  004846  //       : It is necessary to configure the pins first, depending on your requirements, eg
004467  004847  //       :           pin_Set(PIN_INP_HI, PA4);     // PA4 as input, with pullup to Vcc
004468  004848  //       : or maybe  pin_Set(PIN_INP, PA4);        // PA4 as input, no pullup or pulldown
004469  004849  //       : Returns true if the pin numbers are legal (usually ignored)
004470  004850  //    QEN1_COUNTER_LO
004471  004851  //    QEN1_COUNTER_HI
004472  004852  //    QEN1_DELTA This is reset to 0 when read
004473  004853        
004474  004854  func Qencoder2("PHApin", "PHBpin", "mode"), 1;
004475  004855  // Syntax: Qencoder2(pinA, pinB, mode);
004476  004856  // Usage : Qencoder2(PA4, PA5, stopfunc);         // connect PA4 and PA5 pins to qudrature encoder module #2
004477  004857  // Notes : not available on pins PA14 and PA15
004478  004858  //       : Connect a quadrature encoder to a pair of pins The position counter and delta can be read
004479  004859  //       : or written to at any time with peekW and pokeW using the following constants:-
004480  004860  //       : It is necessary to configure the pins first, depending on your requirements, eg
004481  004861  //       :           pin_Set(PIN_INP_HI, PA4);     // PA4 as input, with pullup to Vcc
004482  004862  //       : or maybe  pin_Set(PIN_INP, PA4);        // PA4 as input, no pullup or pulldown
004483  004863  //       : Returns true if the pin numbers are legal (usually ignored)
004484  004864  //    QEN2_COUNTER_LO
004485  004865  //    QEN2_COUNTER_HI
004486  004866  //    QEN2_DELTA This is reset to 0 when read
004487  004867        
004488  004868        
004489  004869  func Qencoder1Reset(), 0;
004490  004870  // Syntax: Qencoder1Reset();
004491  004871  // Usage : Qencoder1Reset();     // reset the counter and delta value for encoder #1
004492  004872  // Notes :
004493  004873  //    QEN1_COUNTER_LO is reset to zero
004494  004874  //    QEN1_COUNTER_HI is reset to zero
004495  004875  //    QEN1_DELTA is reset to zero
004496  004876        
004497  004877  func Qencoder2Reset(), 0;
004498  004878  // Syntax: Qencoder2Reset();
004499  004879  // Usage : Qencoder2Reset();     // reset the counter and delta value for encoder #2
004500  004880  // Notes :
004501  004881  //    QEN2_COUNTER_LO is reset to zero
004502  004882  //    QEN2_COUNTER_HI is reset to zero
004503  004883  //    QEN2_DELTA is reset to zero
004504  004884        
004505  004885        
004506  004886  func pin_PulseoutCount("pin", "freq", "count", "function"), 1;        // pulse pin at freq count times calling function when complete
004507  004887  // Syntax: pin_PulseoutCount(pin, freq, count, function);
004508  004888  // Usage : pin_PulseoutCount(PA4, 1000, 5000, 0);            // output 5000 1msec pulses on PA3
004509  004889  // Notes : only available on PA4 to PA9, maximum 3 active at any one time
004510  004890  //       : Invert the state of an output at a "freq" freuency "count" times.
004511  004891  //       : PulseoutCount is non blocking, that is, code execution may continue while
004512  004892  //       : pulses are occuring, and pulses can occur on multiple pins simultaneously.
004513  004893  //       : If not already an output, pin is automatically made a push/pull output,
004514  004894  //       : and the last state of its output latch will determine pulse polarity.
004515  004895  //       : It's its open drain state is not altered if the pin was already an output.
004516  004896  //       : If PulseoutCount is called while PulseoutCount is still active, the pulse counter
004517  004897  //       : will simply have the new "value" added to it.
004518  004898  //       : returns false if the pin number is illegal, freq is < 10, or all counters in use
004519  004899  //       : returns true if the pin number is legal (usually ignored)
004520  004900        
004521  004901  func __reserved72(), 0; // do not remove
004522  004902        
004523  004903  func pwm_Init("pin", "mode", "value"), 1;    // set pin PA4-PA9 for the required PWM mode and select its source
004524  004904  // Syntax: pwm_Init(pin, value);
004525  004905  // Usage : pwm_Init(PA4, 1, 500);                 // output 50% duty cycle on PA4
004526  004906  // Notes : only available on PA4 to PA9
004527  004907  //       : Mode PWM_OFF(0)    : Turn off the PWM (pin is left as output)
004528  004908  //       : Mode PWM_PLAIN(1)  : Plain PWM value is 0-1000, corresponding to 0-100% duty cycle.
004529  004909  //       :                    : Raw frequency ~70khz. A value of 1 is not valid
004530  004910  //       : Mode PWM_SERVO(2)  : Servo PWM value is 100-200, corresponding to 1.00 to 2.00 ms
004531  004911  //       :                    : Values of 0 to 600 are valid (0-6ms), but should be used with caution.
004532  004912  //       :                    : Repetition rate ~50hz or 20ms
004533  004913  //       : Mode PWM_BINARY(3) : Binary PWM value is 0-1024, corresponding to 0-100% duty cycle.
004534  004914  //       :                    : Raw frequency ~68khz. A value of 1 is not valid
004535  004915  //       : pwm_Init is non blocking and the pwm continues until turn off
004536  004916  //       : Returns true if the pin number is legal (usually ignored)
004537  004917        
004538  004918  //------------------------------------------------------------------------------
004539  004919  // PWM Constants
004540  004920  //------------------------------------------------------------------------------
004541  004921  #CONST
004542  004934  #END
004543  004935        
004544  004936  func OW_Reset("pin"), 1;                             // issue 1wire reset command
004545  004937  // Syntax   : OW_Reset(PA0);
004546  004938  // Usage    : OW_Reset(PA0);
004547  004939  // Notes    : Only available on PA0 to PA13
004548  004940  //          : Resets  ONEWIRE device
004549  004941  //          : Returns the status, 0 = ACK.
004550  004942  //          :
004551  004943        
004552  004944  func OW_Read("pin"), 1;                              // read data from 1wire bus
004553  004945  // Syntax   : OW_Read(PA0);
004554  004946  // Usage    : arg1 := OW_Read(PA0);
004555  004947  // Notes    : Only available on PA0 to PA13
004556  004948  //          : Reads value of the ONEWIRE pin
004557  004949  //          : that was previously selected for ONEWIRE comms.
004558  004950  //          :
004559  004951  //          : pin = 0 : the next byte from the ONEWIRE bus
004560  004952        
004561  004953  func OW_Read9("pin"), 1;                             // read data from 1wire bus, 9bit mode
004562  004954  // Syntax   : OW_Read9(PA0);
004563  004955  // Usage    : OW_Read9(PA0);
004564  004956  // Notes    : Only available on PA0 to PA13
004565  004957  //          : Reads 9 bit value of the appropriate ONEWIRE pin
004566  004958  //          : that was previously selected for ONEWIRE comms.
004567  004959  //          :
004568  004960  //          : read the 9 bits from the ONEWIRE bus
004569  004961        
004570  004962  func OW_Write("pin", "value"), 0;                      // write value to 1wire device
004571  004963  // Syntax   : OW_Write(PA0, arg);
004572  004964  // Usage    : OW_Write(PA0, arg);
004573  004965  // Notes    : Only available on PA0 to PA13
004574  004966  //          : Sends ONEWIRE data on the appropriate
004575  004967  //          : pin that was previously  selected as ONEWIRE comms.
004576  004968  //          :
004577  004969  //          : write arg to the ONEWIRE bus
004578  004970        
004579  004971  func __reserved77(), 0; // do not remove
004580  004972  func __reserved78(), 0; // do not remove
004581  004973        
004582  004974  func sys_GetDateVar("&year", "&month", "&day"), 0;              // get year, month, day into variables
004583  004975  // Syntax: sys_GetDateVar(&year, &month, &day);
004584  004976  // Usage : sys_GetDateVar(&year, &month, &day);
004585  004977  // Notes : Retrieves the date values into variables
004586  004978        
004587  004979  func sys_GetTimeVar("&hour", "&minute", "&second", "&msecs"), 0;              // get hour, minute, second, millseconds into variables
004588  004980  // Syntax: sys_GetTimeVar(&hour, &minute, &second, &msecs);
004589  004981  // Usage : sys_GetTimeVar(&hour, &minute, &second, &msecs);
004590  004982  // Notes : Retrieves the time values into variables
004591  004983        
004592  004984  func sys_PmmC(), 0;
004593  004985  // Syntax: sys_PmmC();
004594  004986  // Usage : to(mystring); sys_PmmC();   // save PmmC name and revision string to buffer
004595  004987  // Notes : print the system PmmC name and revision eg "Diablo16\n1.0"
004596  004988  //       : Can be captured to a buffer using the to( function
004597  004989  //       : Returns nothing.
004598  004990        
004599  004991  func sys_Driver(), 0;
004600  004992  // Syntax: sys_Driver();
004601  004993  // Usage : to(mystring); sys_Driver();   // save Driver name and date string to buffer
004602  004994  // Notes : print the system PmmC name and revision eg "uLCD-32WDTU-A\n130411"
004603  004995  //       : Can be captured to a buffer using the to( function
004604  004996  //       : Returns nothing.
004605  004997        
004606  004998  func gfx_Scope("left", "width", "yzero", "n", "xstep", "Yamp", "colorbg", "&old_y1", "&new_y1", "color1", "&old_y2", "&new_y2", "color2", "&old_y3", "&new_y3", "color3", "&old_y4", "&new_y4", "color4"), 0;
004607  004999  // Notes : Draws up to 4 waveforms from table(s) of vertices at the specified origin.
004608  005000  //       : "Left" is the left margin, "Width" is the width, "yzero" is the y position
004609  005001  //       : that corresponds to a y value of zero, normally "Top" + "Height" for
004610  005002  //       : a graph, or "Top" + "Height"/2 for a scope. "n" is the number of
004611  005003  //       : elements in each buffer. This will need to be greater than "width" for negative
004612  005004  //       : "xstep" values. "Yamp" is for amplification in the Y direction, 100 is unity.
004613  005005  //       : pass 0 as the address for any unused traces
004614  005006  //       : X position is incremented each point by "xstep" pixels.
004615  005007  //       : Y values are derived from a Y buffer "newy" (signed values).
004616  005008  //       : 2 buffers need to be supplied, "newy" contains new
004617  005009  //       : points to be drawn, "oldy" contains most recent set
004618  005010  //       : of points to be un-drawn. After the waveform is drawn,
004619  005011  //       : "newy" buffer is automatically copied to "oldy" buffer.
004620  005012        
004621  005013        
004622  005014  func ana_HS("rate", "samples", "&IO1", "&IO2", "&IO3", "&IO4", "COMPLETEfunction"), 0;
004623  005015  // Syntax: ana_HS(rate, samples, IO1buf, IO2buf, IO3buf, IO4buf, userFunction);
004624  005016  // Usage : ana_HS(1000, 10, IO1buf, 0, 0, 0, myFunc);
004625  005017  // Notes : Collects "samples" samples at "rate" frequency for 0 to 4 analogue pins
004626  005018  //       : and calls "COMPLETEfunction" when done.
004627  005019  //       : "rate" is samples in 100 of samples per second
004628  005020  //       : Any unused IOx pins should have their buffer addresses set to 0
004629  005021  //       : For performance reasons samples are taken in chunks of 32, thus if you
004630  005022  //       : request 33 samples there will be a delay of 31 samples before
004631  005023  //       : "COMPLETEfunction" is called
004632  005024  //       : If Touch is enabled this function should be called no more than once per
004633  005025  //       : millisecond, otherwise touch behaviour could be eratic.
004634  005026        
004635  005027        
004636  005028  func sys_ErrorMessage("msgnum"), 1;
004637  005029        
004638  005030  //==============================//
004639  005031  // NeoPixel specific functions  //
004640  005032  //==============================//
004641  005033        
004642  005034  func NP_Write("pin", "data", "size", "Options", "RepeatFirst", "Repeat", "RepeatLast"), 1;    // Write a string of colours to a NeoPixel 'display'
004643  005035  // Syntax: NP_Write(pin, data, size, Options, RepeatFirst, Repeat, RepeatLast);
004644  005036  // Usage : NP_Write(PA4, data, 50, NP_565, 10, 0, 0);                 
004645  005037  // Notes : pin         : The I/O pin for the operation PA0 to PA13
004646  005038  //       : data        : Address of data to be sent
004647  005039  //       : size        : number of colour 'sets' to follow
004648  005040  //       : Options     : format of colour data to be sent, NP_565, NP_RGB, or NP_XRGB. i.e. 2, 3 or 4 bytes per colour
004649  005041  //       : RepeatFirst : Number of times to repeat the first colour (0 means first colour is not considered 'special')
004650  005042  //       : Repeat      : Number of times to repeat the colours between first and last
004651  005043  //       : RepeatLast  : Number of times to repeat the last colour (0 means last colour is not considered 'special')
004652  005044  //       : Returns true if the pin number is legal (usually ignored)
004653  005045  //       : Due to the critical timing requirements of the NeoPixel, the system Timer is disabled during this operation.
004654  005046  //       : Comms Interrupts should also be disabled by the user, otherwise errors may occur.
004655  005047        
004656  005048  // NeoPixel related constants
004657  005049  #CONST
004658  005053  #END
004659  005054        
004660  005055  func __reserved85(), 0; // do not remove
004661  005056  func __reserved86(), 0; // do not remove
004662  005057        
004663  005058  //==============================================//
004664  005059  // spi flash device specific functions          //
004665  005060  //==============================================//
004666  005061        
004667  005062  func spiflash_SIG("spi#", "enablepin"), 1;         // read Jedec signature from SPI Flash device
004668  005063  // Syntax   : spiflash_SIG("spi#","enablepin");
004669  005064  // Usage    : var := spiflash_SIG(SPI1, PA0);
004670  005065  // Notes    : A FLASH storage device connected to the selected SPI port, and correctly initialised with the
004671  005066  //          : spi_Init(...) function, the Electronic Signature of the device can be read using this function. The only
004672  005067  //          : devices supported so far are the M25Pxx range of devices which are 512Kbit to 128Mbit Serial Flash Memory.
004673  005068  //          : Other similar devices should also work, provided they do not exceed 128Mbit.
004674  005069  //          : Release from Deep Power-down, and Read Electronic Signature. Only the low order byte is valid, the upper
004675  005070  //          : byte is ignored.
004676  005071        
004677  005072  func spiflash_ID("spi#", "enablepin"), 1;          // read ID code from FLASH device
004678  005073  // Syntax   : spiflash_ID("spi#","enablepin");
004679  005074  // Usage    : var := spiflash_ID(SPI1, PA0);
004680  005075  // Notes    : A FLASH storage device connected to the selected SPI port, and correctly initialised with the
004681  005076  //          : spi_Init(...) function, the memory type and capacity from the flash device can be read using this function
004682  005077  //          : The only devices supported so far M25Pxx range of devices which are 512Kbit to 128Mbit Serial Flash Memory.
004683  005078  //          : Other similar devices should also work, provided they do not exceed 128Mbit.
004684  005079  //          : Reads the memory type and capacity from the serial FLASH device. Hi byte contains type, and low byte
004685  005080  //          : contains capacity. Refer to the device data sheet for further information.
004686  005081        
004687  005082  func spiflash_BulkErase("spi#", "enablepin"), 0;    // erase the entire FLASH device
004688  005083  // Syntax   : spiflash_BulkErase("spi#","enablepin");
004689  005084  // Usage    : spiflash_BulkErase(SPI1, PA0);
004690  005085  // Notes    : A FLASH storage device connected to the selected SPI port, and correctly initialised with the
004691  005086  //          : spi_Init(...) function, the FLASH device can be completely erased using this function. The only devices
004692  005087  //          : supported so far are the M25Pxx range of devices which are 512Kbit to 128Mbit Serial Flash Memory.
004693  005088  //          : Other similar devices should also work, provided they do not exceed 128Mbit.
004694  005089  //          : Erases the entire flash media device. The function returns no value, and the operation can take up to 80
004695  005090  //          : seconds depending on the size of the flash device. Note that not all devices support this command.
004696  005091        
004697  005092  func spiflash_BlockErase("spi#", "enablepin", "block"), 0;            // erase the required 64k flash block
004698  005093  // Syntax   : spiflash_BlockErase("spi#", "enablepin", "block")
004699  005094  // Usage    : var := spiflash_BlockErase(SPI1, PA0, block_num)
004700  005095  // Notes    : A FLASH storage device connected to the selected SPI port, and correctly initialised with the
004701  005096  //          : spi_Init(...) function, the FLASH block can be erased using this function. The only devices supported so
004702  005097  //          : far are the M25Pxx range of devices which are 512Kbit to 128Mbit Serial Flash Memory.
004703  005098  //          : Other similar devices should also work, provided they do not exceed 128Mbit.
004704  005099  //          : E.g. there are 32 x 64K blocks on a 2Mb flash device.
004705  005100  //          : blockAddress The address of the 64k FLASH block to be erased.
004706  005101  //          : Erases the required block in a FLASH media device. The function returns no value, and the operation
004707  005102  //          : can take up to 3 milliseconds.
004708  005103        
004709  005104  func spiflash_SetAdd("spi#", "HiWord", "LoWord"), 0;           // set stream byte address
004710  005105  // Syntax: spiflash_SetAdd(AddHiWord, AddLoWord);
004711  005106  // Usage : spiflash_SetAdd(SPI1, arg1, arg2);
004712  005107  // Notes : Set FLASH internal Address pointer for bytewise access on the specified SPI port
004713  005108        
004714  005109  func spiflash_Read("*dest", "size", "spi#", "enablepin"), 1;
004715  005110  // Syntax: res := spiflash_Read("*dest", "size", "spi#", "enablepin"),
004716  005111  // Usage : res := spiflash_Read(memblock, 20, SPI1, PA0);
004717  005112  // Notes : Reads the specified number of bytes from the FLASH memory device on the specified SPI port and enable pin
004718  005113  //       : into the specified destination. The destination is a string pointer (i.e. BYTE aligned). The source
004719  005114  //       : is the address set by spiflash_SetAdd(), or incremented by subsequent reads or writes.
004720  005115  //       : returns number of characters read
004721  005116  //       : if "dest" is zero, data is read direct to GRAM window
004722  005117  //       :
004723  005118        
004724  005119  func spiflash_Write("*source", "size", "spi#", "enablepin"), 1;
004725  005120  // Syntax: res := fwrite("*source", "size", "spi#", "enablepin"),
004726  005121  // Usage : res := fwrite(memblock, 20, SPI1, PA0);
004727  005122  // Notes : Writes the specified number of bytes to the FLASH memory device on the specified SPI port and enable pin
004728  005123  //       : from the specified source. The source is a standard address or pointer (i.e. WORD aligned). The target
004729  005124  //       : is the address set by spiflash_SetAdd(), or incremented by subsequent reads or writes.
004730  005125  //       : returns number of bytes written
004731  005126  //       :
004732  005127        
004733  005128  func spiflash_Image("x", "y", "spi#", "enablepin"), 1;
004734  005129  // Syntax: spiflash_Image(x, y, "spi#", "enablepin");
004735  005130  // Usage : spiflash_Image(10, 10, SPI1, PA0);
004736  005131  // Notes : Display an image from a file at the current FLASH position set by spiflash_SetAdd()
004737  005132  //       : The image is displayed at x,y (with respect to top left corner).
004738  005133        
004739  005134  func spiflash_PutC("char", "spi#", "enablepin"), 0;
004740  005135  // Syntax: spiflash_PutC("char", "spi#", "enablepin");
004741  005136  // Usage : spiflash_PutC('x', SPI1, PA0);
004742  005137  // Notes : Writes a character (or byte) to the FLASH memory device on the specified SPI port and enable pin
004743  005138  //       : from the specified source. The source is a standard address or pointer (i.e. WORD aligned). The target
004744  005139  //       : is the address set by spiflash_SetAdd(), or incremented by subsequent reads or writes.
004745  005140        
004746  005141  func spiflash_GetC("spi#", "enablepin"), 1;
004747  005142  // Syntax: spiflash_GetC("spi#", "enablepin");
004748  005143  // Usage : mychar := fgetC(SPI1, PA0);
004749  005144  // Notes : Reads a character (or byte) from the FLASH memory device on the specified SPI port and enable pin
004750  005145  //       : into the specified destination. The source is the address set by spiflash_SetAdd(), or incremented
004751  005146  //       : by subsequent reads or writes.
004752  005147  //       : returns next char from file
004753  005148        
004754  005149  func spiflash_PutW("word", "spi#", "enablepin"), 0;
004755  005150  // Syntax: spiflash_PutW("word", "spi#", "enablepin");
004756  005151  // Usage : spiflash_PutW(0x1234, SPI1, PA0);
004757  005152  // Notes : Writes a word to the FLASH memory device on the specified SPI port and enable pin
004758  005153  //       : from the specified source. The source is a standard address or pointer (i.e. WORD aligned). The target
004759  005154  //       : is the address set by spiflash_SetAdd(), or incremented by subsequent reads or writes.
004760  005155        
004761  005156  func spiflash_GetW("spi#", "enablepin"), 1;
004762  005157  // Syntax: spiflash_GetW("spi#", "enablepin");
004763  005158  // Usage : myword := fgetW(SPI1, PA0);
004764  005159  // Notes : Reads a word from the FLASH memory device on the specified SPI port and enable pin
004765  005160  //       : into the specified destination. The source is the address set by spiflash_SetAdd(), or incremented
004766  005161  //       : by subsequent reads or writes.
004767  005162  // Notes : returns next word in file
004768  005163        
004769  005164  func spiflash_PutS("*source", "spi#", "enablepin"), 1;
004770  005165  // Syntax: res := spiflash_Puts("*source", "spi#", "enablepin"),
004771  005166  // Usage : res := spiflash_Puts(mystring, SPI1, PA0);
004772  005167  // Notes : Writes a string to the FLASH memory device on the specified SPI port and enable pin
004773  005168  //       : from the specified source. The source is a standard address or pointer (i.e. WORD aligned). The target
004774  005169  //       : is the address set by spiflash_SetAdd(), or incremented by subsequent reads or writes.
004775  005170  //       : returns number of characters written
004776  005171  //       :
004777  005172        
004778  005173  func spiflash_GetS("*string", "size", "spi#", "enablepin"), 1;
004779  005174  // Syntax: res := spiflash_Gets("*string", "size", "spi#", "enablepin");
004780  005175  // Usage : res := spiflash_Gets(mystr , 81, SPI1, PA0); // read up to 80 chars
004781  005176  // Notes : Reads a string from the FLASH memory device on the specified SPI port and enable pin
004782  005177  //       : into the specified destination. The source is the address set by spiflash_SetAdd(), or incremented
004783  005178  //       : by subsequent reads or writes.
004784  005179  //       : returns pointer to string or null if failed.
004785  005180  //       : spiflash_GetS(...) automatically appends a null-terminator to the data read.
004786  005181  //       : NB:- only reads up to "size-1" characters into "string"
004787  005182  //       : spiflash_GetS(...) will stop reading when any of the following conditions are true:
004788  005183  //       : A] It has read n-1 bytes (one character is reserved for the null-terminator)
004789  005184  //       : B] It encounters a newline character (a line-feed in the compilers tested here), or
004790  005185  //       : C] It reaches the end of file
004791  005186  //       : D] A read error occurs.
004792  005187        
004793  005188  func spiflash_LoadFunction("spi#", "enablepin"), 1;
004794  005189  // Syntax: res := spiflash_LoadFunction("spi#", "enablepin");
004795  005190  // Usage : myfunc := spiflash_LoadFunction(SPI1, PA0);
004796  005191  // Notes : Load a function or program from the FLASH memory device on the specified SPI port and enable pin at
004797  005192  //       : the address set by spiflash_SetAdd(), or incremented by subsequent reads or writes and
004798  005193  //       : return a function pointer to the allocation.
004799  005194  //       : The function can then be invoked just like any other
004800  005195  //       : function would be called via a function pointer.
004801  005196  //       : Parameters may be passed to it in a conventional way.
004802  005197  //       : The function may be discarded at any time when no
004803  005198  //       : longer required, thus freeing its memory resources.
004804  005199  //       : The loaded function can be discarded with mem_Free(..)
004805  005200  //       : eg:
004806  005201  //       : popupWindow := spiflash_LoadFunction("popupWindow1.4fn");
004807  005202  //       : if(!popupWindow) goto LoadFunctionFailed; // could not load the function !!!
004808  005203  //       : then elsewhere in your program:-
004809  005204  //       : res := popupWindow(MYMODE,"My Title","My Popup Text");
004810  005205  //       : if(res == QUIT_APPLICATION) goto exitApp;
004811  005206  //       : Later in your program, when popupWindow is no longer
004812  005207  //       : required for the application:-
004813  005208  //       : res := mem_Free(popupWindow);
004814  005209  //       : if(!res) goto FreeFunctionFailed; // should never happen if memory not corrupted
004815  005210  //       : The callers stack is shared by the loaded function,
004816  005211  //       : however any global variables in the loaded function
004817  005212  //       : are private to that function.
004818  005213  //
004819  005214        
004820  005215  func spiflash_Run("spi#", "enablepin", "arglistptr"), 1;
004821  005216  // Syntax: res := spiflash_Run("spi#", "enablepin", "arglistptr");
004822  005217  // Usage : res := spiflash_Run(SPI1, PA0, argptr);
004823  005218  // Notes : current program releases any allocated memory but
004824  005219  //       : retains the stack and global memory.
004825  005220  //       : If arglistptr is 0, no arguments are passed, else
004826  005221  //       : arglist points to an array, the first element being
004827  005222  //       : the number of elements in the array.
004828  005223  //       : func 'main' in the called program accepts
004829  005224  //       : the arguments, if any. The arguments can only
004830  005225  //       : be passed by value, no pointers or references can be
004831  005226  //       : used as all memory is cleared before the file
004832  005227  //       : is loaded. Refer to spiflash_Exec and spiflash_LoadFunction
004833  005228  //       : for functions that can pass by reference.
004834  005229        
004835  005230  func spiflash_Exec("spi#", "enablepin", "arglistptr"), 1;
004836  005231  // Syntax: res := spiflash_Exec("spi#", "enablepin", "arglistptr");
004837  005232  // Usage : res := spiflash_Exec(SPI1, PA0, "arglistptr");
004838  005233  // Notes : returns like a function, current program
004839  005234  //       : calling program is kept active and control returns to it.
004840  005235  //       : If arglistptr is 0, no arguments are passed, else
004841  005236  //       : arglist points to an array, the first element being
004842  005237  //       : the number of elements in the array.
004843  005238  //       : func 'main' in the called program accepts the arguments.
004844  005239  //       : This function is similar to spiflash_LoadFunction(...), however,
004845  005240  //       : the function argument list is passed by pointer, and
004846  005241  //       : the memory consumed by the function is released as
004847  005242  //       : soon as the function completes.
004848  005243        
004849  005244  func spiflash_LoadImageControl("spi#", "enablepin"), 1;
004850  005245  // Syntax: hImagelist := spiflash_LoadImageControl ("spi#", "enablepin"),
004851  005246  // Usage : hImagelist := spiflash_LoadImageControl (SPI1, PA0);
004852  005247  // Notes : Reads a control file to create an image list from the FLASH memory device on the specified SPI port
004853  005248  //       : and enable pin. The source is the address set by spiflash_SetAdd(), or incremented by subsequent reads
004854  005249  //       : or writes. The ".dat" file is first and is immediately followed a ^Z and then by the ".gci' file.
004855  005250  //       : Returns NULL if function fails.
004856  005251  //       : Returns a handle (pointer to the memory allocation) to the
004857  005252  //       : image control list that has been created.
004858  005253        
004859  005254  // Notes : This function Calculates the size of a chunk of memory required for
004860  005255  //       : a image list and populates it from the image control file ("*.dat")
004861  005256  //       : therefore, when imagelist is no longer required, you must de-allocate
004862  005257  //       : the image list memory by using eg:- mem_Free(hImagelist);
004863  005258  //       : to restore the heap.
004864  005259  //       :
004865  005260        
004866  005261  func spiflash_PlayWAV("spi#", "enablepin"), 1;
004867  005262  // Syntax: spiflash_PlayWAV("spi#", "enablepin");
004868  005263  // Usage : spiflash_PlayWAV(SPI1, PA0);
004869  005264  // Notes : Play a wave file from the FLASH memory device on the specified SPI port and enable pin.
004870  005265  //       : The source is the address set by spiflash_SetAdd(), or incremented by subsequent reads
004871  005266  //       : or writes.
004872  005267  //       : This function automatically grabs a chunk
004873  005268  //       : of memory for a file buffer, and a wave
004874  005269  //       : buffer. The minimum memory requirement is
004875  005270  //       : about 580 bytes for the disk io service and
004876  005271  //       : a minimum wave buffer size of 1024. The size
004877  005272  //       : of the wave buffer allocation
004878  005273  //       : can be increased by the snd_BufSize function.
004879  005274  //       : The default size 1024 bytes.
004880  005275  //       : NB the memory is only required during the
004881  005276  //       : duration of play, and is automatically
004882  005277  //       : released while not in use.
004883  005278  //       : See the Sound Class services for other associated controls.
004884  005279  //       : If there are no errors, returns number of blocks to play (1 to 32767)
004885  005280  //       : If errors occured, the folling is returned
004886  005281  //       : -7  : Insufficient memory available for WAV buffer and file
004887  005282  //       : -6  : cant play this rate
004888  005283  //       : -5  : no data chunk found in first rsector
004889  005284  //       : -4  : no format data
004890  005285  //       : -3  : no wave chunk signature
004891  005286  //       : -2  : bad wave file format
004892  005287  //       : -1  : file not found
004893  005288        
004894  005289  //==============================================//
004895  005290  // more com functions                           //
004896  005291  //==============================================//
004897  005292        
004898  005293  func com1_TXblock("buf", "bufsize"), 0;                       // commence a block transmission
004899  005294  // Syntax   : com1_TXblock("buf", "bufsize");
004900  005295  // Usage    : com1_TXblock(mybuf, 30);                         // point to the TX buffer and send 30 character
004901  005296  // *Notes   : Bufsize bytes are transmitted to the serial port from the string pointer "buf".
004902  005297  //          : if a transmit buffer is active and space is available this function will return almost
004903  005298  //          : immediately otherwise it will block until until the space is available, or the data is transmitted.
004904  005299        
004905  005300  func com1_RXblock("buf", "bufsize"), 0;                       // commence a block reception
004906  005301  // Syntax   : com1_RXblock("buf", "bufsize");
004907  005302  // Usage    : com1_RXblock(mybuf, 30);                        // point to the RX buffer and receive 30 character
004908  005303  // *Notes   : Bufsize bytes are received from the serial port to the string pointer "buf".
004909  005304  //          : if a receive buffer is active and bufsize characters are available this function will return almost
004910  005305  //          : immediately otherwise it will block until until the required bytes are received.
004911  005306        
004912  005307  func com2_TXblock("buf", "bufsize"), 0;                       // commence a block transmission
004913  005308  // Syntax   : com_TXblock("buf", "bufsize");
004914  005309  // Usage    : com_TXblock(mybuf, 30);                         // point to the TX buffer and send 30 character
004915  005310  // *Notes   : Bufsize bytes are transmitted to the serial port from the string pointer "buf".
004916  005311  //          : if a transmit buffer is active and space is available this function will return almost
004917  005312  //          : immediately otherwise it will block until until the space is available, or the data is transmitted.
004918  005313        
004919  005314  func com2_RXblock("buf", "bufsize"), 0;                       // commence an block reception
004920  005315  // Syntax   : com_RXblock("buf", "bufsize");
004921  005316  // Usage    : com_RXblock(mybuf, 30);                        // point to the RX buffer and receive 30 character
004922  005317  // *Notes   : Bufsize bytes are received from the serial port to the string pointer "buf".
004923  005318  //          : if a receive buffer is active and bufsize characters are available this function will return almost
004924  005319  //          : immediately otherwise it will block until until the required bytes are received.
004925  005320        
004926  005321  func com3_TXblock("buf", "bufsize"), 0;                       // commence a block transmission
004927  005322  // Syntax   : com_TXblock("buf", "bufsize");
004928  005323  // Usage    : com_TXblock(mybuf, 30);                         // point to the TX buffer and send 30 character
004929  005324  // *Notes   : Bufsize bytes are transmitted to the serial port from the string pointer "buf".
004930  005325  //          : if a transmit buffer is active and space is available this function will return almost
004931  005326  //          : immediately otherwise it will block until until the space is available, or the data is transmitted.
004932  005327        
004933  005328  func com3_RXblock("buf", "bufsize"), 0;                       // commence an block reception
004934  005329  // Syntax   : com_RXblock("buf", "bufsize");
004935  005330  // Usage    : com_RXblock(mybuf, 30);                        // point to the RX buffer and receive 30 character
004936  005331  // *Notes   : Bufsize bytes are received from the serial port to the string pointer "buf".
004937  005332  //          : if a receive buffer is active and bufsize characters are available this function will return almost
004938  005333  //          : immediately otherwise it will block until until the required bytes are received.
004939  005334        
004940  005335  func disp_BlitPixelsFromCOM1(), 0;                     // Writes current GRAM window pixels to the display from the COM port
004941  005336  // Syntax: disp_BlitPixelsFromCOM1();                  New in v1.1
004942  005337  // Usage : disp_BlitPixelsFromCOM1();
004943  005338  // Notes : Writes the number of pixels defined by the last disp_setGRAM() call to the
004944  005339  //       : display from the specified com port.
004945  005340        
004946  005341  func disp_BlitPixelsFromCOM2(), 0;                     // Writes current GRAM window pixels to the display from the COM port
004947  005342  // Syntax: disp_BlitPixelsFromCOM2();                  New in v1.1
004948  005343  // Usage : disp_BlitPixelsFromCOM2();
004949  005344  // Notes : Writes the number of pixels defined by the last disp_setGRAM() call to the
004950  005345  //       : display from the specified com port.
004951  005346        
004952  005347  func disp_BlitPixelsFromCOM3(), 0;                     // Writes current GRAM window pixels to the display from the COM port
004953  005348  // Syntax: disp_BlitPixelsFromCOM3();                  New in v1.1
004954  005349  // Usage : disp_BlitPixelsFromCOM3();
004955  005350  // Notes : Writes the number of pixels defined by the last disp_setGRAM() call to the
004956  005351  //       : display from the specified com port.
004957  005352        
004958  005353        
004959  005354  //==============================================//
004960  005355  // crc generation functions                     //
004961  005356  //==============================================//
004962  005357        
004963  005358  func crc_CSUM_8("buf","count"), 1;                      // given a pointer to a buffer and a byte count, calculate the 8bit LRC
004964  005359  // *Notes   : (if you calculate all of the incoming data
004965  005360  //          : INCLUDING the CRC, the result should be 0x00
004966  005361  //          : This is equivalent to simple addition of all bytes
004967  005362  //          : and returning the negated sum an 8 bit value.
004968  005363  //          : For the standard test string "123456789",
004969  005364  //          : crc_CSUM_8 will return 0x0023.
004970  005365        
004971  005366        
004972  005367  func crc_16("buf","count"), 1;                      // given a pointer to a buffer and a byte count, calculate CRC16
004973  005368  // *Notes   : The "mode" argument may be READ, WRITE or CHECK
004974  005369  //          : (if you calculate all of the incoming data
004975  005370  //          : INCLUDING the CRC, the result should be 0x0000
004976  005371  //          : For the standard test string "123456789",
004977  005372  //          : crc_16 will return 0xBB3D.
004978  005373        
004979  005374        
004980  005375  func crc_MODBUS("buf","count"), 1;                  // given a pointer to a buffer and a byte count, calculate CRC16 for MODBUS
004981  005376  // *Notes   : (if you calculate all of the incoming data
004982  005377  //          : INCLUDING the CRC, the result should be 0x0000
004983  005378  //          : For the standard test string "123456789",
004984  005379  //          : crc_MODBUS will return 0x4B37.
004985  005380        
004986  005381        
004987  005382  func crc_CCITT("buf","count","seed"), 1;            // given a pointer to a buffer, byte count and seed, calculate the 16bit CRC for seed
004988  005383  // *Notes   : (if you calculate all of the incoming data
004989  005384  //          : INCLUDING the CRC, the result should be 0x0000
004990  005385  //          : For the standard test string "123456789",
004991  005386  //          : crc_CCITT will return the following:-
004992  005387  //          : seed = 0 (XMODEM protocol) result = 0x31C3
004993  005388  //          : seed = 0xFFFF, result = 0x29B1
004994  005389  //          : seed = 0x1D0F, result = 0xE5CC
004995  005390        
004996  005391  func __reserved87(), 0; // do not remove
004997  005392  func __reserved88(), 0; // do not remove
004998  005393  func __reserved89(), 0; // do not remove
004999  005394        
005000  005395  //----------------------------------------------------------------------------//
005001  005396  //  functions to support buffered transmission and reception of break signal  //
005002  005397  //----------------------------------------------------------------------------//
005003  005398        
005004  005399  func com_TXbufferBrk("buf", "bufsize", "pin"), 0;    // sets the buffer location for buffered transmission
005005  005400  // Usage : com_TXbufferBrk(mybuf, 1024, PA0);    // set the TX buffer, using PA0 for turnaround
005006  005401  // Usage : com_TXbufferBrk(0, 0, 0);             // revert to non buffered service
005007  005402  // Notes : initialize a serial buffer for the COM0 output.
005008  005403  //       : The program must declare a var array as a circular buffer.
005009  005404  //       : When a TX buffer is declared for comms, the transmission
005010  005405  //       : of characters becomes non blocking. If the buffer has
005011  005406  //       : insufficient space to accept the next character from a
005012  005407  //       : serout_x() function, the excess characters will be ignored,
005013  005408  //       : and the com_Full_x() error will be asserted.   If the
005014  005409  //       : TX buffer is no longer required, just set the buffer pointer
005015  005410  //       : to zero, the size in this case doesnt matter and is ignored.
005016  005411  //       : The function can resize or reallocated to another buffer at
005017  005412  //       : any time. The buffer is flushed before any changes are made.
005018  005413  //       : "pin" designates an IO pin to control a bi-directional
005019  005414  //       : control device for half duplex mode. "pin" will go HI at the
005020  005415  //       : start of a transmission, and will return low after the final
005021  005416  //       : byte is transmitted. If not required, just set "pin" to zero.
005022  005417        
005023  005418  func com1_TXbufferBrk("buf", "bufsize", "pin"), 0;
005024  005419  // Usage : com1_TXbufferBrk(mybuf, 1024, PA0);    // set the TX buffer, using PA0 for turnaround
005025  005420  // Usage : com1_TXbufferBrk(0, 0, 0);              // revert to non buffered service
005026  005421  // Notes : initialize a serial buffer for the COM0 output.
005027  005422  //       : The program must declare a var array as a circular buffer.
005028  005423  //       : When a TX buffer is declared for comms, the transmission
005029  005424  //       : of characters becomes non blocking. If the buffer has
005030  005425  //       : insufficient space to accept the next character from a
005031  005426  //       : serout_x() function, the excess characters will be ignored,
005032  005427  //       : and the com_Full_x() error will be asserted.   If the
005033  005428  //       : TX buffer is no longer required, just set the buffer pointer
005034  005429  //       : to zero, the size in this case doesnt matter and is ignored.
005035  005430  //       : The function can resize or reallocated to another buffer at
005036  005431  //       : any time. The buffer is flushed before any changes are made.
005037  005432  //       : "pin" designates an IO pin to control a bi-directional
005038  005433  //       : control device for half duplex mode. "pin" will go HI at the
005039  005434  //       : start of a transmission, and will return low after the final
005040  005435  //       : byte is transmitted. If not required, just set "pin" to zero.
005041  005436        
005042  005437  func com2_TXbufferBrk("buf", "bufsize", "pin"), 0;
005043  005438  // Usage : com2_TXbufferBrk(mybuf, 1024, PA0);    // set the TX buffer, using PA0 for turnaround
005044  005439  // Usage : com2_TXbufferBrk(0, 0, 0);              // revert to non buffered service
005045  005440  // Notes : initialize a serial buffer for the COM0 output.
005046  005441  //       : The program must declare a var array as a circular buffer.
005047  005442  //       : When a TX buffer is declared for comms, the transmission
005048  005443  //       : of characters becomes non blocking. If the buffer has
005049  005444  //       : insufficient space to accept the next character from a
005050  005445  //       : serout_x() function, the excess characters will be ignored,
005051  005446  //       : and the com_Full_x() error will be asserted.   If the
005052  005447  //       : TX buffer is no longer required, just set the buffer pointer
005053  005448  //       : to zero, the size in this case doesnt matter and is ignored.
005054  005449  //       : The function can resize or reallocated to another buffer at
005055  005450  //       : any time. The buffer is flushed before any changes are made.
005056  005451  //       : "pin" designates an IO pin to control a bi-directional
005057  005452  //       : control device for half duplex mode. "pin" will go HI at the
005058  005453  //       : start of a transmission, and will return low after the final
005059  005454  //       : byte is transmitted. If not required, just set "pin" to zero.
005060  005455        
005061  005456  func com3_TXbufferBrk("buf", "bufsize", "pin"), 0;
005062  005457  // Usage : com3_TXbufferBrk(mybuf, 1024, PA0);    // set the TX buffer, using PA0 for turnaround
005063  005458  // Usage : com3_TXbufferBrk(0, 0, 0);              // revert to non buffered service
005064  005459  // Notes : initialize a serial buffer for the COM0 output.
005065  005460  //       : The program must declare a var array as a circular buffer.
005066  005461  //       : When a TX buffer is declared for comms, the transmission
005067  005462  //       : of characters becomes non blocking. If the buffer has
005068  005463  //       : insufficient space to accept the next character from a
005069  005464  //       : serout_x() function, the excess characters will be ignored,
005070  005465  //       : and the com_Full_x() error will be asserted.   If the
005071  005466  //       : TX buffer is no longer required, just set the buffer pointer
005072  005467  //       : to zero, the size in this case doesnt matter and is ignored.
005073  005468  //       : The function can resize or reallocated to another buffer at
005074  005469  //       : any time. The buffer is flushed before any changes are made.
005075  005470  //       : "pin" designates an IO pin to control a bi-directional
005076  005471  //       : control device for half duplex mode. "pin" will go HI at the
005077  005472  //       : start of a transmission, and will return low after the final
005078  005473  //       : byte is transmitted. If not required, just set "pin" to zero.
005079  005474        
005080  005475  func com_InitBrk("buf","bufsize","qualifier"), 0;  // set up a interrupt driven ring buffer for comms
005081  005476  // Syntax: com_InitBrk(buffer, bufsize, qualifier);
005082  005477  // Usage1: com_InitBrk(mybuf, 20, 0);
005083  005478  // Usage2: com_InitBrk(mybuf, 20, ':');
005084  005479  // Notes : initialize a serial capture buffer for the comms input
005085  005480  //       : The program must declare a var array as a circular buffer.
005086  005481  //       : Usage1 declares a circular buffer which will continually
005087  005482  //       : buffer characters.
005088  005483  //       : Usage2 must receive ':' before any characters will
005089  005484  //       : accumulate in the buffer.
005090  005485        
005091  005486  func com1_InitBrk("buf","bufsize","qualifier"), 0;
005092  005487  // Syntax: com1_InitBrk(buffer, bufsize, qualifier);
005093  005488  // Usage1: com1_InitBrk(mybuf, 20, 0);
005094  005489  // Usage2: com1_InitBrk(mybuf, 20, ':');
005095  005490  // Notes : initialize a serial capture buffer for the comms input
005096  005491  //       : The program must declare a var array as a circular buffer.
005097  005492  //       : Usage1 declares a circular buffer which will continually
005098  005493  //       : buffer characters.
005099  005494  //       : Usage2 must receive ':' before any characters will
005100  005495  //       : accumulate in the buffer.
005101  005496        
005102  005497  func com2_InitBrk("buf","bufsize","qualifier"), 0;
005103  005498  // Syntax: com2_InitBrk(buffer, bufsize, qualifier);
005104  005499  // Usage1: com2_InitBrk(mybuf, 20, 0);
005105  005500  // Usage2: com2_InitBrk(mybuf, 20, ':');
005106  005501  // Notes : initialize a serial capture buffer for the comms input
005107  005502  //       : The program must declare a var array as a circular buffer.
005108  005503  //       : Usage1 declares a circular buffer which will continually
005109  005504  //       : buffer characters.
005110  005505  //       : Usage2 must receive ':' before any characters will
005111  005506  //       : accumulate in the buffer.
005112  005507        
005113  005508  func com3_InitBrk("buf","bufsize","qualifier"), 0;
005114  005509  // Syntax: com3_InitBrk(buffer, bufsize, qualifier);
005115  005510  // Usage1: com3_InitBrk(mybuf, 20, 0);
005116  005511  // Usage2: com3_Init(mybuf, 20, ':');
005117  005512  // Notes : initialize a serial capture buffer for the comms input
005118  005513  //       : The program must declare a var array as a circular buffer.
005119  005514  //       : Usage1 declares a circular buffer which will continually
005120  005515  //       : buffer characters.
005121  005516  //       : Usage2 must receive ':' before any characters will
005122  005517  //       : accumulate in the buffer.
005123  005518        
005124  005519  //------------------------------------------------------------------//
005125  005520  //     break control constant                                       //
005126  005521  //------------------------------------------------------------------//
005127  005522  #constant BREAK      0xFFFD    // interpretation of the break signal
005128  005522  #constant BREAK      0xFFFD    // interpretation of the break signal
005129  005523        
005130  005524  //------------------------------------------------------------------//
005131  005525  // CONSTANTS
005132  005526  //------------------------------------------------------------------//
005133  005527        
005134  005528  #CONST
005135  005532  #END
005136  005533        
005137  005534  // timebase constants for timebase_init
005138  005535  // NB only TB2 and TB4 can be used for synchronous A2D sampling.
005139  005536  #CONST
005140  005547  #END
005141  005548        
005142  005549        
005143  005550  // generic constants
005144  005551  #CONST
005145  005559  #END
005146  005560        
005147  005561        
005148  005562        
005149  005563  //gfx_Get() related constants
005150  005564  #CONST
005151  005573  #END
005152  005574        
005153  005575        
005154  005576        
005155  005577        
005156  005578  #CONST
005157  005591  #END
005158  005592        
005159  005593        
005160  005594  #CONST
005161  005619  #END
005162  005620        
005163  005621        
005164  005622        
005165  005623        
005166  005624  // timer control  related constants
005167  005625  #CONST
005168  005634  #END
005169  005635        
005170  005636        
005171  005637        
005172  005638  //------------------------------------------------------------------------------
005173  005639  // system WORD variables accesible with peekW and pokeW or pointer access
005174  005640  // Note that the txt_Set variables (0-15) and gfx_set variables (16-31)
005175  005641  // can also be accessed with peekW and pokeW
005176  005642  //------------------------------------------------------------------------------
005177  005643        
005178  005644  #CONST
005179  005739  #END
005180  005740        
005181  005741  #CONST
005182  005906  #END
005183  005907        
005184  005908        
005185  005909        
005186  005910  //==================================================================================================
005187  005911        
005188  005912        
005189  005913        
005190  000013      #ENDIF
005191  000014        
005192  000015        
005193  000016  //===========================================================================================
005194  000017        
005195  000018        
file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\4DGL_16bitColours.fnc

005196  000006  #inherit "4DGL_16bitColours.fnc"
005197  000006  #inherit "4DGL_16bitColours.fnc"
005198  000004  */
005199  000005        
005200  000006        
005201  000007        
005202  000008  #CONST
005203  000149  #END
005204  000150        
file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\VisualConst.inc

005205  000007  #inherit "VisualConst.inc"
005206  000007  #inherit "VisualConst.inc"
005207  000001  // Line Patterns
005208  000002  #constant  LPCOARSE    0xF0F0
005209  000002  #constant  LPCOARSE    0xF0F0
005210  000003  #constant  LPMEDIUM    0x3333
005211  000003  #constant  LPMEDIUM    0x3333
005212  000004  #constant  LPFINE      0xAAAA
005213  000004  #constant  LPFINE      0xAAAA
005214  000005  #constant  LPDASHDOT   0x03CF
005215  000005  #constant  LPDASHDOT   0x03CF
005216  000006  #constant  LPDASHDOTDOT 0x0333
005217  000006  #constant  LPDASHDOTDOT 0x0333
005218  000007  #constant  LPSOLID     0x0000
005219  000007  #constant  LPSOLID     0x0000
file C:\Users\ebenton\Documents\CERDEC TS\CERDEC.4DWork\CERDECConst.inc

005220  000008  #inherit "CERDECConst.inc"
005221  000008  #inherit "CERDECConst.inc"
005222  000001  // File generated 11/14/2019 12:09:50 PM
005223  000002  // Warning! This is a generated file, any manual changes will be
005224  000003  // lost during the next generation.
005225  000004        
005226  000005  // object indexes into ImageControl
005227  000006  #CONST
005228  000108  #END
005229  000109        
005230  000110  #IFNOT EXISTS NOGLOBALS
005231  000111  var hndl ;
005232  000112  #ENDIF
005233  000009        
005234  000010  // ##################
005235  000011  // Constants
005236  000012  // ##################
005237  000013        
005238  000014  // Generic
005239  000015  #constant BTN_UP        0
005240  000015  #constant BTN_UP        0
005241  000016  #constant BTN_DOWN      1
005242  000016  #constant BTN_DOWN      1
005243  000017  #constant ACTIVE        1
005244  000017  #constant ACTIVE        1
005245  000018  #constant INACTIVE      0
005246  000018  #constant INACTIVE      0
005247  000019  #constant TRUE          1
005248  000019  #constant TRUE          1
005249  000020  #constant FALSE         0
005250  000020  #constant FALSE         0
005251  000021  #constant OFFLINE       1
005252  000021  #constant OFFLINE       1
005253  000022  #constant ONLINE        0
005254  000022  #constant ONLINE        0
005255  000023  #constant START_BYT     0x18
005256  000023  #constant START_BYT     0x18
005257  000024        
005258  000025  // Colors
005259  000026  #constant BACKGROUND_COLOR  0xDF5F
005260  000026  #constant BACKGROUND_COLOR  0xDF5F
005261  000027  #constant LED_GOOD          LIMEGREEN
005262  000027  #constant LED_GOOD          LIMEGREEN
005263  000028  #constant LED_IDLE          0x34DF
005264  000028  #constant LED_IDLE          0x34DF
005265  000029  #constant LED_BAD           RED
005266  000029  #constant LED_BAD           RED
005267  000030  #constant RB_CHKD           BLACK
005268  000030  #constant RB_CHKD           BLACK
005269  000031  #constant RB_UNCHKD         0xD699
005270  000031  #constant RB_UNCHKD         0xD699
005271  000032        
005272  000033  // Forms
005273  000034  #constant OVERVIEW_FORM 0
005274  000034  #constant OVERVIEW_FORM 0
005275  000035  #constant SHELF_FORM 1
005276  000035  #constant SHELF_FORM 1
005277  000036  #constant MOD_FORM 2
005278  000036  #constant MOD_FORM 2
005279  000037        
005280  000038  // Indices
005281  000039  #constant TYPE  2
005282  000039  #constant TYPE  2
005283  000040  #constant ID    3
005284  000040  #constant ID    3
005285  000041  #constant MOD_V 4
005286  000041  #constant MOD_V 4
005287  000042  #constant MOD_T 6
005288  000042  #constant MOD_T 6
005289  000043  #constant MOD_A 7
005290  000043  #constant MOD_A 7
005291  000044        
005292  000045  // TODO: Add indices to indexers
005293  000046  #constant SHELF_V
005294  000046  #constant SHELF_V
005295  000047  #constant SHELF_T
005296  000047  #constant SHELF_T
005297  000048  #constant SHELF_H
005298  000048  #constant SHELF_H
005299  000049  #constant SHELF_L
005300  000049  #constant SHELF_L
005301  000050  #constant SHELF_ID
005302  000050  #constant SHELF_ID
005303  000051  #constant SHELF_A
005304  000051  #constant SHELF_A
005305  000052  #constant SHELF_E
005306  000052  #constant SHELF_E
005307  000053        
005308  000054  // ##################
005309  000055  // Structures
005310  000056  // ##################
005311  000057        
005312  000058  // System has 12 major characteristics
005313  000059  // 1) System Status, Int: 1 Byte
005314  000060  // 2) System Mode, Int: 1 Byte
005315  000061  // 3) Relay Status, Int: 1 Byte
005316  000062  // 4) # of Discharges, Int: 1 Byte
005317  000063  // 5) Stored Energy, Float: 2 Bytes
005318  000064  // 6) Time at Max, Float: 2 Bytes
005319  000065  // 7) Estimated Runtime, Float: 2 Bytes
005320  000066  // 8) Bus Voltage, Float: 2 Bytes
005321  000067  // 9) Output Current, Float: 2 Bytes
005322  000068  // 10) Capacitors' Voltage, Float: 2 Bytes
005323  000069  var system[16];
005324  000070        
005325  000071  // Shelves have 9 major characteristics
005326  000072  // 1) Total Voltage, Float: 2 Bytes
005327  000073  // 2) Avg. Temp, Int: 1 Byte
005328  000074  // 3) Highest Temp, Float: 1 Byte
005329  000075  // 4) Lowest Temp, Float: 1 Bytes
005330  000076  // 5) ID Highest/Lowest Temp, Int: 1 Byte
005331  000077  // 6) Alarm/Error, Int : 1 Byte
005332  000078  // 7) Error ID, Int: 1 Byte
005333  000079  // 8) X Position,  Int: 1 Byte
005334  000080  // 9) Y Position,  Int: 1 Byte
005335  000081  // 10) Good Button handle, Ptr: 1 Byte
005336  000082  // 11) Bad Button handle, Ptr: 1 Byte
005337  000083  var shelf0[13];
005338  000084  var *shelf_ptr;
005339  000085  var shelf_volt[2];
005340  000086  var shelf_temp[2];
005341  000087        
005342  000088  // Modules have 7 major characteristics
005343  000089  // 1) Voltage, Float: 2 Bytes
005344  000090  // 2) Temperature, Int: 1 Byte
005345  000091  // 3) Alarm/Error, Int: 1 Byte
005346  000092  // 4) X Position,  Int: 1 Byte
005347  000093  // 5) Y Position,  Int: 1 Byte
005348  000094  // 6) Good Button handle, Ptr: 1 Byte
005349  000095  // 7) Bad Button handle, Ptr: 1 Byte
005350  000096  var mod0[8];
005351  000097  var mod1[8];
005352  000098  var mod2[8];
005353  000099  var mod3[8];
005354  000100  var mod4[8];
005355  000101  var mod5[8];
005356  000102  var mod6[8];
005357  000103  var mod7[8];
005358  000104  var mod8[8];
005359  000105  var mods[9] := [mod0, mod1, mod2, mod3, mod4, mod5, mod6, mod7, mod8];
5360  0018
5361  0019
5362  001A
5363  001B
5364  001C
5365  001D
5366  001E
5367  001F
5368  0020
5369  0021
5370  0022
5371  0023
5372  0024
5373  0025
5374  0026
5375  0027
5376  0028
5377  0029
005378  000106  var current_mod := 0;
005379  000107  var *mod_ptr_1;
005380  000108  var *mod_ptr_2;
005381  000109  var mod_volt[2];
005382  000110  var mod_temp[2];
005383  000111        
005384  000112  // ##################
005385  000113  // Variables
005386  000114  // ##################
005387  000115        
005388  000116  // Initialize to the overview screen
005389  000117  var current_form := OVERVIEW_FORM;
005390  000118        
005391  000119  // ##################
005392  000120  // Main
005393  000121  // ##################
005394  000122        
005395  000123  func main()
005396  000124        
005397  000125    // Mount the drive
005398  000126    putstr("Mounting...\n");
005399  000127    if (!(file_Mount()))
005400  000128      while(!(file_Mount()))
005401  000129        putstr("Drive not mounted...");
005402  000130        pause(200);
005403  000131        gfx_Cls();
005404  000132        pause(200);
005405  000133      wend
005406  000134    endif
005407  000135        
005408  000136    // Get file handle
005409  000137    hndl := file_LoadImageControl("CERDEC.dat", "CERDEC.gci", 1);
005410  000138        
005411  000139    // Basic initialization stuff
005412  000140    gfx_Set(SCREEN_MODE, LANDSCAPE);
005413  000141    touch_Set(TOUCH_ENABLE);
005414  000142        
005415  000143    // Draw the logo screen then the overall screen
005416  000144    draw_logo_screen();
005417  000145    pause(1500);
005418  000146    draw_overall_form();
005419  000147        
005420  000148    // Enter the forever loop
005421  000149    repeat
005422  000150        
005423  000151      // Send Commands
005424  000152      if(current_form == SHELF_FORM || current_form == MOD_FORM)
005425  000153        
005426  000154        var current_shelf := 0;
005427  000155        //request_all_shelf_mods(current_shelf);
005428  000156        
005429  000157      endif
005430  000158      // Read Commands
005431  000159      // process_input();
005432  000160        
005433  000161      // Update the view
005434  000162        
005435  000163      // Check for user input
005436  000164      check_press();
005437  000165        
005438  000166      // React to user input
005439  000167        
005440  000168    forever
005441  000169        
005442  000170  endfunc
005443  000171        
005444  000172  // ##################
005445  000173  // DRAWING
005446  000174  // ##################
005447  000175        
005448  000176  // === Logo Screen ===
005449  000177        
005450  000178  func draw_logo_screen()
005451  000179        
005452  000180    gfx_BGcolour(WHITE);
005453  000181    gfx_Cls();
005454  000182        
005455  000183  endfunc
005456  000184        
005457  000185  // === Overall Form ===
005458  000186        
005459  000187  func draw_overall_form()
005460  000188        
005461  000189    // Overall System Form
005462  000190    gfx_BGcolour(0x8D9C) ;
005463  000191    gfx_Cls() ;
005464  000192        
005465  000193    // Draw the Title
005466  000194    img_Show(hndl,iCERDEC_Title);
005467  000195        
005468  000196    // Draw the System Status
005469  000197    draw_system_status();
005470  000198        
005471  000199    // Draw the System Mode
005472  000200    draw_system_mode();
005473  000201        
005474  000202    // Draw the Relay Status
005475  000203    draw_relay_status();
005476  000204        
005477  000205    // Draw the Number of Discharges
005478  000206    draw_num_discharges();
005479  000207        
005480  000208    // Draw Stored Energy
005481  000209    draw_stored_energy();
005482  000210        
005483  000211    // Draw Time at Max
005484  000212    draw_time_at_max();
005485  000213        
005486  000214    // Draw Estimated Runtime
005487  000215    draw_estimated_runtime();
005488  000216        
005489  000217    // Draw Bus Voltage
005490  000218    draw_bus_voltage();
005491  000219        
005492  000220    // Draw Output Current
005493  000221    draw_output_current();
005494  000222        
005495  000223    // Draw Capacitors' Voltage
005496  000224    draw_capacitors_voltage();
005497  000225        
005498  000226    // Draw the buttons on the far right side
005499  000227    draw_overall_side_buttons();
005500  000228        
005501  000229    // Draw the Modules
005502  000230    draw_overall_mods();
005503  000231        
005504  000232  endfunc
005505  000233        
005506  000234  func draw_system_status()
005507  000235        
005508  000236    // System Status Field
005509  000237    gfx_Panel(PANEL_RAISED, 12, 129, 65, 30, WHITE);
005510  000238        
005511  000239    // Reset System Status Button
005512  000240    img_ClearAttributes(hndl, iResetSystemStatus_btn, I_TOUCH_DISABLE);
005513  000241    img_SetWord(hndl, iResetSystemStatus_btn, IMAGE_INDEX, BTN_UP);
005514  000242    img_Show(hndl,iResetSystemStatus_btn);
005515  000243        
005516  000244    // System Status Title
005517  000245    img_Show(hndl,iSystemStatus_Title);
005518  000246        
005519  000247  endfunc
005520  000248        
005521  000249  func draw_system_mode()
005522  000250        
005523  000251    // Background panel
005524  000252    gfx_Panel(PANEL_SUNKEN, 8, 188, 176, 84, 0x8D9C) ;
005525  000253        
005526  000254    // Draw the title + labels
005527  000255    draw_system_mode_labels();
005528  000256        
005529  000257    // Draw the Radio Buttons
005530  000258    draw_system_mode_radios();
005531  000259        
005532  000260  endfunc
005533  000261        
005534  000262  func draw_relay_status()
005535  000263        
005536  000264    // Relay State Label
005537  000265    img_Show(hndl,iRelayState_Label);
005538  000266        
005539  000267    // Draw the Relay Status LED
005540  000268    draw_relay_status_led();
005541  000269        
005542  000270  endfunc
005543  000271        
005544  000272  func draw_num_discharges()
005545  000273        
005546  000274    // Draw the Number Discharges Field
005547  000275    gfx_Panel(PANEL_RAISED, 12, 360, 65, 30, WHITE);
005548  000276        
005549  000277    // Reset Discharges Button
005550  000278    img_ClearAttributes(hndl, iResetDischarges_btn, I_TOUCH_DISABLE);
005551  000279    img_SetWord(hndl, iResetDischarges_btn, IMAGE_INDEX, BTN_UP);
005552  000280    img_Show(hndl,iResetDischarges_btn);
005553  000281        
005554  000282    // Draw the Number Discharges Title
005555  000283    img_Show(hndl,iNumberDischarges_Label);
005556  000284        
005557  000285  endfunc
005558  000286        
005559  000287  func draw_stored_energy()
005560  000288        
005561  000289    // Stored Energy Field
005562  000290    gfx_Panel(PANEL_RAISED, 516, 96, 108, 35, WHITE);
005563  000291        
005564  000292    // Stored Energy Label
005565  000293    img_Show(hndl,iStoredEnergy_Label);
005566  000294        
005567  000295  endfunc
005568  000296        
005569  000297  func draw_time_at_max()
005570  000298        
005571  000299    // Time @ Max Field
005572  000300    gfx_Panel(PANEL_RAISED, 516, 181, 108, 35, WHITE);
005573  000301        
005574  000302    // Time @ Max Label
005575  000303    img_Show(hndl,iMaxTime_Label);
005576  000304        
005577  000305  endfunc
005578  000306        
005579  000307  func draw_estimated_runtime()
005580  000308        
005581  000309    // Estimated Runtime Field
005582  000310    gfx_Panel(PANEL_RAISED, 516, 222, 108, 35, WHITE);
005583  000311        
005584  000312    // Estimated Runtime Label
005585  000313    img_Show(hndl,iEstimatedRuntime_Label);
005586  000314        
005587  000315  endfunc
005588  000316        
005589  000317  func draw_bus_voltage()
005590  000318        
005591  000319    // Bus Voltage Field
005592  000320    gfx_Panel(PANEL_RAISED, 516, 275, 108, 35, WHITE);
005593  000321        
005594  000322    // Bus Voltage Label
005595  000323    img_Show(hndl,iBusVoltage_btn);
005596  000324        
005597  000325  endfunc
005598  000326        
005599  000327  func draw_output_current()
005600  000328        
005601  000329    // Output Current Field
005602  000330    gfx_Panel(PANEL_RAISED, 516, 316, 108, 35, WHITE);
005603  000331        
005604  000332    // Output Current Label
005605  000333    img_Show(hndl,iOutputCurrent_Label);
005606  000334        
005607  000335  endfunc
005608  000336        
005609  000337  func draw_capacitors_voltage()
005610  000338        
005611  000339    // Capacitors' Voltage Field
005612  000340    gfx_Panel(PANEL_RAISED, 516, 357, 108, 35, WHITE);
005613  000341        
005614  000342    // Capacitors' Voltage Label
005615  000343    img_Show(hndl,iCapacitorVoltage_Label);
005616  000344        
005617  000345  endfunc
005618  000346        
005619  000347  func draw_relay_status_led()
005620  000348        
005621  000349    var relay_index;
005622  000350    relay_index := 2;
005623  000351        
005624  000352    // Draw the background LED first
005625  000353    gfx_CircleFilled(111, 298, 18, 0x6B6D);
005626  000354        
005627  000355    // Draw the Relay Status LED
005628  000356    if(system[relay_index] == ACTIVE)
005629  000357      gfx_CircleFilled(111, 298, 17, LED_GOOD);
005630  000358    else
005631  000359      gfx_CircleFilled(111, 298, 17, LED_BAD);
005632  000360    endif
005633  000361        
005634  000362  endfunc
005635  000363        
005636  000364  func draw_system_mode_radios()
005637  000365        
005638  000366    var mode_index, off, idle, voltage, power;
005639  000367    mode_index := 1;
005640  000368    off := 0;
005641  000369    idle := 1;
005642  000370    voltage := 2;
005643  000371    power := 3;
005644  000372        
005645  000373    // System Off Radio Button
005646  000374    if(system[mode_index] == off)
005647  000375      gfx_CircleFilled(25, 215, 10, RB_CHKD);
005648  000376    else
005649  000377      gfx_CircleFilled(25, 215, 10, RB_UNCHKD);
005650  000378    endif
005651  000379        
005652  000380    // System Idle Radio Button
005653  000381    if(system[mode_index] == idle)
005654  000382      gfx_CircleFilled(25, 250, 10, RB_CHKD);
005655  000383    else
005656  000384      gfx_CircleFilled(25, 250, 10, RB_UNCHKD);
005657  000385    endif
005658  000386        
005659  000387    // System Power Radio Button
005660  000388    if(system[mode_index] == power)
005661  000389      gfx_CircleFilled(100, 250, 10, RB_CHKD);
005662  000390    else
005663  000391      gfx_CircleFilled(100, 250, 10, RB_UNCHKD);
005664  000392    endif
005665  000393        
005666  000394    // System Voltage Radio Button
005667  000395    if(system[mode_index] == voltage)
005668  000396      gfx_CircleFilled(100, 215, 10, RB_CHKD);
005669  000397    else
005670  000398      gfx_CircleFilled(100, 215, 10, RB_UNCHKD);
005671  000399    endif
005672  000400        
005673  000401  endfunc
005674  000402        
005675  000403  func draw_system_mode_labels()
005676  000404        
005677  000405    // System Mode Title
005678  000406    img_Show(hndl,iSystemMode_Title);
005679  000407        
005680  000408    // System Mode Off Label
005681  000409    img_Show(hndl,iSystemOff_Label);
005682  000410        
005683  000411    // System Mode Idle Label
005684  000412    img_Show(hndl,iSystemIdle_Label);
005685  000413        
005686  000414    // System Mode Voltage Label
005687  000415    img_Show(hndl,iSystemVoltage_Label);
005688  000416        
005689  000417    // System Mode Power Label
005690  000418    img_Show(hndl,iSystemPower_Label);
005691  000419        
005692  000420  endfunc
005693  000421        
005694  000422  func draw_overall_side_buttons()
005695  000423        
005696  000424      // SystemStart_btn
005697  000425      img_ClearAttributes(hndl, iSystemStart_btn, I_TOUCH_DISABLE);
005698  000426      img_SetWord(hndl, iSystemStart_btn, IMAGE_INDEX, BTN_UP);
005699  000427      img_Show(hndl,iSystemStart_btn);
005700  000428        
005701  000429      // SystemStop_btn
005702  000430      img_ClearAttributes(hndl, iSystemStop_btn, I_TOUCH_DISABLE);
005703  000431      img_SetWord(hndl, iSystemStop_btn, IMAGE_INDEX, BTN_UP);
005704  000432      img_Show(hndl,iSystemStop_btn);
005705  000433        
005706  000434      // Shelf_btn
005707  000435      img_ClearAttributes(hndl, iShelf_btn, I_TOUCH_DISABLE);
005708  000436      img_SetWord(hndl, iShelf_btn, IMAGE_INDEX, BTN_UP);
005709  000437      img_Show(hndl,iShelf_btn);
005710  000438        
005711  000439      // EmergencyStop_btn
005712  000440      img_ClearAttributes(hndl, iEmergencyStop_btn, I_TOUCH_DISABLE);
005713  000441      img_SetWord(hndl, iEmergencyStop_btn, IMAGE_INDEX, BTN_UP);
005714  000442      img_Show(hndl,iEmergencyStop_btn);
005715  000443        
005716  000444      // Draw all the module buttons
005717  000445      draw_overall_mods();
005718  000446        
005719  000447  endfunc
005720  000448        
005721  000449  func draw_overall_mods()
005722  000450        
005723  000451    var alarm_index := 2;
005724  000452        
005725  000453    // Main Module 0 Button
005726  000454    if(any_mod_errors(mod0))
005727  000455      // MainModule1Good_btn
005728  000456      img_ClearAttributes(hndl, iMainModule1Good_btn, I_TOUCH_DISABLE);
005729  000457      img_SetWord(hndl, iMainModule1Good_btn, IMAGE_INDEX, BTN_UP);
005730  000458      img_Show(hndl,iMainModule1Good_btn);
005731  000459      img_SetAttributes(hndl, iMainModule1Bad_btn, I_TOUCH_DISABLE);
005732  000460    else
005733  000461      // MainModule1Bad_btn
005734  000462      img_ClearAttributes(hndl, iMainModule1Bad_btn, I_TOUCH_DISABLE);
005735  000463      img_SetWord(hndl, iMainModule1Bad_btn, IMAGE_INDEX, BTN_UP);
005736  000464      img_Show(hndl,iMainModule1Bad_btn);
005737  000465      img_SetAttributes(hndl, iMainModule1Good_btn, I_TOUCH_DISABLE);
005738  000466    endif
005739  000467        
005740  000468    // Main Module 1 Button
005741  000469    if(any_mod_errors(mod1))
005742  000470      // MainModule2Good_btn
005743  000471      img_ClearAttributes(hndl, iMainModule2Good_btn, I_TOUCH_DISABLE);
005744  000472      img_SetWord(hndl, iMainModule2Good_btn, IMAGE_INDEX, BTN_UP);
005745  000473      img_Show(hndl,iMainModule2Good_btn);
005746  000474      img_SetAttributes(hndl, iMainModule2Bad_btn, I_TOUCH_DISABLE);
005747  000475    else
005748  000476      // MainModule2Bad_btn
005749  000477      img_ClearAttributes(hndl, iMainModule2Bad_btn, I_TOUCH_DISABLE);
005750  000478      img_SetWord(hndl, iMainModule2Bad_btn, IMAGE_INDEX, BTN_UP);
005751  000479      img_Show(hndl,iMainModule2Bad_btn);
005752  000480      img_SetAttributes(hndl, iMainModule2Good_btn, I_TOUCH_DISABLE);
005753  000481    endif
005754  000482        
005755  000483    // Main Module 2 Button
005756  000484    if(any_mod_errors(mod2))
005757  000485      // MainModule3Good_btn
005758  000486      img_ClearAttributes(hndl, iMainModule3Good_btn, I_TOUCH_DISABLE);
005759  000487      img_SetWord(hndl, iMainModule3Good_btn, IMAGE_INDEX, BTN_UP);
005760  000488      img_Show(hndl,iMainModule3Good_btn);
005761  000489      img_SetAttributes(hndl, iMainModule3Bad_btn, I_TOUCH_DISABLE);
005762  000490    else
005763  000491      // MainModule3Bad_btn
005764  000492      img_ClearAttributes(hndl, iMainModule3Bad_btn, I_TOUCH_DISABLE);
005765  000493      img_SetWord(hndl, iMainModule3Bad_btn, IMAGE_INDEX, BTN_UP);
005766  000494      img_Show(hndl,iMainModule3Bad_btn);
005767  000495      img_SetAttributes(hndl, iMainModule3Good_btn, I_TOUCH_DISABLE);
005768  000496    endif
005769  000497        
005770  000498    // Main Module 3 Button
005771  000499    if(any_mod_errors(mod3))
005772  000500      // MainModule4Good_btn
005773  000501      img_ClearAttributes(hndl, iMainModule4Good_btn, I_TOUCH_DISABLE);
005774  000502      img_SetWord(hndl, iMainModule4Good_btn, IMAGE_INDEX, BTN_UP);
005775  000503      img_Show(hndl,iMainModule4Good_btn);
005776  000504      img_SetAttributes(hndl, iMainModule4Bad_btn, I_TOUCH_DISABLE);
005777  000505    else
005778  000506      // MainModule4Good_btn
005779  000507      img_ClearAttributes(hndl, iMainModule4Bad_btn, I_TOUCH_DISABLE);
005780  000508      img_SetWord(hndl, iMainModule4Bad_btn, IMAGE_INDEX, BTN_UP);
005781  000509      img_Show(hndl,iMainModule4Bad_btn);
005782  000510      img_SetAttributes(hndl, iMainModule4Good_btn, I_TOUCH_DISABLE);
005783  000511    endif
005784  000512        
005785  000513    // Main Module 4 Button
005786  000514    if(any_mod_errors(mod4))
005787  000515      // MainModule5Good_btn
005788  000516      img_ClearAttributes(hndl, iMainModule5Good_btn, I_TOUCH_DISABLE);
005789  000517      img_SetWord(hndl, iMainModule5Good_btn, IMAGE_INDEX, BTN_UP);
005790  000518      img_Show(hndl,iMainModule5Good_btn);
005791  000519      img_SetAttributes(hndl, iMainModule5Bad_btn, I_TOUCH_DISABLE);
005792  000520    else
005793  000521      // MainModule5Good_btn
005794  000522      img_ClearAttributes(hndl, iMainModule5Bad_btn, I_TOUCH_DISABLE);
005795  000523      img_SetWord(hndl, iMainModule5Bad_btn, IMAGE_INDEX, BTN_UP);
005796  000524      img_Show(hndl,iMainModule5Bad_btn);
005797  000525      img_SetAttributes(hndl, iMainModule5Good_btn, I_TOUCH_DISABLE);
005798  000526    endif
005799  000527        
005800  000528    // Main Module 5 Button
005801  000529    if(any_mod_errors(mod5))
005802  000530      // MainModule6Good_btn
005803  000531      img_ClearAttributes(hndl, iMainModule6Good_btn, I_TOUCH_DISABLE);
005804  000532      img_SetWord(hndl, iMainModule6Good_btn, IMAGE_INDEX, BTN_UP);
005805  000533      img_Show(hndl,iMainModule6Good_btn);
005806  000534      img_SetAttributes(hndl, iMainModule6Bad_btn, I_TOUCH_DISABLE);
005807  000535    else
005808  000536      // MainModule6Good_btn
005809  000537      img_ClearAttributes(hndl, iMainModule6Bad_btn, I_TOUCH_DISABLE);
005810  000538      img_SetWord(hndl, iMainModule6Bad_btn, IMAGE_INDEX, BTN_UP);
005811  000539      img_Show(hndl,iMainModule6Bad_btn);
005812  000540      img_SetAttributes(hndl, iMainModule6Good_btn, I_TOUCH_DISABLE);
005813  000541    endif
005814  000542        
005815  000543    // Main Module 6 Button
005816  000544    if(any_mod_errors(mod6))
005817  000545      // MainModule7Good_btn
005818  000546      img_ClearAttributes(hndl, iMainModule7Good_btn, I_TOUCH_DISABLE);
005819  000547      img_SetWord(hndl, iMainModule7Good_btn, IMAGE_INDEX, BTN_UP);
005820  000548      img_Show(hndl,iMainModule7Good_btn);
005821  000549      img_SetAttributes(hndl, iMainModule7Bad_btn, I_TOUCH_DISABLE);
005822  000550    else
005823  000551      // MainModule7Good_btn
005824  000552      img_ClearAttributes(hndl, iMainModule7Bad_btn, I_TOUCH_DISABLE);
005825  000553      img_SetWord(hndl, iMainModule7Bad_btn, IMAGE_INDEX, BTN_UP);
005826  000554      img_Show(hndl,iMainModule7Bad_btn);
005827  000555      img_SetAttributes(hndl, iMainModule7Good_btn, I_TOUCH_DISABLE);
005828  000556    endif
005829  000557        
005830  000558    // Main Module 7 Button
005831  000559    if(any_mod_errors(mod7))
005832  000560      // MainModule8Good_btn
005833  000561      img_ClearAttributes(hndl, iMainModule8Good_btn, I_TOUCH_DISABLE);
005834  000562      img_SetWord(hndl, iMainModule8Good_btn, IMAGE_INDEX, BTN_UP);
005835  000563      img_Show(hndl,iMainModule8Good_btn);
005836  000564      img_SetAttributes(hndl, iMainModule8Bad_btn, I_TOUCH_DISABLE);
005837  000565    else
005838  000566      // MainModule8Good_btn
005839  000567      img_ClearAttributes(hndl, iMainModule8Bad_btn, I_TOUCH_DISABLE);
005840  000568      img_SetWord(hndl, iMainModule8Bad_btn, IMAGE_INDEX, BTN_UP);
005841  000569      img_Show(hndl,iMainModule8Bad_btn);
005842  000570      img_SetAttributes(hndl, iMainModule8Good_btn, I_TOUCH_DISABLE);
005843  000571    endif
005844  000572        
005845  000573    // Main Module 8 Button
005846  000574    if(any_mod_errors(mod8))
005847  000575      // MainModule9Good_btn
005848  000576      img_ClearAttributes(hndl, iMainModule9Good_btn, I_TOUCH_DISABLE);
005849  000577      img_SetWord(hndl, iMainModule9Good_btn, IMAGE_INDEX, BTN_UP);
005850  000578      img_Show(hndl,iMainModule9Good_btn);
005851  000579      img_SetAttributes(hndl, iMainModule9Bad_btn, I_TOUCH_DISABLE);
005852  000580    else
005853  000581      // MainModule9Good_btn
005854  000582      img_ClearAttributes(hndl, iMainModule9Bad_btn, I_TOUCH_DISABLE);
005855  000583      img_SetWord(hndl, iMainModule9Bad_btn, IMAGE_INDEX, BTN_UP);
005856  000584      img_Show(hndl,iMainModule9Bad_btn);
005857  000585      img_SetAttributes(hndl, iMainModule9Good_btn, I_TOUCH_DISABLE);
005858  000586    endif
005859  000587        
005860  000588  endfunc
005861  000589        
005862  000590  func any_mod_errors(var mod)
005863  000591    var alarm_index;
005864  000592    alarm_index := 2;
005865  000593    if(mod[alarm_index] == 0x00 || mod[alarm_index] == 0x00)
005866  000594      return TRUE;
005867  000595    else
005868  000596      return FALSE;
005869  000597    endif
005870  000598  endfunc
005871  000599        
005872  000600  // === Shelf Form ===
005873  000601        
005874  000602  func draw_shelf_form()
005875  000603        
005876  000604    gfx_BGcolour(0x8D9C);
005877  000605    gfx_Cls();
005878  000606        
005879  000607    draw_shelf_modules();
005880  000608        
005881  000609    draw_shelf_mod_info(0);
005882  000610        
005883  000611    draw_shelf_alarms();
005884  000612        
005885  000613    draw_shelf_readings();
005886  000614        
005887  000615    draw_shelf_system_status();
005888  000616        
005889  000617    draw_shelf_side_buttons();
005890  000618        
005891  000619  endfunc
005892  000620        
005893  000621  func draw_shelf_alarms()
005894  000622        
005895  000623    // Draw the background panel
005896  000624    gfx_OutlineColour(SILVER);
005897  000625    gfx_Panel(PANEL_SUNKEN, 18, 225, 270, 236, 0x8D9C);
005898  000626    gfx_OutlineColour(BLACK);
005899  000627        
005900  000628    // Draw the LEDs
005901  000629    draw_shelf_alarm_leds();
005902  000630        
005903  000631    // Draw the labels for the LEDs
005904  000632    draw_shelf_alarms_labels();
005905  000633        
005906  000634    // Draw the "Error" field
005907  000635    gfx_Panel(PANEL_RAISED, 160, 406, 108, 35, WHITE);
005908  000636        
005909  000637    // Draw the title
005910  000638    img_Show(hndl,iShelfAlarms_Title);
005911  000639        
005912  000640  endfunc
005913  000641        
005914  000642  func draw_shelf_readings()
005915  000643        
005916  000644    // Draw the background panel
005917  000645    gfx_OutlineColour(SILVER);
005918  000646    gfx_Panel(PANEL_SUNKEN, 296, 225, 324, 236, 0x8D9C);
005919  000647    gfx_OutlineColour(BLACK);
005920  000648        
005921  000649    // Draw the labels
005922  000650    draw_shelf_readings_labels();
005923  000651        
005924  000652    // Draw the fields
005925  000653    draw_shelf_readings_fields();
005926  000654        
005927  000655    // Draw the title
005928  000656    img_Show(hndl,iShelfReadings_Title);
005929  000657        
005930  000658  endfunc
005931  000659        
005932  000660  func draw_shelf_modules()
005933  000661        
005934  000662    // Draw the background panel
005935  000663    gfx_OutlineColour(SILVER);
005936  000664    gfx_Panel(PANEL_SUNKEN, 18, 29, 270, 166, 0x8D9C);
005937  000665    gfx_OutlineColour(BLACK);
005938  000666        
005939  000667    // Draw the modules
005940  000668    draw_shelf_module_buttons();
005941  000669        
005942  000670    // Draw the title
005943  000671    img_Show(hndl,iModules_Title);
005944  000672        
005945  000673  endfunc
005946  000674        
005947  000675  func draw_shelf_mod_info(var mod_number)
005948  000676        
005949  000677    // Draw the background panel
005950  000678    gfx_OutlineColour(SILVER);
005951  000679    gfx_Panel(PANEL_SUNKEN, 296, 29, 324, 166, 0x8D9C);
005952  000680    gfx_OutlineColour(BLACK);
005953  000681        
005954  000682    // Draw the LEDs for the module's alarms
005955  000683    draw_mod_alarm_leds(mods[mod_number]);
005956  000684        
005957  000685    // Draw the labels for the module's fields
005958  000686    draw_mod_labels();
005959  000687        
005960  000688    // Draw the fields for the module's info
005961  000689    draw_mod_info_fields();
005962  000690        
005963  000691    // Draw the title
005964  000692    img_Show(hndl,iModuleNumber_Title);
005965  000693        
005966  000694  endfunc
005967  000695        
005968  000696  func draw_mod_alarm_leds(var mod)
005969  000697        
005970  000698    var alarm_index, alarms;
005971  000699    alarm_index := 2;
005972  000700    alarms := mod[alarm_index];
005973  000701        
005974  000702    // Shelf Over Charged
005975  000703    if(alarms & 0x01 == 0x01)
005976  000704      gfx_CircleFilled(324, 140, 10, LED_GOOD);
005977  000705    else
005978  000706      gfx_CircleFilled(324, 140, 10, LED_BAD);
005979  000707    endif
005980  000708        
005981  000709    // Shelf Over Temp
005982  000710    if(alarms & 0x04 == 0x04)
005983  000711      gfx_CircleFilled(500, 140, 10, LED_GOOD);
005984  000712    else
005985  000713      gfx_CircleFilled(500, 140, 10, LED_BAD);
005986  000714    endif
005987  000715        
005988  000716    // Shelf Over Disc
005989  000717    if(alarms & 0x02 == 0x02)
005990  000718      gfx_CircleFilled(324, 172, 10, LED_GOOD);
005991  000719    else
005992  000720      gfx_CircleFilled(324, 172, 10, LED_BAD);
005993  000721    endif
005994  000722        
005995  000723    // Shelf Error
005996  000724    if(alarms & 0x08 == 0x08)
005997  000725      gfx_CircleFilled(500, 172, 10, LED_GOOD);
005998  000726    else
005999  000727      gfx_CircleFilled(500, 172, 10, LED_BAD);
006000  000728    endif
006001  000729        
006002  000730  endfunc
006003  000731        
006004  000732  func draw_mod_labels()
006005  000733        
006006  000734    // Module Voltage
006007  000735    img_Show(hndl,iModuleVoltage_Label) ;
006008  000736        
006009  000737    // Module Temp
006010  000738    img_Show(hndl,iModuleTemp_Label) ;
006011  000739        
006012  000740    // Module Voltage Units
006013  000741    img_Show(hndl,iModuleVoltage_Unit) ;
006014  000742        
006015  000743    // Module Temp Units
006016  000744    img_Show(hndl,iModuleTemp_Units) ;
006017  000745        
006018  000746    // Module Over Charged
006019  000747    img_Show(hndl,iModuleOverCharged_Label) ;
006020  000748        
006021  000749    // Module Over Discharged
006022  000750    img_Show(hndl,iModuleOverDischarged_Label) ;
006023  000751        
006024  000752    // Module Over Temp
006025  000753    img_Show(hndl,iModuleOverTemp_Label) ;
006026  000754        
006027  000755    // Module Error
006028  000756    img_Show(hndl,iModuleError_Label) ;
006029  000757    gfx_Panel(PANEL_RAISED, 572, 160, 35, 25, WHITE) ;
006030  000758        
006031  000759  endfunc
006032  000760        
006033  000761  func draw_mod_info_fields()
006034  000762        
006035  000763    gfx_Panel(PANEL_RAISED, 439, 44, 108, 35, WHITE);
006036  000764    gfx_Panel(PANEL_RAISED, 439, 82, 108, 35, WHITE);
006037  000765        
006038  000766  endfunc
006039  000767        
006040  000768  func draw_shelf_module_buttons()
006041  000769        
006042  000770    var alarm_index := 2;
006043  000771        
006044  000772    // Main Module 0 Button
006045  000773    if(any_mod_errors(mod0))
006046  000774      img_ClearAttributes(hndl, iModule1Good_btn, I_TOUCH_DISABLE);
006047  000775      img_SetWord(hndl, iModule1Good_btn, IMAGE_INDEX, BTN_UP);
006048  000776      img_Show(hndl,iModule1Good_btn);
006049  000777      img_SetAttributes(hndl, iModule1Bad_btn, I_TOUCH_DISABLE);
006050  000778    else
006051  000779      img_ClearAttributes(hndl, iModule1Bad_btn, I_TOUCH_DISABLE);
006052  000780      img_SetWord(hndl, iModule1Bad_btn, IMAGE_INDEX, BTN_UP);
006053  000781      img_Show(hndl,iModule1Bad_btn);
006054  000782      img_SetAttributes(hndl, iModule1Good_btn, I_TOUCH_DISABLE);
006055  000783    endif
006056  000784        
006057  000785    // Main Module 1 Button
006058  000786    if(any_mod_errors(mod1))
006059  000787      img_ClearAttributes(hndl, iModule2Good_btn, I_TOUCH_DISABLE);
006060  000788      img_SetWord(hndl, iModule2Good_btn, IMAGE_INDEX, BTN_UP);
006061  000789      img_Show(hndl,iModule2Good_btn);
006062  000790      img_SetAttributes(hndl, iModule2Bad_btn, I_TOUCH_DISABLE);
006063  000791    else
006064  000792      img_ClearAttributes(hndl, iModule2Bad_btn, I_TOUCH_DISABLE);
006065  000793      img_SetWord(hndl, iModule2Bad_btn, IMAGE_INDEX, BTN_UP);
006066  000794      img_Show(hndl,iModule2Bad_btn);
006067  000795      img_SetAttributes(hndl, iModule2Good_btn, I_TOUCH_DISABLE);
006068  000796    endif
006069  000797        
006070  000798    // Main Module 2 Button
006071  000799    if(any_mod_errors(mod2))
006072  000800      img_ClearAttributes(hndl, iModule3Good_btn, I_TOUCH_DISABLE);
006073  000801      img_SetWord(hndl, iModule3Good_btn, IMAGE_INDEX, BTN_UP);
006074  000802      img_Show(hndl,iModule3Good_btn);
006075  000803      img_SetAttributes(hndl, iModule3Bad_btn, I_TOUCH_DISABLE);
006076  000804    else
006077  000805      img_ClearAttributes(hndl, iModule3Bad_btn, I_TOUCH_DISABLE);
006078  000806      img_SetWord(hndl, iModule3Bad_btn, IMAGE_INDEX, BTN_UP);
006079  000807      img_Show(hndl,iModule3Bad_btn);
006080  000808      img_SetAttributes(hndl, iModule3Good_btn, I_TOUCH_DISABLE);
006081  000809    endif
006082  000810        
006083  000811    // Main Module 3 Button
006084  000812    if(any_mod_errors(mod3))
006085  000813      img_ClearAttributes(hndl, iModule4Good_btn, I_TOUCH_DISABLE);
006086  000814      img_SetWord(hndl, iModule4Good_btn, IMAGE_INDEX, BTN_UP);
006087  000815      img_Show(hndl,iModule4Good_btn);
006088  000816      img_SetAttributes(hndl, iModule4Bad_btn, I_TOUCH_DISABLE);
006089  000817    else
006090  000818      img_ClearAttributes(hndl, iModule4Bad_btn, I_TOUCH_DISABLE);
006091  000819      img_SetWord(hndl, iModule4Bad_btn, IMAGE_INDEX, BTN_UP);
006092  000820      img_Show(hndl,iModule4Bad_btn);
006093  000821      img_SetAttributes(hndl, iModule4Good_btn, I_TOUCH_DISABLE);
006094  000822    endif
006095  000823        
006096  000824    // Main Module 4 Button
006097  000825    if(any_mod_errors(mod4))
006098  000826      img_ClearAttributes(hndl, iModule5Good_btn, I_TOUCH_DISABLE);
006099  000827      img_SetWord(hndl, iModule5Good_btn, IMAGE_INDEX, BTN_UP);
006100  000828      img_Show(hndl,iModule5Good_btn);
006101  000829      img_SetAttributes(hndl, iModule5Bad_btn, I_TOUCH_DISABLE);
006102  000830    else
006103  000831      img_ClearAttributes(hndl, iModule5Bad_btn, I_TOUCH_DISABLE);
006104  000832      img_SetWord(hndl, iModule5Bad_btn, IMAGE_INDEX, BTN_UP);
006105  000833      img_Show(hndl,iModule5Bad_btn);
006106  000834      img_SetAttributes(hndl, iModule5Good_btn, I_TOUCH_DISABLE);
006107  000835    endif
006108  000836        
006109  000837    // Main Module 5 Button
006110  000838    if(any_mod_errors(mod5))
006111  000839      img_ClearAttributes(hndl, iModule6Good_btn, I_TOUCH_DISABLE);
006112  000840      img_SetWord(hndl, iModule6Good_btn, IMAGE_INDEX, BTN_UP);
006113  000841      img_Show(hndl,iModule6Good_btn);
006114  000842      img_SetAttributes(hndl, iModule6Bad_btn, I_TOUCH_DISABLE);
006115  000843    else
006116  000844      img_ClearAttributes(hndl, iModule6Bad_btn, I_TOUCH_DISABLE);
006117  000845      img_SetWord(hndl, iModule6Bad_btn, IMAGE_INDEX, BTN_UP);
006118  000846      img_Show(hndl,iModule6Bad_btn);
006119  000847      img_SetAttributes(hndl, iModule6Good_btn, I_TOUCH_DISABLE);
006120  000848    endif
006121  000849        
006122  000850    // Main Module 6 Button
006123  000851    if(any_mod_errors(mod6))
006124  000852      img_ClearAttributes(hndl, iModule7Good_btn, I_TOUCH_DISABLE);
006125  000853      img_SetWord(hndl, iModule7Good_btn, IMAGE_INDEX, BTN_UP);
006126  000854      img_Show(hndl,iModule7Good_btn);
006127  000855      img_SetAttributes(hndl, iModule7Bad_btn, I_TOUCH_DISABLE);
006128  000856    else
006129  000857      img_ClearAttributes(hndl, iModule7Bad_btn, I_TOUCH_DISABLE);
006130  000858      img_SetWord(hndl, iModule7Bad_btn, IMAGE_INDEX, BTN_UP);
006131  000859      img_Show(hndl,iModule7Bad_btn);
006132  000860      img_SetAttributes(hndl, iModule7Good_btn, I_TOUCH_DISABLE);
006133  000861    endif
006134  000862        
006135  000863    // Main Module 7 Button
006136  000864    if(any_mod_errors(mod7))
006137  000865      img_ClearAttributes(hndl, iModule8Good_btn, I_TOUCH_DISABLE);
006138  000866      img_SetWord(hndl, iModule8Good_btn, IMAGE_INDEX, BTN_UP);
006139  000867      img_Show(hndl,iModule8Good_btn);
006140  000868      img_SetAttributes(hndl, iModule8Bad_btn, I_TOUCH_DISABLE);
006141  000869    else
006142  000870      img_ClearAttributes(hndl, iModule8Bad_btn, I_TOUCH_DISABLE);
006143  000871      img_SetWord(hndl, iModule8Bad_btn, IMAGE_INDEX, BTN_UP);
006144  000872      img_Show(hndl,iModule8Bad_btn);
006145  000873      img_SetAttributes(hndl, iModule8Good_btn, I_TOUCH_DISABLE);
006146  000874    endif
006147  000875        
006148  000876    // Main Module 8 Button
006149  000877    if(any_mod_errors(mod8))
006150  000878      img_ClearAttributes(hndl, iModule9Good_btn, I_TOUCH_DISABLE);
006151  000879      img_SetWord(hndl, iModule9Good_btn, IMAGE_INDEX, BTN_UP);
006152  000880      img_Show(hndl,iModule9Good_btn);
006153  000881      img_SetAttributes(hndl, iModule9Bad_btn, I_TOUCH_DISABLE);
006154  000882    else
006155  000883      img_ClearAttributes(hndl, iModule9Bad_btn, I_TOUCH_DISABLE);
006156  000884      img_SetWord(hndl, iModule9Bad_btn, IMAGE_INDEX, BTN_UP);
006157  000885      img_Show(hndl,iModule9Bad_btn);
006158  000886      img_SetAttributes(hndl, iModule9Good_btn, I_TOUCH_DISABLE);
006159  000887    endif
006160  000888        
006161  000889  endfunc
006162  000890        
006163  000891  func draw_shelf_alarm_leds()
006164  000892        
006165  000893    var alarm_index, alarms;
006166  000894    alarm_index := 6;
006167  000895    alarms := shelf0[alarm_index];
006168  000896        
006169  000897    // Shelf Over Charged
006170  000898    if(alarms & 0x01 == 0x01)
006171  000899      gfx_CircleFilled(50, 265, 20, LED_GOOD);
006172  000900    else
006173  000901      gfx_CircleFilled(50, 265, 20, LED_BAD);
006174  000902    endif
006175  000903        
006176  000904    // Shelf Over Temp
006177  000905    if(alarms & 0x04 == 0x04)
006178  000906      gfx_CircleFilled(50, 317, 20, LED_GOOD);
006179  000907    else
006180  000908      gfx_CircleFilled(50, 317, 20, LED_BAD);
006181  000909    endif
006182  000910        
006183  000911    // Shelf Over Disc
006184  000912    if(alarms & 0x02 == 0x02)
006185  000913      gfx_CircleFilled(50, 368, 20, LED_GOOD);
006186  000914    else
006187  000915      gfx_CircleFilled(50, 368, 20, LED_BAD);
006188  000916    endif
006189  000917        
006190  000918    // Shelf Error
006191  000919    if(alarms & 0x08 == 0x08)
006192  000920      gfx_CircleFilled(50, 425, 20, LED_GOOD);
006193  000921    else
006194  000922      gfx_CircleFilled(50, 425, 20, LED_BAD);
006195  000923    endif
006196  000924        
006197  000925  endfunc
006198  000926        
006199  000927  func draw_shelf_alarms_labels()
006200  000928        
006201  000929    // Shelf Over Charge
006202  000930    img_Show(hndl,iShelfOverCharge_Label);
006203  000931        
006204  000932    // Shelf Over Temp
006205  000933    img_Show(hndl,iShelfOverTemp_Label);
006206  000934        
006207  000935    // Over Discharged
006208  000936    img_Show(hndl,iOverDischarged_Label);
006209  000937        
006210  000938    // Shelf Error
006211  000939    img_Show(hndl,iShelfError_Label);
006212  000940        
006213  000941  endfunc
006214  000942        
006215  000943  func draw_shelf_readings_labels()
006216  000944        
006217  000945    // Shelf Total Voltage
006218  000946    img_Show(hndl,iShelfTotalVoltage_Label);
006219  000947        
006220  000948    // Shelf Average Temp
006221  000949    img_Show(hndl,iShelfAverageTemp_Label);
006222  000950        
006223  000951    // Shelf Max Temp
006224  000952    img_Show(hndl,iShelfMaxTemp_Label);
006225  000953        
006226  000954    // Shelf Min Temp
006227  000955    img_Show(hndl,iShelfMinTemp_Label);
006228  000956        
006229  000957    // Shelf Total Voltage Units
006230  000958    img_Show(hndl,iShelfTotalVoltage_Units);
006231  000959        
006232  000960    // Shelf Average Temp Units
006233  000961    img_Show(hndl,iShelfAverageTemp_Units);
006234  000962        
006235  000963    // Module ID
006236  000964    img_Show(hndl,iModuleID_Label);
006237  000965        
006238  000966  endfunc
006239  000967        
006240  000968  func draw_shelf_readings_fields()
006241  000969        
006242  000970    // Total Voltage
006243  000971    gfx_Panel(PANEL_RAISED, 441, 246, 108, 35, WHITE);
006244  000972        
006245  000973    // Average Temp
006246  000974    gfx_Panel(PANEL_RAISED, 441, 291, 108, 35, WHITE);
006247  000975        
006248  000976    // Max Temp
006249  000977    gfx_Panel(PANEL_RAISED, 441, 364, 108, 35, WHITE);
006250  000978        
006251  000979    // Min Temp
006252  000980    gfx_Panel(PANEL_RAISED, 441, 416, 108, 35, WHITE);
006253  000981        
006254  000982    // Max ID
006255  000983    gfx_Panel(PANEL_RAISED, 560, 364, 50, 35, WHITE);
006256  000984        
006257  000985    // Min ID
006258  000986    gfx_Panel(PANEL_RAISED, 560, 416, 50, 35, WHITE);
006259  000987        
006260  000988  endfunc
006261  000989        
006262  000990  func draw_shelf_system_status()
006263  000991  endfunc
006264  000992        
006265  000993  func draw_shelf_side_buttons()
006266  000994        
006267  000995    // SystemStart_btn
006268  000996    img_ClearAttributes(hndl, iSystemStart_btn, I_TOUCH_DISABLE);
006269  000997    img_SetWord(hndl, iSystemStart_btn, IMAGE_INDEX, BTN_UP);
006270  000998    img_Show(hndl,iSystemStart_btn);
006271  000999        
006272  001000    // SystemStop_btn
006273  001001    img_ClearAttributes(hndl, iSystemStop_btn, I_TOUCH_DISABLE);
006274  001002    img_SetWord(hndl, iSystemStop_btn, IMAGE_INDEX, BTN_UP);
006275  001003    img_Show(hndl,iSystemStop_btn);
006276  001004        
006277  001005    // Shelf_btn
006278  001006    img_ClearAttributes(hndl, iShelfToMain_btn, I_TOUCH_DISABLE);
006279  001007    img_SetWord(hndl, iShelfToMain_btn, IMAGE_INDEX, BTN_UP);
006280  001008    img_Show(hndl,iShelfToMain_btn);
006281  001009        
006282  001010    // EmergencyStop_btn
006283  001011    img_ClearAttributes(hndl, iEmergencyStop_btn, I_TOUCH_DISABLE);
006284  001012    img_SetWord(hndl, iEmergencyStop_btn, IMAGE_INDEX, BTN_UP);
006285  001013    img_Show(hndl,iEmergencyStop_btn);
006286  001014        
006287  001015  endfunc
006288  001016        
006289  001017  // ##################
006290  001018  // Math
006291  001019  // ##################
006292  001020        
006293  001021  // Prints the system voltage
006294  001022  // Sums the voltage from each shelf
006295  001023  func print_system_voltage(var x_pos, var y_pos)
006296  001024        
006297  001025      var sys_volt[2];
006298  001026        
006299  001027      sys_volt := calc_system_voltage();
006300  001028        
006301  001029      gfx_MoveTo(x_pos, y_pos);
006302  001030      flt_PRINT(sys_volt, "%-.0f");
006303  001031        
006304  001032  endfunc
006305  001033        
006306  001034  // Calculates the system voltage
006307  001035  // By summing up each shelf's voltage
006308  001036  func calc_system_voltage()
006309  001037        
006310  001038      var sys_volt[2];
006311  001039        
006312  001040      // Init the system voltage
006313  001041      flt_VAL(sys_volt, "0.0");
006314  001042        
006315  001043      // Sum the voltages
006316  001044      var i;
006317  001045      for(i := 0; i < 3; i++)
006318  001046        
006319  001047          calc_shelf_voltage(i);
006320  001048        
006321  001049          // Add current shelf voltage to system voltage
006322  001050          flt_ADD(sys_volt, sys_volt, shelf_volt);
006323  001051      next
006324  001052        
006325  001053      return sys_volt;
006326  001054        
006327  001055  endfunc
006328  001056        
006329  001057  // Prints off the voltage given a 16 bit int
006330  001058  func print_shelf_voltage(var shelf, var x_pos, var y_pos)
006331  001059        
006332  001060      // Setting up float arrays
006333  001061      var volt_flt[2];
006334  001062        
006335  001063      calc_shelf_voltage(shelf);
006336  001064        
006337  001065      // Print it at desired location
006338  001066      gfx_MoveTo(x_pos, y_pos);
006339  001067      flt_PRINT(volt_flt, "%-.0f");
006340  001068        
006341  001069  endfunc
006342  001070        
006343  001071  // Calculates the voltage given a 16 bit int for a shelf
006344  001072  func calc_shelf_voltage(var shelf)
006345  001073        
006346  001074      get_shelf(shelf);
006347  001075        
006348  001076      var volt_int;
006349  001077      volt_int := shelf_ptr[0];
006350  001078        
006351  001079      // Setting up float arrays
006352  001080      var volt_flt[2], temp_flt[2];
006353  001081        
006354  001082      // Convert to float
006355  001083      flt_ITOF(volt_flt, volt_int);
006356  001084        
006357  001085      // Create multiplication factor
006358  001086      flt_VAL(temp_flt, "0.02");
006359  001087        
006360  001088      // (voltage = [0xUpperByte,0xLowerByte] * 0.02)
006361  001089      flt_MUL(shelf_volt, volt_flt, temp_flt);
006362  001090        
006363  001091  endfunc
006364  001092        
006365  001093  // Calculates the voltage given a 16 bit int for a mod
006366  001094  func calc_mod_voltage(var volt_int)
006367  001095        
006368  001096      // Setting up float arrays
006369  001097      var volt_flt[2], temp_flt[2];
006370  001098        
006371  001099      // Convert to float
006372  001100      flt_ITOF(volt_flt, volt_int);
006373  001101        
006374  001102      // Create multiplication factor
006375  001103      flt_VAL(temp_flt, "0.02");
006376  001104        
006377  001105      // (voltage = [0xUpperByte,0xLowerByte] * 0.02)
006378  001106      flt_MUL(volt_mod, volt_flt, temp_flt);
006379  001107        
006380  001108  endfunc
006381  001109        
006382  001110  // Prints off the temperature given a 8+ bit int
006383  001111  func print_temperature(var temp_int, var x_pos, var y_pos)
006384  001112        
006385  001113      var temp_flt[2];
006386  001114        
006387  001115      temp_flt := calc_temperature(temp_int);
006388  001116        
006389  001117      gfx_MoveTo(x_pos, y_pos);
006390  001118      flt_PRINT(temp_flt, "%-.0f");
006391  001119        
006392  001120  endfunc
006393  001121        
006394  001122  // Calculates the temperature given an 8+ bit int
006395  001123  func calc_temperature(var temp_int)
006396  001124        
006397  001125      var temp_flt_1[2], temp_flt_2[2];
006398  001126        
006399  001127      // Get the temperature
006400  001128      flt_VAL(temp_flt_1, "0.5");
006401  001129      flt_ITOF(temp_flt_2, temp_int);
006402  001130      flt_MUL(temp_flt_1, temp_flt_1, temp_flt_2);
006403  001131        
006404  001132      return temp_flt_1;
006405  001133        
006406  001134  endfunc
006407  001135        
006408  001136  // ##################
006409  001137  // Get/Set
006410  001138  // ##################
006411  001139        
006412  001140  // Basic Shelf Get/Set
006413  001141  // Sets the global shelf_ptr to 'shelf'
006414  001142  func get_shelf(var shelf)
006415  001143        
006416  001144      shelf_ptr := shelf0;
006417  001145        
006418  001146  endfunc
006419  001147        
006420  001148  // Updates the shelf_ptr shelf's info
006421  001149  func set_shelf(var data)
006422  001150        
006423  001151      shelf_ptr[0] := data[SHELF_V];
006424  001152      shelf_ptr[1] := data[SHELF_V + 1];
006425  001153      shelf_ptr[2] := data[SHELF_T];
006426  001154      shelf_ptr[3] := data[SHELF_H];
006427  001155      shelf_ptr[4] := data[SHELF_L];
006428  001156      shelf_ptr[5] := data[SHELF_ID];
006429  001157      shelf_ptr[6] := data[SHELF_A];
006430  001158      shelf_ptr[7] := data[SHELF_E];
006431  001159        
006432  001160  endfunc
006433  001161        
006434  001162  // Basic Mod Get/Set
006435  001163  // Sets the global mod_ptr_1 to 'even' mod (0, 2, 4, ...)
006436  001164  // Sets the global mod_ptr_2 to 'odd' mod (1, 3, 5, ...)
006437  001165  func get_mods(var shelf, var mod)
006438  001166        
006439  001167      var mods_per_shelf := 12;
006440  001168      mod_ptr_1 := mods[mod + (shelf * mods_per_shelf)];
006441  001169      mod_ptr_2 := mods[mod + (shelf * mods_per_shelf) + 1];
006442  001170        
006443  001171  endfunc
006444  001172        
006445  001173  // Updates the mod_ptr_1 & mod_ptr_2 mods' infos
006446  001174  func set_mods(var data)
006447  001175        
006448  001176      // Get the voltage
006449  001177      mod_ptr_1[0] := data[MOD_V];
006450  001178      mod_ptr_1[1] := data[MOD_V + 1];
006451  001179      mod_ptr_2[0] := data[MOD_V + 4];
006452  001180      mod_ptr_2[1] := data[MOD_V + 4 + 1];
006453  001181        
006454  001182      // Get the temperature
006455  001183      mod_ptr_1[2] := data[MOD_T];
006456  001184      mod_ptr_2[2] := data[MOD_T + 4];
006457  001185        
006458  001186      // Get the Alarm/Error
006459  001187      mod_ptr_1[3] := data[MOD_A];
006460  001188      mod_ptr_2[3] := data[MOD_A + 4];
006461  001189  endfunc
006462  001190        
006463  001191  // ##################
006464  001192  // Input/Output
006465  001193  // ##################
006466  001194        
006467  001195  // === Input ===
006468  001196        
006469  001197  // Handles input messages
006470  001198  func process_input()
006471  001199        
006472  001200      var tmpByte;
006473  001201      var dataByteCount := 0x0F;
006474  001202      var temp_vals[15];
006475  001203      var shelf_number;
006476  001204      var mod_number;
006477  001205      var i;
006478  001206        
006479  001207      if(com1_Count() > dataByteCount)
006480  001208        
006481  001209          // Read in the first byte
006482  001210          // Should be START BYTE (0xAA)
006483  001211          tmpByte := serin1();
006484  001212        
006485  001213          // Looking for the start of a message so...
006486  001214          // While tmpByte isn't the Start Byte
006487  001215          while(tmpByte != START_BYT)
006488  001216        
006489  001217              // If there isn't enough data
006490  001218              // in the buffer for a full message
006491  001219              if(com1_Count() < dataByteCount)
006492  001220                  return; // Leave function
006493  001221              endif
006494  001222        
006495  001223              // Read in the next byte
006496  001224              tmpByte := serin1();
006497  001225        
006498  001226          wend
006499  001227        
006500  001228          // Give it  5msec to breath
006501  001229          pause(5);
006502  001230        
006503  001231          // Read in vals from buffer into temp array
006504  001232          for(i := 0; i < dataByteCount; i++)
006505  001233              temp_vals[i] := serin1();
006506  001234          next
006507  001235        
006508  001236          // If it's a shelf update message
006509  001237          if(temp_vals[TYPE] == 0xA0)
006510  001238        
006511  001239              // See who the message is for
006512  001240              shelf_number := temp_vals[ID];
006513  001241        
006514  001242              // Get their attention
006515  001243              get_shelf(shelf_number);
006516  001244        
006517  001245              // Update their info
006518  001246              set_shelf(temp_vals);
006519  001247          endif
006520  001248        
006521  001249          // If it's a mod update message
006522  001250          if((temp_vals[TYPE] & 0xB0) == 0xB0)
006523  001251        
006524  001252              // See who the message is for
006525  001253              shelf_number := temp_vals[ID];
006526  001254              mod_number := ((temp_vals[TYPE] | 0xF0) & 0x0F);
006527  001255        
006528  001256              // Get their attention
006529  001257              get_mods(shelf_number, mod_number);
006530  001258        
006531  001259              // Update their info
006532  001260              set_mods(temp_vals);
006533  001261          endif
006534  001262      endif
006535  001263  endfunc
006536  001264        
006537  001265  // === Output ===
006538  001266        
006539  001267  // Requests the basic module info
006540  001268  // Sends out the "B#" command
006541  001269  func request_mod(var shelf, var mod)
006542  001270        
006543  001271      var cmd[7];
006544  001272      cmd[0] := 0x18;
006545  001273      cmd[1] := 0xEA;
006546  001274      cmd[2] := shelf;
006547  001275      cmd[3] := 0x0F;
006548  001276      cmd[4] := (0xB0) + (mod/2);
006549  001277      cmd[5] := 0xFF;
006550  001278      cmd[6] := 0x00;
006551  001279        
006552  001280      var i;
006553  001281      for(i := 0; i < 7; i++)
006554  001282          serout1(cmd[i]);
006555  001283      next
006556  001284        
006557  001285  endfunc
006558  001286        
006559  001287  // Sends a request for all the mods on the current shelf
006560  001288  func request_all_shelf_mods(var shelf)
006561  001289        
006562  001290      var mods_per_shelf := 12;
006563  001291        
006564  001292      var i;
006565  001293      for(i := 0; i < mods_per_shelf; i += 2)
006566  001294          // Send request for each mod on current shelf
006567  001295          request_mod(shelf, i);
006568  001296          // pause(5);
006569  001297      next
006570  001298  endfunc
006571  001299        
006572  001300  func check_press()
006573  001301        
006574  001302    var touch_state;
006575  001303    touch_state := touch_Get(TOUCH_STATUS);
006576  001304        
006577  001305    if(touch_state == TOUCH_RELEASED)
006578  001306        
006579  001307      // Get the touched image and location
006580  001308      var touched_image, x_touch, y_touch;
006581  001309      touched_image := img_Touched(hndl, -1);
006582  001310      x_touch := touch_Get(TOUCH_GETX);
006583  001311      y_touch := touch_Get(TOUCH_GETY);
006584  001312        
006585  001313      // If we are looking at the overview screen
006586  001314      if(current_form == OVERVIEW_FORM)
006587  001315        
006588  001316        if(touched_image == iShelf_btn)
006589  001317          current_form := SHELF_FORM;
006590  001318          disable_all_inputs();
006591  001319          draw_shelf_form();
006592  001320        endif
006593  001321        
006594  001322      endif
006595  001323        
006596  001324      // If we are looking at the shelf form
006597  001325      if(current_form == SHELF_FORM)
006598  001326        
006599  001327        if(touched_image == iShelfToMain_btn)
006600  001328          current_form := OVERVIEW_FORM;
006601  001329          disable_all_inputs();
006602  001330          draw_overall_form();
006603  001331        endif
006604  001332        
006605  001333      endif
006606  001334        
006607  001335    endif
006608  001336        
006609  001337  endfunc
006610  001338        
006611  001339  func disable_all_inputs()
006612  001340        
006613  001341    img_SetAttributes(hndl, -1, I_TOUCH_DISABLE);
006614  001342        
006615  001343  endfunc
006616  001344        
006617  001345        
Notice: no execution path to func 'request_all_shelf_mods'
Notice: no execution path to func 'process_input'
Notice: variable 'data' is being indexed (line 1177 file:CERDEC.4dg)
Notice: variable 'data' is being indexed (line 1178 file:CERDEC.4dg)
Notice: variable 'data' is being indexed (line 1179 file:CERDEC.4dg)
Notice: variable 'data' is being indexed (line 1180 file:CERDEC.4dg)
Notice: variable 'data' is being indexed (line 1183 file:CERDEC.4dg)
Notice: variable 'data' is being indexed (line 1184 file:CERDEC.4dg)
Notice: variable 'data' is being indexed (line 1187 file:CERDEC.4dg)
Notice: variable 'data' is being indexed (line 1188 file:CERDEC.4dg)
Notice: variable 'data' is being indexed (line 1151 file:CERDEC.4dg)
Notice: variable 'data' is being indexed (line 1152 file:CERDEC.4dg)
Notice: variable 'data' is being indexed (line 1153 file:CERDEC.4dg)
Notice: variable 'data' is being indexed (line 1154 file:CERDEC.4dg)
Notice: variable 'data' is being indexed (line 1155 file:CERDEC.4dg)
Notice: variable 'data' is being indexed (line 1156 file:CERDEC.4dg)
Notice: variable 'data' is being indexed (line 1157 file:CERDEC.4dg)
Notice: variable 'data' is being indexed (line 1158 file:CERDEC.4dg)
Notice: function argument 'shelf' in func 'get_shelf' is never used (line 1142 file:CERDEC.4dg)
Notice: no execution path to func 'print_temperature'
Notice: no execution path to func 'calc_mod_voltage'
Notice: no execution path to func 'print_shelf_voltage'
Notice: no execution path to func 'print_system_voltage'
Notice: variable 'mod' is being indexed (line 700 file:CERDEC.4dg)
Notice: variable 'mod' is being indexed (line 593 file:CERDEC.4dg)
Notice: variable 'mod' is being indexed (line 593 file:CERDEC.4dg)


Symbol Table:
name                             decimal         hex
__MAXBANKS                             6  0x00000006 (const dword)  (not used)
__MAXMEM                           32768  0x00008000 (const dword)  (usage 1)
__MAXPROG                          32750  0x00007fee (const dword)  (usage 1)
__PLATFORM                             3  0x00000003 (const dword)  (not used)
__reserved10                        -111  0xffffff91 (PmmC func) args[0] r=0  (not used)
__reserved13                        -123  0xffffff85 (PmmC func) args[0] r=0  (not used)
__reserved14                        -124  0xffffff84 (PmmC func) args[0] r=0  (not used)
__reserved17                        -201  0xffffff37 (PmmC func) args[0] r=0  (not used)
__reserved18                        -202  0xffffff36 (PmmC func) args[0] r=0  (not used)
__reserved19                        -203  0xffffff35 (PmmC func) args[0] r=0  (not used)
__reserved20                        -204  0xffffff34 (PmmC func) args[0] r=0  (not used)
__reserved21                        -205  0xffffff33 (PmmC func) args[0] r=0  (not used)
__reserved22                        -206  0xffffff32 (PmmC func) args[0] r=0  (not used)
__reserved23                        -220  0xffffff24 (PmmC func) args[0] r=0  (not used)
__reserved24                        -221  0xffffff23 (PmmC func) args[0] r=0  (not used)
__reserved25                        -222  0xffffff22 (PmmC func) args[0] r=0  (not used)
__reserved26                        -223  0xffffff21 (PmmC func) args[0] r=0  (not used)
__reserved3                          -69  0xffffffbb (PmmC func) args[0] r=0  (not used)
__reserved30                        -283  0xfffffee5 (PmmC func) args[0] r=0  (not used)
__reserved4                          -70  0xffffffba (PmmC func) args[0] r=0  (not used)
__reserved42                        -373  0xfffffe8b (PmmC func) args[0] r=0  (not used)
__reserved43                        -387  0xfffffe7d (PmmC func) args[0] r=0  (not used)
__reserved44                        -388  0xfffffe7c (PmmC func) args[0] r=0  (not used)
__reserved45                        -389  0xfffffe7b (PmmC func) args[0] r=0  (not used)
__reserved46                        -390  0xfffffe7a (PmmC func) args[0] r=0  (not used)
__reserved5                          -76  0xffffffb4 (PmmC func) args[0] r=0  (not used)
__reserved51                        -411  0xfffffe65 (PmmC func) args[0] r=0  (not used)
__reserved52                        -412  0xfffffe64 (PmmC func) args[0] r=0  (not used)
__reserved53                        -422  0xfffffe5a (PmmC func) args[0] r=0  (not used)
__reserved54                        -423  0xfffffe59 (PmmC func) args[0] r=0  (not used)
__reserved57                        -457  0xfffffe37 (PmmC func) args[0] r=0  (not used)
__reserved58                        -458  0xfffffe36 (PmmC func) args[0] r=0  (not used)
__reserved6                          -77  0xffffffb3 (PmmC func) args[0] r=0  (not used)
__reserved60                        -467  0xfffffe2d (PmmC func) args[0] r=0  (not used)
__reserved61                        -468  0xfffffe2c (PmmC func) args[0] r=0  (not used)
__reserved62                        -469  0xfffffe2b (PmmC func) args[0] r=0  (not used)
__reserved63                        -490  0xfffffe16 (PmmC func) args[0] r=0  (not used)
__reserved64                        -491  0xfffffe15 (PmmC func) args[0] r=0  (not used)
__reserved65                        -492  0xfffffe14 (PmmC func) args[0] r=0  (not used)
__reserved66                        -493  0xfffffe13 (PmmC func) args[0] r=0  (not used)
__reserved68                        -509  0xfffffe03 (PmmC func) args[0] r=0  (not used)
__reserved69                        -510  0xfffffe02 (PmmC func) args[0] r=0  (not used)
__reserved70                        -511  0xfffffe01 (PmmC func) args[0] r=0  (not used)
__reserved72                        -520  0xfffffdf8 (PmmC func) args[0] r=0  (not used)
__reserved77                        -526  0xfffffdf2 (PmmC func) args[0] r=0  (not used)
__reserved78                        -527  0xfffffdf1 (PmmC func) args[0] r=0  (not used)
__reserved85                        -536  0xfffffde8 (PmmC func) args[0] r=0  (not used)
__reserved86                        -537  0xfffffde7 (PmmC func) args[0] r=0  (not used)
__reserved87                        -570  0xfffffdc6 (PmmC func) args[0] r=0  (not used)
__reserved88                        -571  0xfffffdc5 (PmmC func) args[0] r=0  (not used)
__reserved89                        -572  0xfffffdc4 (PmmC func) args[0] r=0  (not used)
__reserved9                         -110  0xffffff92 (PmmC func) args[0] r=0  (not used)
__translate                           -8  0xfffffff8 (PmmC func) args[4] r=1  (not used)
ABS                                  -53  0xffffffcb (PmmC func) args[1] r=1  (not used)
ACTIVE                                 1  0x00000001 (const dword)  (usage 3)
ALICEBLUE                          63455  0x0000f7df (const dword)  (not used)
ALL                                65535  0x0000ffff (const dword)  (not used)
ana_HS                              -533  0xfffffdeb (PmmC func) args[7] r=0  (not used)
ANTIQUEWHITE                       65370  0x0000ff5a (const dword)  (not used)
any_mod_errors                      2995  0x00000bb3 (User func) args[1] r=0  (usage 54)
APPEND                                 0  0x00000000 (const dword)  (not used)
AQUA                                2047  0x000007ff (const dword)  (not used)
AQUAMARINE                         32762  0x00007ffa (const dword)  (not used)
AUDIO_ENABLE                          17  0x00000011 (const dword)  (not used)
AZURE                              63487  0x0000f7ff (const dword)  (not used)
BACKGROUND_COLOR                   57183  0x0000df5f (const dword)  (not used)
BACKGROUND_COLOUR                     17  0x00000011 (const dword)  (not used)
BAUD_110                               0  0x00000000 (const dword)  (not used)
BAUD_115200                           13  0x0000000d (const dword)  (not used)
BAUD_1200                              3  0x00000003 (const dword)  (not used)
BAUD_128000                           14  0x0000000e (const dword)  (not used)
BAUD_14400                             7  0x00000007 (const dword)  (not used)
BAUD_19200                             8  0x00000008 (const dword)  (not used)
BAUD_2400                              4  0x00000004 (const dword)  (not used)
BAUD_256000                           15  0x0000000f (const dword)  (not used)
BAUD_300                               1  0x00000001 (const dword)  (not used)
BAUD_300000                           16  0x00000010 (const dword)  (not used)
BAUD_31250                             9  0x00000009 (const dword)  (not used)
BAUD_375000                           17  0x00000011 (const dword)  (not used)
BAUD_38400                            10  0x0000000a (const dword)  (not used)
BAUD_4800                              5  0x00000005 (const dword)  (not used)
BAUD_500000                           18  0x00000012 (const dword)  (not used)
BAUD_56000                            11  0x0000000b (const dword)  (not used)
BAUD_57600                            12  0x0000000c (const dword)  (not used)
BAUD_600                               2  0x00000002 (const dword)  (not used)
BAUD_600000                           19  0x00000013 (const dword)  (not used)
BAUD_9600                              6  0x00000006 (const dword)  (not used)
BEIGE                              63419  0x0000f7bb (const dword)  (not used)
BEVEL_RADIUS                          27  0x0000001b (const dword)  (not used)
BEVEL_SHADOW                          29  0x0000001d (const dword)  (not used)
BEVEL_WIDTH                           28  0x0000001c (const dword)  (not used)
BIN                                    2  0x00000002 (const dword)  (not used)
BIN1                                 258  0x00000102 (const dword)  (not used)
BIN10                               2562  0x00000a02 (const dword)  (not used)
BIN10Z                              6658  0x00001a02 (const dword)  (not used)
BIN10ZB                            10754  0x00002a02 (const dword)  (not used)
BIN11                               2818  0x00000b02 (const dword)  (not used)
BIN11Z                              6914  0x00001b02 (const dword)  (not used)
BIN11ZB                            11010  0x00002b02 (const dword)  (not used)
BIN12                               3074  0x00000c02 (const dword)  (not used)
BIN12Z                              7170  0x00001c02 (const dword)  (not used)
BIN12ZB                            11266  0x00002c02 (const dword)  (not used)
BIN13                               3330  0x00000d02 (const dword)  (not used)
BIN13Z                              7426  0x00001d02 (const dword)  (not used)
BIN13ZB                            11522  0x00002d02 (const dword)  (not used)
BIN14                               3586  0x00000e02 (const dword)  (not used)
BIN14Z                              7682  0x00001e02 (const dword)  (not used)
BIN14ZB                            11778  0x00002e02 (const dword)  (not used)
BIN15                               3842  0x00000f02 (const dword)  (not used)
BIN15Z                              7938  0x00001f02 (const dword)  (not used)
BIN15ZB                            12034  0x00002f02 (const dword)  (not used)
BIN16                                  2  0x00000002 (const dword)  (not used)
BIN16Z                              4098  0x00001002 (const dword)  (not used)
BIN16ZB                             8194  0x00002002 (const dword)  (not used)
BIN1Z                               4354  0x00001102 (const dword)  (not used)
BIN1ZB                              8450  0x00002102 (const dword)  (not used)
BIN2                                 514  0x00000202 (const dword)  (not used)
BIN2Z                               4610  0x00001202 (const dword)  (not used)
BIN2ZB                              8706  0x00002202 (const dword)  (not used)
BIN3                                 770  0x00000302 (const dword)  (not used)
BIN3Z                               4866  0x00001302 (const dword)  (not used)
BIN3ZB                              8962  0x00002302 (const dword)  (not used)
BIN4                                1026  0x00000402 (const dword)  (not used)
BIN4Z                               5122  0x00001402 (const dword)  (not used)
BIN4ZB                              9218  0x00002402 (const dword)  (not used)
BIN5                                1282  0x00000502 (const dword)  (not used)
BIN5Z                               5378  0x00001502 (const dword)  (not used)
BIN5ZB                              9474  0x00002502 (const dword)  (not used)
BIN6                                1538  0x00000602 (const dword)  (not used)
BIN6Z                               5634  0x00001602 (const dword)  (not used)
BIN6ZB                              9730  0x00002602 (const dword)  (not used)
BIN7                                1794  0x00000702 (const dword)  (not used)
BIN7Z                               5890  0x00001702 (const dword)  (not used)
BIN7ZB                              9986  0x00002702 (const dword)  (not used)
BIN8                                2050  0x00000802 (const dword)  (not used)
BIN8Z                               6146  0x00001802 (const dword)  (not used)
BIN8ZB                             10242  0x00002802 (const dword)  (not used)
BIN9                                2306  0x00000902 (const dword)  (not used)
BIN9Z                               6402  0x00001902 (const dword)  (not used)
BIN9ZB                             10498  0x00002902 (const dword)  (not used)
BINZ                                4098  0x00001002 (const dword)  (not used)
BINZB                               8194  0x00002002 (const dword)  (not used)
BISQUE                             65336  0x0000ff38 (const dword)  (not used)
BLACK                                  0  0x00000000 (const dword)  (usage 15)
BLANCHEDALMOND                     65369  0x0000ff59 (const dword)  (not used)
BLUE                                  31  0x0000001f (const dword)  (not used)
BLUEVIOLET                         35164  0x0000895c (const dword)  (not used)
BOLD                                  16  0x00000010 (const dword)  (not used)
BOTTOM_POS                             5  0x00000005 (const dword)  (not used)
BREAK                              65533  0x0000fffd (const dword)  (not used)
BROWN                              41285  0x0000a145 (const dword)  (not used)
BTN_DOWN                               1  0x00000001 (const dword)  (not used)
BTN_UP                                 0  0x00000000 (const dword)  (usage 138)
BURLYWOOD                          56784  0x0000ddd0 (const dword)  (not used)
bus_ClearPins                       -119  0xffffff89 (PmmC func) args[1] r=0  (not used)
BUS_RD_PIN                             4  0x00000004 (const dword)  (not used)
bus_Read                            -117  0xffffff8b (PmmC func) args[0] r=1  (not used)
bus_Read8                           -122  0xffffff86 (PmmC func) args[0] r=1  (not used)
bus_SetChangeInterrupt              -120  0xffffff88 (PmmC func) args[2] r=1  (not used)
bus_SetPins                         -118  0xffffff8a (PmmC func) args[1] r=0  (not used)
BUS_WR_PIN                             3  0x00000003 (const dword)  (not used)
bus_Write8                          -121  0xffffff87 (PmmC func) args[1] r=0  (not used)
BUTTON_DOWN                            0  0x00000000 (const dword)  (not used)
BUTTON_UP                              1  0x00000001 (const dword)  (not used)
ByteSwap                             -49  0xffffffcf (PmmC func) args[1] r=1  (not used)
C:\Users\ebenton\Documents\CERDEC TS\CERDEC.4dg    2806  0x00000af6 (const ??? 0)  (not used)
CADETBLUE                          23796  0x00005cf4 (const dword)  (not used)
calc_mod_voltage                  UNRESOLVED (User func) args[1] r=0  (not used)
calc_shelf_voltage                   639  0x0000027f (User func) args[1] r=0  (usage 5)
calc_system_voltage                  693  0x000002b5 (User func) args[0] r=0  (usage 2)
calc_temperature                     603  0x0000025b (User func) args[1] r=0  (usage 2)
charheight                           -12  0xfffffff4 (PmmC func) args[1] r=1  (not used)
CHARTREUSE                         32736  0x00007fe0 (const dword)  (not used)
charwidth                            -11  0xfffffff5 (PmmC func) args[1] r=1  (not used)
check_press                          108  0x0000006c (User func) args[0] r=0  (usage 3)
CHECKED                                0  0x00000000 (const dword)  (not used)
CHOCOLATE                          54083  0x0000d343 (const dword)  (not used)
CHR                                  129  0x00000081 (const dword)  (not used)
CLIPPING                              19  0x00000013 (const dword)  (not used)
COLOUR16                               0  0x00000000 (const dword)  (not used)
COLOUR8                                1  0x00000001 (const dword)  (not used)
COM0                               63492  0x0000f804 (const dword)  (not used)
COM1                               63493  0x0000f805 (const dword)  (not used)
com1_Count                          -249  0xffffff07 (PmmC func) args[0] r=1  (usage 4)
com1_Error                          -257  0xfffffeff (PmmC func) args[0] r=1  (not used)
com1_Full                           -253  0xffffff03 (PmmC func) args[0] r=1  (not used)
com1_Init                           -233  0xffffff17 (PmmC func) args[3] r=0  (not used)
com1_InitBrk                        -578  0xfffffdbe (PmmC func) args[3] r=0  (not used)
com1_Reset                          -245  0xffffff0b (PmmC func) args[0] r=0  (not used)
COM1_RX_pin                         -226  0xffffff1e (PmmC func) args[1] r=1  (not used)
com1_RXblock                        -558  0xfffffdd2 (PmmC func) args[2] r=0  (not used)
com1_Sync                           -261  0xfffffefb (PmmC func) args[0] r=1  (not used)
COM1_TX_pin                         -229  0xffffff1b (PmmC func) args[1] r=1  (not used)
com1_TXblock                        -557  0xfffffdd3 (PmmC func) args[2] r=0  (not used)
com1_TXbuffer                       -265  0xfffffef7 (PmmC func) args[3] r=0  (not used)
com1_TXbufferBrk                    -574  0xfffffdc2 (PmmC func) args[3] r=0  (not used)
com1_TXbufferHold                   -277  0xfffffeeb (PmmC func) args[1] r=1  (not used)
com1_TXcount                        -269  0xfffffef3 (PmmC func) args[0] r=1  (not used)
com1_TXemptyEvent                   -273  0xfffffeef (PmmC func) args[1] r=1  (not used)
COM2                               63494  0x0000f806 (const dword)  (not used)
com2_Count                          -250  0xffffff06 (PmmC func) args[0] r=1  (not used)
com2_Error                          -258  0xfffffefe (PmmC func) args[0] r=1  (not used)
com2_Full                           -254  0xffffff02 (PmmC func) args[0] r=1  (not used)
com2_Init                           -234  0xffffff16 (PmmC func) args[3] r=0  (not used)
com2_InitBrk                        -579  0xfffffdbd (PmmC func) args[3] r=0  (not used)
com2_Reset                          -246  0xffffff0a (PmmC func) args[0] r=0  (not used)
COM2_RX_pin                         -227  0xffffff1d (PmmC func) args[1] r=1  (not used)
com2_RXblock                        -560  0xfffffdd0 (PmmC func) args[2] r=0  (not used)
com2_Sync                           -262  0xfffffefa (PmmC func) args[0] r=1  (not used)
COM2_TX_pin                         -230  0xffffff1a (PmmC func) args[1] r=1  (not used)
com2_TXblock                        -559  0xfffffdd1 (PmmC func) args[2] r=0  (not used)
com2_TXbuffer                       -266  0xfffffef6 (PmmC func) args[3] r=0  (not used)
com2_TXbufferBrk                    -575  0xfffffdc1 (PmmC func) args[3] r=0  (not used)
com2_TXbufferHold                   -278  0xfffffeea (PmmC func) args[1] r=1  (not used)
com2_TXcount                        -270  0xfffffef2 (PmmC func) args[0] r=1  (not used)
com2_TXemptyEvent                   -274  0xfffffeee (PmmC func) args[1] r=1  (not used)
COM3                               63495  0x0000f807 (const dword)  (not used)
com3_Count                          -251  0xffffff05 (PmmC func) args[0] r=1  (not used)
com3_Error                          -259  0xfffffefd (PmmC func) args[0] r=1  (not used)
com3_Full                           -255  0xffffff01 (PmmC func) args[0] r=1  (not used)
com3_Init                           -235  0xffffff15 (PmmC func) args[3] r=0  (not used)
com3_InitBrk                        -580  0xfffffdbc (PmmC func) args[3] r=0  (not used)
com3_Reset                          -247  0xffffff09 (PmmC func) args[0] r=0  (not used)
COM3_RX_pin                         -228  0xffffff1c (PmmC func) args[1] r=1  (not used)
com3_RXblock                        -562  0xfffffdce (PmmC func) args[2] r=0  (not used)
com3_Sync                           -263  0xfffffef9 (PmmC func) args[0] r=1  (not used)
COM3_TX_pin                         -231  0xffffff19 (PmmC func) args[1] r=1  (not used)
com3_TXblock                        -561  0xfffffdcf (PmmC func) args[2] r=0  (not used)
com3_TXbuffer                       -267  0xfffffef5 (PmmC func) args[3] r=0  (not used)
com3_TXbufferBrk                    -576  0xfffffdc0 (PmmC func) args[3] r=0  (not used)
com3_TXbufferHold                   -279  0xfffffee9 (PmmC func) args[1] r=1  (not used)
com3_TXcount                        -271  0xfffffef1 (PmmC func) args[0] r=1  (not used)
com3_TXemptyEvent                   -275  0xfffffeed (PmmC func) args[1] r=1  (not used)
com_Count                           -248  0xffffff08 (PmmC func) args[0] r=1  (not used)
com_Error                           -256  0xffffff00 (PmmC func) args[0] r=1  (not used)
com_Full                            -252  0xffffff04 (PmmC func) args[0] r=1  (not used)
com_Init                            -232  0xffffff18 (PmmC func) args[3] r=0  (not used)
com_InitBrk                         -577  0xfffffdbf (PmmC func) args[3] r=0  (not used)
com_Mode                            -280  0xfffffee8 (PmmC func) args[4] r=1  (not used)
com_Reset                           -244  0xffffff0c (PmmC func) args[0] r=0  (not used)
com_RXblock                         -282  0xfffffee6 (PmmC func) args[2] r=0  (not used)
com_SetBaud                         -225  0xffffff1f (PmmC func) args[2] r=1  (not used)
com_Sync                            -260  0xfffffefc (PmmC func) args[0] r=1  (not used)
com_TXblock                         -281  0xfffffee7 (PmmC func) args[2] r=0  (not used)
com_TXbuffer                        -264  0xfffffef8 (PmmC func) args[3] r=0  (not used)
com_TXbufferBrk                     -573  0xfffffdc3 (PmmC func) args[3] r=0  (not used)
com_TXbufferHold                    -276  0xfffffeec (PmmC func) args[1] r=1  (not used)
com_TXcount                         -268  0xfffffef4 (PmmC func) args[0] r=1  (not used)
com_TXemptyEvent                    -272  0xfffffef0 (PmmC func) args[1] r=1  (not used)
CONTRAST                              25  0x00000019 (const dword)  (not used)
CORAL                              64490  0x0000fbea (const dword)  (not used)
CORNFLOWERBLUE                     25789  0x000064bd (const dword)  (not used)
CORNSILK                           65499  0x0000ffdb (const dword)  (not used)
COS                                  -58  0xffffffc6 (PmmC func) args[1] r=1  (not used)
COUNT_EDGE                             3  0x00000003 (const dword)  (not used)
COUNT_FALL                             2  0x00000002 (const dword)  (not used)
COUNT_OFF                              0  0x00000000 (const dword)  (not used)
COUNT_RISE                             1  0x00000001 (const dword)  (not used)
crc_16                              -567  0xfffffdc9 (PmmC func) args[2] r=1  (not used)
crc_CCITT                           -569  0xfffffdc7 (PmmC func) args[3] r=1  (not used)
crc_CSUM_8                          -566  0xfffffdca (PmmC func) args[2] r=1  (not used)
crc_MODBUS                          -568  0xfffffdc8 (PmmC func) args[2] r=1  (not used)
CRIMSON                            55463  0x0000d8a7 (const dword)  (not used)
current_form                         246  0x000000f6 (mem) word (global)  (usage 19)
current_mod                          232  0x000000e8 (mem) word (global)  (usage 1)
CY                                   -64  0xffffffc0 (PmmC func) args[0] r=1  (not used)
CYAN                                2047  0x000007ff (const dword)  (not used)
DARKBLUE                              17  0x00000011 (const dword)  (not used)
DARKCYAN                            1105  0x00000451 (const dword)  (not used)
DARKGOLDENROD                      48161  0x0000bc21 (const dword)  (not used)
DARKGRAY                           44373  0x0000ad55 (const dword)  (not used)
DARKGREEN                            800  0x00000320 (const dword)  (not used)
DARKKHAKI                          48557  0x0000bdad (const dword)  (not used)
DARKMAGENTA                        34833  0x00008811 (const dword)  (not used)
DARKOLIVEGREEN                     21317  0x00005345 (const dword)  (not used)
DARKORANGE                         64608  0x0000fc60 (const dword)  (not used)
DARKORCHID                         39321  0x00009999 (const dword)  (not used)
DARKRED                            34816  0x00008800 (const dword)  (not used)
DARKSALMON                         60591  0x0000ecaf (const dword)  (not used)
DARKSEAGREEN                       36337  0x00008df1 (const dword)  (not used)
DARKSLATEBLUE                      18929  0x000049f1 (const dword)  (not used)
DARKSLATEGRAY                      10857  0x00002a69 (const dword)  (not used)
DARKTURQUOISE                       1658  0x0000067a (const dword)  (not used)
DARKVIOLET                         36890  0x0000901a (const dword)  (not used)
DEBUG_MODE                            64  0x00000040 (const dword)  (not used)
DEC                                 1290  0x0000050a (const dword)  (not used)
DEC1                                 266  0x0000010a (const dword)  (not used)
DEC1Z                               4362  0x0000110a (const dword)  (not used)
DEC1ZB                              8458  0x0000210a (const dword)  (not used)
DEC2                                 522  0x0000020a (const dword)  (not used)
DEC2Z                               4618  0x0000120a (const dword)  (not used)
DEC2ZB                              8714  0x0000220a (const dword)  (not used)
DEC3                                 778  0x0000030a (const dword)  (not used)
DEC3Z                               4874  0x0000130a (const dword)  (not used)
DEC3ZB                              8970  0x0000230a (const dword)  (not used)
DEC4                                1034  0x0000040a (const dword)  (not used)
DEC4Z                               5130  0x0000140a (const dword)  (not used)
DEC4ZB                              9226  0x0000240a (const dword)  (not used)
DEC5                                1290  0x0000050a (const dword)  (not used)
DEC5Z                               5386  0x0000150a (const dword)  (not used)
DEC5ZB                              9482  0x0000250a (const dword)  (not used)
DECZ                                5386  0x0000150a (const dword)  (not used)
DECZB                               9482  0x0000250a (const dword)  (not used)
DEEPPINK                           63666  0x0000f8b2 (const dword)  (not used)
DEEPSKYBLUE                         1535  0x000005ff (const dword)  (not used)
DIABLO                                 3  0x00000003 (const dword)  (usage 3)
DIMGRAY                            27469  0x00006b4d (const dword)  (not used)
DISABLE                                0  0x00000000 (const dword)  (not used)
disable_all_inputs                    94  0x0000005e (User func) args[0] r=0  (usage 6)
DISK_BUF                              15  0x0000000f (const dword)  (not used)
DISK_DATA_HI                           7  0x00000007 (const dword)  (not used)
DISK_DATA_LO                           6  0x00000006 (const dword)  (not used)
DISK_FAT_HI                            3  0x00000003 (const dword)  (not used)
DISK_FAT_LO                            2  0x00000002 (const dword)  (not used)
DISK_FATCOPIES                        12  0x0000000c (const dword)  (not used)
DISK_FATSIZE                          11  0x0000000b (const dword)  (not used)
DISK_FIRST_SECT_HI                     1  0x00000001 (const dword)  (not used)
DISK_FIRST_SECT_LO                     0  0x00000000 (const dword)  (not used)
DISK_MAXCLUS_HI                        9  0x00000009 (const dword)  (not used)
DISK_MAXCLUS_LO                        8  0x00000008 (const dword)  (not used)
DISK_MAXROOT                          10  0x0000000a (const dword)  (not used)
DISK_ROOT_HI                           5  0x00000005 (const dword)  (not used)
DISK_ROOT_LO                           4  0x00000004 (const dword)  (not used)
DISK_SECT_PER_CLUS                    13  0x0000000d (const dword)  (not used)
DISK_TYPE                             14  0x0000000e (const dword)  (not used)
disp_BlitPixelsFromCOM0             -372  0xfffffe8c (PmmC func) args[0] r=0  (not used)
disp_BlitPixelsFromCOM1             -563  0xfffffdcd (PmmC func) args[0] r=0  (not used)
disp_BlitPixelsFromCOM2             -564  0xfffffdcc (PmmC func) args[0] r=0  (not used)
disp_BlitPixelsFromCOM3             -565  0xfffffdcb (PmmC func) args[0] r=0  (not used)
disp_Disconnect                     -371  0xfffffe8d (PmmC func) args[0] r=0  (not used)
disp_Init                           -370  0xfffffe8e (PmmC func) args[0] r=0  (not used)
disp_ReadWord                       -367  0xfffffe91 (PmmC func) args[0] r=1  (not used)
disp_setGRAM                        -363  0xfffffe95 (PmmC func) args[4] r=0  (not used)
disp_SetReg                         -362  0xfffffe96 (PmmC func) args[2] r=0  (not used)
disp_Sync                           -369  0xfffffe8f (PmmC func) args[1] r=0  (not used)
disp_WrGRAM                         -364  0xfffffe94 (PmmC func) args[1] r=0  (not used)
disp_WriteControl                   -365  0xfffffe93 (PmmC func) args[1] r=0  (not used)
disp_WriteWord                      -366  0xfffffe92 (PmmC func) args[1] r=0  (not used)
DODGERBLUE                          7327  0x00001c9f (const dword)  (not used)
DOWN                                   0  0x00000000 (const dword)  (not used)
draw_bus_voltage                    4570  0x000011da (User func) args[0] r=0  (usage 3)
draw_capacitors_voltage             4506  0x0000119a (User func) args[0] r=0  (usage 3)
draw_estimated_runtime              4602  0x000011fa (User func) args[0] r=0  (usage 3)
draw_logo_screen                    4975  0x0000136f (User func) args[0] r=0  (usage 3)
draw_mod_alarm_leds                 2472  0x000009a8 (User func) args[1] r=0  (usage 3)
draw_mod_info_fields                2330  0x0000091a (User func) args[0] r=0  (usage 3)
draw_mod_labels                     2371  0x00000943 (User func) args[0] r=0  (usage 3)
draw_num_discharges                 4695  0x00001257 (User func) args[0] r=0  (usage 3)
draw_output_current                 4538  0x000011ba (User func) args[0] r=0  (usage 3)
draw_overall_form                   4877  0x0000130d (User func) args[0] r=0  (usage 6)
draw_overall_mods                   3037  0x00000bdd (User func) args[0] r=0  (usage 6)
draw_overall_side_buttons           4025  0x00000fb9 (User func) args[0] r=0  (usage 3)
draw_relay_status                   4762  0x0000129a (User func) args[0] r=0  (usage 3)
draw_relay_status_led               4436  0x00001154 (User func) args[0] r=0  (usage 3)
draw_shelf_alarm_leds               1141  0x00000475 (User func) args[0] r=0  (usage 3)
draw_shelf_alarms                   2861  0x00000b2d (User func) args[0] r=0  (usage 3)
draw_shelf_alarms_labels            1100  0x0000044c (User func) args[0] r=0  (usage 3)
draw_shelf_form                     2941  0x00000b7d (User func) args[0] r=0  (usage 3)
draw_shelf_mod_info                 2673  0x00000a71 (User func) args[1] r=0  (usage 3)
draw_shelf_module_buttons           1342  0x0000053e (User func) args[0] r=0  (usage 3)
draw_shelf_modules                  2746  0x00000aba (User func) args[0] r=0  (usage 3)
draw_shelf_readings                 2800  0x00000af0 (User func) args[0] r=0  (usage 3)
draw_shelf_readings_fields           903  0x00000387 (User func) args[0] r=0  (usage 3)
draw_shelf_readings_labels          1029  0x00000405 (User func) args[0] r=0  (usage 3)
draw_shelf_side_buttons              757  0x000002f5 (User func) args[0] r=0  (usage 3)
draw_shelf_system_status             902  0x00000386 (User func) args[0] r=0  (usage 3)
draw_stored_energy                  4664  0x00001238 (User func) args[0] r=0  (usage 3)
draw_system_mode                    4779  0x000012ab (User func) args[0] r=0  (usage 3)
draw_system_mode_labels             4176  0x00001050 (User func) args[0] r=0  (usage 3)
draw_system_mode_radios             4227  0x00001083 (User func) args[0] r=0  (usage 3)
draw_system_status                  4811  0x000012cb (User func) args[0] r=0  (usage 3)
draw_time_at_max                    4633  0x00001219 (User func) args[0] r=0  (usage 3)
DSK                                63490  0x0000f802 (const dword)  (not used)
ENABLE                                 1  0x00000001 (const dword)  (not used)
EVE_SP                               -65  0xffffffbf (PmmC func) args[0] r=1  (not used)
EVE_SSIZE                            -66  0xffffffbe (PmmC func) args[0] r=1  (not used)
EXTERN                               N/A         N/A (macro)  /**/   (not used)
FALSE                                  0  0x00000000 (const dword)  (usage 3)
FALSE_REASON                         141  0x0000008d (const dword)  (not used)
FCY_1                                 20  0x00000014 (const dword)  (not used)
FCY_256                               23  0x00000017 (const dword)  (not used)
FCY_64                                22  0x00000016 (const dword)  (not used)
FCY_8                                 21  0x00000015 (const dword)  (not used)
FE_CANNOT_INIT                        15  0x0000000f (const dword)  (not used)
FE_CANNOT_READ_MBR                    16  0x00000010 (const dword)  (not used)
FE_DIR_FULL                           12  0x0000000c (const dword)  (not used)
FE_DISK_FULL                          13  0x0000000d (const dword)  (not used)
FE_DISK_NOT_MNTD                       6  0x00000006 (const dword)  (not used)
FE_EOF                                10  0x0000000a (const dword)  (not used)
FE_FAT_EOF                             9  0x00000009 (const dword)  (not used)
FE_FILE_NOT_FOUND                      7  0x00000007 (const dword)  (not used)
FE_FILE_OVERWRITE                     14  0x0000000e (const dword)  (not used)
FE_FILE_TIMEOUT                       26  0x0000001a (const dword)  (not used)
FE_FIND_ERROR                         19  0x00000013 (const dword)  (not used)
FE_IDE_ERROR                           1  0x00000001 (const dword)  (not used)
FE_INVALID_BR                          5  0x00000005 (const dword)  (not used)
FE_INVALID_CLUSTER                    11  0x0000000b (const dword)  (not used)
FE_INVALID_FILE                        8  0x00000008 (const dword)  (not used)
FE_INVALID_FNAME                      20  0x00000014 (const dword)  (not used)
FE_INVALID_MBR                         4  0x00000004 (const dword)  (not used)
FE_INVALID_MEDIA                      21  0x00000015 (const dword)  (not used)
FE_INVALID_MODE                       18  0x00000012 (const dword)  (not used)
FE_MALLOC_FAILED                      17  0x00000011 (const dword)  (not used)
FE_NOT_PRESENT                         2  0x00000002 (const dword)  (not used)
FE_OK                                  0  0x00000000 (const dword)  (not used)
FE_PARTITION_TYPE                      3  0x00000003 (const dword)  (not used)
FE_SECTOR_READ_FAIL                   22  0x00000016 (const dword)  (not used)
FE_SECTOR_WRITE_FAIL                  23  0x00000017 (const dword)  (not used)
FILE_ATTRIBUTES                       18  0x00000012 (const dword)  (not used)
FILE_BUFFER                           22  0x00000016 (const dword)  (not used)
file_Close                          -431  0xfffffe51 (PmmC func) args[1] r=1  (not used)
file_Count                          -425  0xfffffe57 (PmmC func) args[1] r=1  (not used)
FILE_CURR_CLUSTER                      1  0x00000001 (const dword)  (not used)
FILE_CURR_SECTOR                       2  0x00000002 (const dword)  (not used)
FILE_CURR_SECTOR_POS                   3  0x00000003 (const dword)  (not used)
FILE_CURR_SECTOR_TOP                   4  0x00000004 (const dword)  (not used)
FILE_DATE                             10  0x0000000a (const dword)  (not used)
file_Dir                            -426  0xfffffe56 (PmmC func) args[1] r=1  (not used)
FILE_DISK                             21  0x00000015 (const dword)  (not used)
FILE_ENTRY                            20  0x00000014 (const dword)  (not used)
file_Erase                          -446  0xfffffe42 (PmmC func) args[1] r=1  (not used)
file_Error                          -424  0xfffffe58 (PmmC func) args[0] r=1  (not used)
file_Exec                           -450  0xfffffe3e (PmmC func) args[2] r=1  (not used)
file_Exists                         -429  0xfffffe53 (PmmC func) args[1] r=1  (not used)
file_FindFirst                      -427  0xfffffe55 (PmmC func) args[1] r=1  (not used)
file_FindNext                       -428  0xfffffe54 (PmmC func) args[0] r=1  (not used)
FILE_FIRST_CLUSTER                     0  0x00000000 (const dword)  (not used)
file_GetC                           -441  0xfffffe47 (PmmC func) args[1] r=1  (not used)
file_GetS                           -445  0xfffffe43 (PmmC func) args[3] r=1  (not used)
file_GetW                           -443  0xfffffe45 (PmmC func) args[1] r=1  (not used)
file_Image                          -438  0xfffffe4a (PmmC func) args[3] r=1  (not used)
file_Index                          -434  0xfffffe4e (PmmC func) args[4] r=1  (not used)
file_LoadFunction                   -448  0xfffffe40 (PmmC func) args[1] r=1  (not used)
file_LoadImageControl               -451  0xfffffe3d (PmmC func) args[3] r=1  (usage 3)
FILE_MODE                             17  0x00000011 (const dword)  (not used)
file_Mount                          -452  0xfffffe3c (PmmC func) args[0] r=1  (usage 6)
FILE_NAME                             11  0x0000000b (const dword)  (not used)
file_Open                           -430  0xfffffe52 (PmmC func) args[2] r=1  (not used)
FILE_PAGEFLAG                         19  0x00000013 (const dword)  (not used)
file_PlayWAV                        -454  0xfffffe3a (PmmC func) args[1] r=1  (not used)
file_PutC                           -440  0xfffffe48 (PmmC func) args[2] r=1  (not used)
file_PutS                           -444  0xfffffe44 (PmmC func) args[2] r=1  (not used)
file_PutW                           -442  0xfffffe46 (PmmC func) args[2] r=1  (not used)
file_Read                           -432  0xfffffe50 (PmmC func) args[3] r=1  (not used)
file_Rename                         -455  0xfffffe39 (PmmC func) args[2] r=1  (not used)
file_Rewind                         -447  0xfffffe41 (PmmC func) args[1] r=1  (not used)
file_Run                            -449  0xfffffe3f (PmmC func) args[2] r=1  (not used)
file_ScreenCapture                  -439  0xfffffe49 (PmmC func) args[5] r=1  (not used)
file_Seek                           -433  0xfffffe4f (PmmC func) args[3] r=1  (not used)
FILE_SEEK_POS_HI                       6  0x00000006 (const dword)  (not used)
FILE_SEEK_POS_LO                       5  0x00000005 (const dword)  (not used)
file_SetDate                        -456  0xfffffe38 (PmmC func) args[7] r=1  (not used)
file_Size                           -437  0xfffffe4b (PmmC func) args[3] r=1  (not used)
FILE_SIZE_HI                           8  0x00000008 (const dword)  (not used)
FILE_SIZE_LO                           7  0x00000007 (const dword)  (not used)
file_Tell                           -435  0xfffffe4d (PmmC func) args[3] r=1  (not used)
FILE_TIME                              9  0x00000009 (const dword)  (not used)
file_Unmount                        -453  0xfffffe3b (PmmC func) args[0] r=0  (not used)
file_Write                          -436  0xfffffe4c (PmmC func) args[3] r=1  (not used)
FILLPATTERN_0                      65504  0x0000ffe0 (const dword)  (not used)
FILLPATTERN_1                      65505  0x0000ffe1 (const ??? 0)  (not used)
FILLPATTERN_10                     65514  0x0000ffea (const ??? 0)  (not used)
FILLPATTERN_11                     65515  0x0000ffeb (const ??? 0)  (not used)
FILLPATTERN_12                     65516  0x0000ffec (const ??? 0)  (not used)
FILLPATTERN_13                     65517  0x0000ffed (const ??? 0)  (not used)
FILLPATTERN_14                     65518  0x0000ffee (const ??? 0)  (not used)
FILLPATTERN_15                     65519  0x0000ffef (const ??? 0)  (not used)
FILLPATTERN_16                     65520  0x0000fff0 (const ??? 0)  (not used)
FILLPATTERN_17                     65521  0x0000fff1 (const ??? 0)  (not used)
FILLPATTERN_18                     65522  0x0000fff2 (const ??? 0)  (not used)
FILLPATTERN_19                     65523  0x0000fff3 (const ??? 0)  (not used)
FILLPATTERN_2                      65506  0x0000ffe2 (const ??? 0)  (not used)
FILLPATTERN_20                     65524  0x0000fff4 (const ??? 0)  (not used)
FILLPATTERN_21                     65525  0x0000fff5 (const ??? 0)  (not used)
FILLPATTERN_22                     65526  0x0000fff6 (const ??? 0)  (not used)
FILLPATTERN_23                     65527  0x0000fff7 (const ??? 0)  (not used)
FILLPATTERN_24                     65528  0x0000fff8 (const ??? 0)  (not used)
FILLPATTERN_25                     65529  0x0000fff9 (const ??? 0)  (not used)
FILLPATTERN_26                     65530  0x0000fffa (const ??? 0)  (not used)
FILLPATTERN_27                     65531  0x0000fffb (const ??? 0)  (not used)
FILLPATTERN_28                     65532  0x0000fffc (const ??? 0)  (not used)
FILLPATTERN_29                     65533  0x0000fffd (const ??? 0)  (not used)
FILLPATTERN_3                      65507  0x0000ffe3 (const ??? 0)  (not used)
FILLPATTERN_30                     65534  0x0000fffe (const ??? 0)  (not used)
FILLPATTERN_31                     65535  0x0000ffff (const ??? 0)  (not used)
FILLPATTERN_4                      65508  0x0000ffe4 (const ??? 0)  (not used)
FILLPATTERN_5                      65509  0x0000ffe5 (const ??? 0)  (not used)
FILLPATTERN_6                      65510  0x0000ffe6 (const ??? 0)  (not used)
FILLPATTERN_7                      65511  0x0000ffe7 (const ??? 0)  (not used)
FILLPATTERN_8                      65512  0x0000ffe8 (const ??? 0)  (not used)
FILLPATTERN_9                      65513  0x0000ffe9 (const ??? 0)  (not used)
FIREBRICK                          45316  0x0000b104 (const dword)  (not used)
flash_Bank                          -498  0xfffffe0e (PmmC func) args[0] r=1  (not used)
flash_Blit1                         -507  0xfffffe05 (PmmC func) args[4] r=1  (not used)
flash_Blit16                        -503  0xfffffe09 (PmmC func) args[3] r=1  (not used)
flash_Blit2                         -506  0xfffffe06 (PmmC func) args[4] r=1  (not used)
flash_Blit4                         -505  0xfffffe07 (PmmC func) args[4] r=1  (not used)
flash_Blit8                         -504  0xfffffe08 (PmmC func) args[3] r=1  (not used)
flash_Copy                          -496  0xfffffe10 (PmmC func) args[4] r=1  (not used)
flash_EraseBank                     -499  0xfffffe0d (PmmC func) args[2] r=1  (not used)
flash_Exec                          -508  0xfffffe04 (PmmC func) args[2] r=1  (not used)
flash_GetByte                       -494  0xfffffe12 (PmmC func) args[2] r=1  (not used)
flash_GetWord                       -495  0xfffffe11 (PmmC func) args[2] r=1  (not used)
flash_LoadFile                      -500  0xfffffe0c (PmmC func) args[2] r=1  (not used)
flash_putstr                        -502  0xfffffe0a (PmmC func) args[2] r=1  (not used)
FLASH_READ_PROTECT                    16  0x00000010 (const dword)  (not used)
flash_Run                           -497  0xfffffe0f (PmmC func) args[1] r=1  (not used)
FLASH_WRITE_PROTECT                   32  0x00000020 (const dword)  (not used)
flash_WriteBlock                    -501  0xfffffe0b (PmmC func) args[3] r=1  (not used)
FLASHBANK_0                            0  0x00000000 (const dword)  (not used)
FLASHBANK_1                            1  0x00000001 (const dword)  (not used)
FLASHBANK_2                            2  0x00000002 (const dword)  (not used)
FLASHBANK_3                            3  0x00000003 (const dword)  (not used)
FLASHBANK_4                            4  0x00000004 (const dword)  (not used)
FLASHBANK_5                            5  0x00000005 (const dword)  (not used)
FLORALWHITE                        65502  0x0000ffde (const dword)  (not used)
flt_ABS                              -84  0xffffffac (PmmC func) args[2] r=1  (not used)
flt_ACOS                             -85  0xffffffab (PmmC func) args[2] r=1  (not used)
flt_ADD                              -97  0xffffff9f (PmmC func) args[3] r=1  (usage 3)
flt_ASIN                             -86  0xffffffaa (PmmC func) args[2] r=1  (not used)
flt_ATAN                             -87  0xffffffa9 (PmmC func) args[2] r=1  (not used)
flt_CEIL                             -90  0xffffffa6 (PmmC func) args[2] r=1  (not used)
flt_COS                              -88  0xffffffa8 (PmmC func) args[2] r=1  (not used)
flt_DIV                             -100  0xffffff9c (PmmC func) args[3] r=1  (not used)
flt_EQ                              -101  0xffffff9b (PmmC func) args[2] r=1  (not used)
flt_EXP                              -89  0xffffffa7 (PmmC func) args[2] r=1  (not used)
flt_FLOOR                            -91  0xffffffa5 (PmmC func) args[2] r=1  (not used)
flt_FTOI                            -108  0xffffff94 (PmmC func) args[1] r=1  (not used)
flt_GE                              -104  0xffffff98 (PmmC func) args[2] r=1  (not used)
flt_GT                              -103  0xffffff99 (PmmC func) args[2] r=1  (not used)
flt_ITOF                             -79  0xffffffb1 (PmmC func) args[2] r=1  (usage 8)
flt_LE                              -106  0xffffff96 (PmmC func) args[2] r=1  (not used)
flt_LOG                              -93  0xffffffa3 (PmmC func) args[2] r=1  (not used)
flt_LT                              -105  0xffffff97 (PmmC func) args[2] r=1  (not used)
flt_LTOF                             -81  0xffffffaf (PmmC func) args[2] r=1  (not used)
flt_MUL                              -99  0xffffff9d (PmmC func) args[3] r=1  (usage 8)
flt_NE                              -102  0xffffff9a (PmmC func) args[2] r=1  (not used)
flt_POW                              -96  0xffffffa0 (PmmC func) args[3] r=1  (not used)
flt_PRINT                            -83  0xffffffad (PmmC func) args[2] r=1  (usage 6)
flt_PRINTxy                         -109  0xffffff93 (PmmC func) args[4] r=1  (not used)
flt_SGN                             -107  0xffffff95 (PmmC func) args[1] r=1  (not used)
flt_SIN                              -92  0xffffffa4 (PmmC func) args[2] r=1  (not used)
flt_SQR                              -94  0xffffffa2 (PmmC func) args[2] r=1  (not used)
flt_SUB                              -98  0xffffff9e (PmmC func) args[3] r=1  (not used)
flt_TAN                              -95  0xffffffa1 (PmmC func) args[2] r=1  (not used)
flt_UITOF                            -80  0xffffffb0 (PmmC func) args[2] r=1  (not used)
flt_ULTOF                            -82  0xffffffae (PmmC func) args[2] r=1  (not used)
flt_VAL                              -78  0xffffffb2 (PmmC func) args[2] r=1  (usage 11)
FONT1                                  1  0x00000001 (const dword)  (not used)
FONT2                                  2  0x00000002 (const dword)  (not used)
FONT3                                  3  0x00000003 (const dword)  (not used)
FONT_1                                 1  0x00000001 (const dword)  (not used)
FONT_10                               10  0x0000000a (const dword)  (not used)
FONT_11                               11  0x0000000b (const dword)  (not used)
FONT_2                                 2  0x00000002 (const dword)  (not used)
FONT_3                                 3  0x00000003 (const dword)  (not used)
FONT_4                                 4  0x00000004 (const dword)  (not used)
FONT_5                                 5  0x00000005 (const dword)  (not used)
FONT_6                                 6  0x00000006 (const dword)  (not used)
FONT_7                                 7  0x00000007 (const dword)  (not used)
FONT_8                                 8  0x00000008 (const dword)  (not used)
FONT_9                                 9  0x00000009 (const dword)  (not used)
FONT_ID                                2  0x00000002 (const dword)  (not used)
FONT_SIZE                              2  0x00000002 (const dword)  (not used)
FORESTGREEN                         9284  0x00002444 (const dword)  (not used)
FRAME_DELAY                           22  0x00000016 (const dword)  (not used)
FUCHSIA                            63519  0x0000f81f (const dword)  (not used)
GAINSBORO                          57083  0x0000defb (const dword)  (not used)
Gen4_ULCD_70DT_DIABLO16_GFX            0  0x00000000 (const ??? 0)  (not used)
get_mods                             446  0x000001be (User func) args[2] r=0  (usage 2)
get_shelf                            596  0x00000254 (User func) args[1] r=0  (usage 5)
GFX                                63489  0x0000f801 (const dword)  (not used)
gfx_332to565                        -165  0xffffff5b (PmmC func) args[1] r=1  (not used)
gfx_565to332                        -166  0xffffff5a (PmmC func) args[1] r=1  (not used)
gfx_Arc                             -172  0xffffff54 (PmmC func) args[7] r=0  (not used)
gfx_BevelRadius                     -194  0xffffff3e (PmmC func) args[1] r=1  (not used)
gfx_BevelShadow                     -196  0xffffff3c (PmmC func) args[1] r=1  (not used)
gfx_BevelWidth                      -195  0xffffff3d (PmmC func) args[1] r=1  (not used)
gfx_BGcolour                        -184  0xffffff48 (PmmC func) args[1] r=1  (usage 9)
GFX_BOTTOM                            51  0x00000033 (const dword)  (not used)
gfx_BoxTo                           -149  0xffffff6b (PmmC func) args[2] r=0  (not used)
gfx_Bullet                          -146  0xffffff6e (PmmC func) args[1] r=0  (not used)
gfx_Button                          -155  0xffffff65 (PmmC func) args[9] r=1  (not used)
gfx_Button2                         -156  0xffffff64 (PmmC func) args[8] r=0  (not used)
gfx_Button3                         -157  0xffffff63 (PmmC func) args[8] r=0  (not used)
gfx_ChangeColour                    -151  0xffffff69 (PmmC func) args[2] r=0  (not used)
gfx_CheckBox                        -158  0xffffff62 (PmmC func) args[8] r=0  (not used)
gfx_Circle                          -136  0xffffff78 (PmmC func) args[4] r=0  (not used)
gfx_CircleFilled                    -137  0xffffff77 (PmmC func) args[4] r=0  (usage 81)
GFX_CLIP_BOTTOM                      114  0x00000072 (const dword)  (not used)
GFX_CLIP_BOTTOM_VAL                  110  0x0000006e (const dword)  (not used)
GFX_CLIP_LEFT                        111  0x0000006f (const dword)  (not used)
GFX_CLIP_LEFT_VAL                    107  0x0000006b (const dword)  (not used)
GFX_CLIP_RIGHT                       113  0x00000071 (const dword)  (not used)
GFX_CLIP_RIGHT_VAL                   109  0x0000006d (const dword)  (not used)
GFX_CLIP_TOP                         112  0x00000070 (const dword)  (not used)
GFX_CLIP_TOP_VAL                     108  0x0000006c (const dword)  (not used)
gfx_Clipping                        -186  0xffffff46 (PmmC func) args[1] r=1  (not used)
gfx_ClipWindow                      -150  0xffffff6a (PmmC func) args[4] r=0  (not used)
gfx_Cls                             -126  0xffffff82 (PmmC func) args[0] r=0  (usage 12)
gfx_Contrast                        -192  0xffffff40 (PmmC func) args[1] r=1  (not used)
gfx_Dot                             -145  0xffffff6f (PmmC func) args[0] r=0  (not used)
gfx_Ellipse                         -153  0xffffff67 (PmmC func) args[5] r=0  (not used)
gfx_EllipseFilled                   -154  0xffffff66 (PmmC func) args[5] r=0  (not used)
gfx_FillPattern                     -170  0xffffff56 (PmmC func) args[2] r=1  (not used)
gfx_FrameDelay                      -189  0xffffff43 (PmmC func) args[1] r=1  (not used)
gfx_Get                             -182  0xffffff4a (PmmC func) args[1] r=1  (not used)
gfx_GetPixel                        -139  0xffffff75 (PmmC func) args[2] r=1  (not used)
gfx_Gradient                        -176  0xffffff50 (PmmC func) args[7] r=0  (not used)
gfx_Hline                           -132  0xffffff7c (PmmC func) args[4] r=1  (not used)
gfx_IncX                            -147  0xffffff6d (PmmC func) args[0] r=1  (not used)
gfx_IncY                            -148  0xffffff6c (PmmC func) args[0] r=1  (not used)
GFX_LAST_CHAR_HEIGHT                 120  0x00000078 (const dword)  (not used)
GFX_LAST_CHAR_WIDTH                  119  0x00000077 (const dword)  (not used)
GFX_LAST_STR_HEIGHT                  122  0x0000007a (const dword)  (not used)
GFX_LAST_STR_WIDTH                   121  0x00000079 (const dword)  (not used)
GFX_LEFT                              48  0x00000030 (const dword)  (not used)
gfx_Line                            -131  0xffffff7d (PmmC func) args[5] r=0  (not used)
gfx_LinePattern                     -193  0xffffff3f (PmmC func) args[1] r=1  (not used)
gfx_LineRel                         -130  0xffffff7e (PmmC func) args[2] r=0  (not used)
gfx_LineTo                          -129  0xffffff7f (PmmC func) args[2] r=0  (not used)
gfx_MoveRel                         -128  0xffffff80 (PmmC func) args[2] r=0  (not used)
gfx_MoveTo                          -127  0xffffff81 (PmmC func) args[2] r=0  (usage 6)
gfx_ObjectColour                    -185  0xffffff47 (PmmC func) args[1] r=1  (not used)
gfx_Orbit                           -142  0xffffff72 (PmmC func) args[2] r=0  (not used)
gfx_OrbitInit                       -141  0xffffff73 (PmmC func) args[2] r=0  (not used)
gfx_Origin                          -169  0xffffff57 (PmmC func) args[2] r=0  (not used)
gfx_OutlineColour                   -191  0xffffff41 (PmmC func) args[1] r=1  (usage 24)
gfx_Panel                           -161  0xffffff5f (PmmC func) args[6] r=0  (usage 69)
gfx_PenSize                         -183  0xffffff49 (PmmC func) args[1] r=1  (not used)
gfx_PieSlice                        -171  0xffffff55 (PmmC func) args[9] r=0  (not used)
gfx_PointWithinBox                  -199  0xffffff39 (PmmC func) args[3] r=1  (not used)
gfx_PointWithinRectangle            -200  0xffffff38 (PmmC func) args[3] r=1  (not used)
gfx_Polygon                         -144  0xffffff70 (PmmC func) args[4] r=0  (not used)
gfx_PolygonFilled                   -168  0xffffff58 (PmmC func) args[4] r=0  (not used)
gfx_Polyline                        -143  0xffffff71 (PmmC func) args[4] r=0  (not used)
gfx_PutPixel                        -138  0xffffff76 (PmmC func) args[3] r=0  (not used)
gfx_RadioButton                     -159  0xffffff61 (PmmC func) args[8] r=0  (not used)
gfx_ReadBresLine                    -178  0xffffff4e (PmmC func) args[5] r=1  (not used)
gfx_ReadGRAMarea                    -180  0xffffff4c (PmmC func) args[5] r=1  (not used)
gfx_Rectangle                       -134  0xffffff7a (PmmC func) args[5] r=0  (not used)
gfx_RectangleFilled                 -135  0xffffff79 (PmmC func) args[5] r=0  (not used)
gfx_RGBto565                        -164  0xffffff5c (PmmC func) args[3] r=1  (not used)
GFX_RIGHT                             50  0x00000032 (const dword)  (not used)
gfx_RoundGradient                   -177  0xffffff4f (PmmC func) args[8] r=0  (not used)
gfx_RoundPanel                      -175  0xffffff51 (PmmC func) args[8] r=0  (not used)
gfx_RoundRect                       -173  0xffffff53 (PmmC func) args[6] r=0  (not used)
gfx_Scope                           -532  0xfffffdec (PmmC func) args[19] r=0  (not used)
gfx_ScreenCopyPaste                 -163  0xffffff5d (PmmC func) args[6] r=0  (not used)
gfx_ScreenMode                      -190  0xffffff42 (PmmC func) args[1] r=1  (not used)
gfx_Set                             -125  0xffffff83 (PmmC func) args[2] r=0  (usage 3)
gfx_SetClipRegion                   -152  0xffffff68 (PmmC func) args[0] r=0  (not used)
gfx_Slider                          -162  0xffffff5e (PmmC func) args[8] r=1  (not used)
gfx_Slider2                         -160  0xffffff60 (PmmC func) args[8] r=1  (not used)
gfx_Surround                        -174  0xffffff52 (PmmC func) args[7] r=0  (not used)
GFX_THUMB_BORDER_DARK                 76  0x0000004c (const dword)  (not used)
GFX_THUMB_BORDER_LIGHT                77  0x0000004d (const dword)  (not used)
GFX_THUMB_PERCENT                     75  0x0000004b (const dword)  (not used)
GFX_TOP                               49  0x00000031 (const dword)  (not used)
GFX_TOUCH_REGION_X1                  103  0x00000067 (const dword)  (not used)
GFX_TOUCH_REGION_X2                  105  0x00000069 (const dword)  (not used)
GFX_TOUCH_REGION_Y1                  104  0x00000068 (const dword)  (not used)
GFX_TOUCH_REGION_Y2                  106  0x0000006a (const dword)  (not used)
gfx_Transparency                    -188  0xffffff44 (PmmC func) args[1] r=1  (not used)
gfx_TransparentColour               -187  0xffffff45 (PmmC func) args[1] r=1  (not used)
gfx_Triangle                        -140  0xffffff74 (PmmC func) args[7] r=0  (not used)
gfx_TriangleFilled                  -167  0xffffff59 (PmmC func) args[7] r=0  (not used)
gfx_Vline                           -133  0xffffff7b (PmmC func) args[4] r=1  (not used)
gfx_WriteBresLine                   -179  0xffffff4d (PmmC func) args[5] r=0  (not used)
gfx_WriteGRAMarea                   -181  0xffffff4b (PmmC func) args[5] r=0  (not used)
GFX_X1                                52  0x00000034 (const dword)  (not used)
GFX_X2                                54  0x00000036 (const dword)  (not used)
GFX_X_ORG                             56  0x00000038 (const dword)  (not used)
GFX_XMAX                              46  0x0000002e (const dword)  (not used)
gfx_Xorigin                         -197  0xffffff3b (PmmC func) args[1] r=1  (not used)
GFX_Y1                                53  0x00000035 (const dword)  (not used)
GFX_Y2                                55  0x00000037 (const dword)  (not used)
GFX_Y_ORG                             57  0x00000039 (const dword)  (not used)
GFX_YMAX                              47  0x0000002f (const dword)  (not used)
gfx_Yorigin                         -198  0xffffff3a (PmmC func) args[1] r=1  (not used)
GHOSTWHITE                         65503  0x0000ffdf (const dword)  (not used)
GOLD                               65184  0x0000fea0 (const dword)  (not used)
GOLDENROD                          56612  0x0000dd24 (const dword)  (not used)
GRAD_DOWN                             32  0x00000020 (const dword)  (not used)
GRAD_LEFT                             80  0x00000050 (const dword)  (not used)
GRAD_RIGHT                            48  0x00000030 (const dword)  (not used)
GRAD_UP                               64  0x00000040 (const dword)  (not used)
GRAD_WAVE_HOR                        112  0x00000070 (const dword)  (not used)
GRAD_WAVE_VER                         96  0x00000060 (const dword)  (not used)
GRAM_PIXEL_COUNT_HI                  116  0x00000074 (const dword)  (not used)
GRAM_PIXEL_COUNT_LO                  115  0x00000073 (const dword)  (not used)
GRAY                               33808  0x00008410 (const dword)  (not used)
GREEN                               1024  0x00000400 (const dword)  (not used)
GREENYELLOW                        45029  0x0000afe5 (const dword)  (not used)
HEX                                 5136  0x00001410 (const dword)  (not used)
HEX1                                4368  0x00001110 (const dword)  (not used)
HEX1Z                                272  0x00000110 (const dword)  (not used)
HEX1ZB                              8464  0x00002110 (const dword)  (not used)
HEX2                                4624  0x00001210 (const dword)  (not used)
HEX2Z                                528  0x00000210 (const dword)  (not used)
HEX2ZB                              8720  0x00002210 (const dword)  (not used)
HEX3                                4880  0x00001310 (const dword)  (not used)
HEX3Z                                784  0x00000310 (const dword)  (not used)
HEX3ZB                              8976  0x00002310 (const dword)  (not used)
HEX4                                5136  0x00001410 (const dword)  (not used)
HEX4Z                               1040  0x00000410 (const dword)  (not used)
HEX4ZB                              9232  0x00002410 (const dword)  (not used)
HEXZ                                1040  0x00000410 (const dword)  (not used)
HEXZB                               9232  0x00002410 (const dword)  (not used)
HI                                     1  0x00000001 (const dword)  (not used)
HIbyte                               -48  0xffffffd0 (PmmC func) args[1] r=1  (not used)
HIDE                                   2  0x00000002 (const dword)  (not used)
hndl                                   0  0x00000000 (mem) word (global)  (usage 645)
HONEYDEW                           63486  0x0000f7fe (const dword)  (not used)
HOTPINK                            64342  0x0000fb56 (const dword)  (not used)
HYPER                                  3  0x00000003 (const dword)  (not used)
I2C1                               63520  0x0000f820 (const dword)  (not used)
I2C1_Ack                            -305  0xfffffecf (PmmC func) args[0] r=0  (not used)
I2C1_AckPoll                        -314  0xfffffec6 (PmmC func) args[1] r=1  (not used)
I2C1_AckStatus                      -311  0xfffffec9 (PmmC func) args[0] r=1  (not used)
I2C1_Close                          -287  0xfffffee1 (PmmC func) args[0] r=0  (not used)
I2C1_Getn                           -323  0xfffffebd (PmmC func) args[2] r=1  (not used)
I2C1_Gets                           -320  0xfffffec0 (PmmC func) args[2] r=1  (not used)
I2C1_Idle                           -317  0xfffffec3 (PmmC func) args[0] r=1  (not used)
I2C1_Nack                           -308  0xfffffecc (PmmC func) args[0] r=0  (not used)
I2C1_Open                           -284  0xfffffee4 (PmmC func) args[3] r=1  (not used)
I2C1_Putn                           -329  0xfffffeb7 (PmmC func) args[2] r=1  (not used)
I2C1_Puts                           -326  0xfffffeba (PmmC func) args[1] r=1  (not used)
I2C1_Read                           -299  0xfffffed5 (PmmC func) args[0] r=1  (not used)
I2C1_Restart                        -296  0xfffffed8 (PmmC func) args[0] r=1  (not used)
I2C1_Start                          -290  0xfffffede (PmmC func) args[0] r=1  (not used)
I2C1_Stop                           -293  0xfffffedb (PmmC func) args[0] r=1  (not used)
I2C1_Write                          -302  0xfffffed2 (PmmC func) args[1] r=1  (not used)
I2C2                               63521  0x0000f821 (const dword)  (not used)
I2C2_Ack                            -306  0xfffffece (PmmC func) args[0] r=0  (not used)
I2C2_AckPoll                        -315  0xfffffec5 (PmmC func) args[1] r=1  (not used)
I2C2_AckStatus                      -312  0xfffffec8 (PmmC func) args[0] r=1  (not used)
I2C2_Close                          -288  0xfffffee0 (PmmC func) args[0] r=0  (not used)
I2C2_Getn                           -324  0xfffffebc (PmmC func) args[2] r=1  (not used)
I2C2_Gets                           -321  0xfffffebf (PmmC func) args[2] r=1  (not used)
I2C2_Idle                           -318  0xfffffec2 (PmmC func) args[0] r=1  (not used)
I2C2_Nack                           -309  0xfffffecb (PmmC func) args[0] r=0  (not used)
I2C2_Open                           -285  0xfffffee3 (PmmC func) args[3] r=1  (not used)
I2C2_Putn                           -330  0xfffffeb6 (PmmC func) args[2] r=1  (not used)
I2C2_Puts                           -327  0xfffffeb9 (PmmC func) args[1] r=1  (not used)
I2C2_Read                           -300  0xfffffed4 (PmmC func) args[0] r=1  (not used)
I2C2_Restart                        -297  0xfffffed7 (PmmC func) args[0] r=1  (not used)
I2C2_Start                          -291  0xfffffedd (PmmC func) args[0] r=1  (not used)
I2C2_Stop                           -294  0xfffffeda (PmmC func) args[0] r=1  (not used)
I2C2_Write                          -303  0xfffffed1 (PmmC func) args[1] r=1  (not used)
I2C3                               63522  0x0000f822 (const dword)  (not used)
I2C3_Ack                            -307  0xfffffecd (PmmC func) args[0] r=0  (not used)
I2C3_AckPoll                        -316  0xfffffec4 (PmmC func) args[1] r=1  (not used)
I2C3_AckStatus                      -313  0xfffffec7 (PmmC func) args[0] r=1  (not used)
I2C3_Close                          -289  0xfffffedf (PmmC func) args[0] r=0  (not used)
I2C3_Getn                           -325  0xfffffebb (PmmC func) args[2] r=1  (not used)
I2C3_Gets                           -322  0xfffffebe (PmmC func) args[2] r=1  (not used)
I2C3_Idle                           -319  0xfffffec1 (PmmC func) args[0] r=1  (not used)
I2C3_Nack                           -310  0xfffffeca (PmmC func) args[0] r=0  (not used)
I2C3_Open                           -286  0xfffffee2 (PmmC func) args[3] r=1  (not used)
I2C3_Putn                           -331  0xfffffeb5 (PmmC func) args[2] r=1  (not used)
I2C3_Puts                           -328  0xfffffeb8 (PmmC func) args[1] r=1  (not used)
I2C3_Read                           -301  0xfffffed3 (PmmC func) args[0] r=1  (not used)
I2C3_Restart                        -298  0xfffffed6 (PmmC func) args[0] r=1  (not used)
I2C3_Start                          -292  0xfffffedc (PmmC func) args[0] r=1  (not used)
I2C3_Stop                           -295  0xfffffed9 (PmmC func) args[0] r=1  (not used)
I2C3_Write                          -304  0xfffffed0 (PmmC func) args[1] r=1  (not used)
I2C_10KHZ                              3  0x00000003 (const dword)  (not used)
I2C_20KHZ                              4  0x00000004 (const dword)  (not used)
I2C_250KHZ                             6  0x00000006 (const dword)  (not used)
I2C_50KHZ                              5  0x00000005 (const dword)  (not used)
I2C_FAST                               2  0x00000002 (const dword)  (not used)
I2C_MED                                1  0x00000001 (const dword)  (not used)
I2C_SLOW                               0  0x00000000 (const dword)  (not used)
I_COLOUR16                            16  0x00000010 (const dword)  (not used)
I_DARKEN                           16384  0x00004000 (const dword)  (not used)
I_ENABLED                          32768  0x00008000 (const dword)  (not used)
I_LIGHTEN                           8192  0x00002000 (const dword)  (not used)
I_MOVIE                              128  0x00000080 (const dword)  (not used)
I_NOGROUP                             64  0x00000040 (const dword)  (not used)
I_STAYONTOP                          256  0x00000100 (const dword)  (not used)
I_TOPMOST                            512  0x00000200 (const dword)  (not used)
I_TOUCH_DISABLE                       32  0x00000020 (const dword)  (usage 249)
I_TOUCHED                           4096  0x00001000 (const dword)  (not used)
I_X_LOCK                            1024  0x00000400 (const dword)  (not used)
I_Y_LOCK                            2048  0x00000800 (const dword)  (not used)
iBusVoltage_btn                        7  0x00000007 (const ??? 0)  (usage 3)
iCapacitorVoltage_Label                9  0x00000009 (const ??? 0)  (usage 3)
iCERDEC_Title                         14  0x0000000e (const ??? 0)  (usage 3)
ID                                     3  0x00000003 (const dword)  (usage 4)
iEmergencyStop_btn                    29  0x0000001d (const ??? 0)  (usage 18)
iEstimatedRuntime_Label                6  0x00000006 (const ??? 0)  (usage 3)
IMAGE_CLUSTER                         10  0x0000000a (const dword)  (not used)
IMAGE_DELAY                            7  0x00000007 (const dword)  (not used)
IMAGE_FLAGS                            6  0x00000006 (const dword)  (not used)
IMAGE_FRAMES                           8  0x00000008 (const dword)  (not used)
IMAGE_HEIGHT                           5  0x00000005 (const dword)  (not used)
IMAGE_HIWORD                           1  0x00000001 (const dword)  (not used)
IMAGE_INDEX                            9  0x00000009 (const dword)  (usage 138)
IMAGE_LOWORD                           0  0x00000000 (const dword)  (not used)
IMAGE_SECTOR                          11  0x0000000b (const dword)  (not used)
IMAGE_TAG                             12  0x0000000c (const dword)  (not used)
IMAGE_TAG2                            13  0x0000000d (const dword)  (not used)
IMAGE_WIDTH                            4  0x00000004 (const dword)  (not used)
IMAGE_XPOS                             2  0x00000002 (const dword)  (not used)
IMAGE_YPOS                             3  0x00000003 (const dword)  (not used)
iMainModule1Bad_btn                   92  0x0000005c (const ??? 0)  (usage 12)
iMainModule1Good_btn                  18  0x00000012 (const ??? 0)  (usage 12)
iMainModule2Bad_btn                   93  0x0000005d (const ??? 0)  (usage 12)
iMainModule2Good_btn                  17  0x00000011 (const ??? 0)  (usage 12)
iMainModule3Bad_btn                   94  0x0000005e (const ??? 0)  (usage 12)
iMainModule3Good_btn                  16  0x00000010 (const ??? 0)  (usage 12)
iMainModule4Bad_btn                   95  0x0000005f (const ??? 0)  (usage 12)
iMainModule4Good_btn                  19  0x00000013 (const ??? 0)  (usage 12)
iMainModule5Bad_btn                   96  0x00000060 (const ??? 0)  (usage 12)
iMainModule5Good_btn                  20  0x00000014 (const ??? 0)  (usage 12)
iMainModule6Bad_btn                   97  0x00000061 (const ??? 0)  (usage 12)
iMainModule6Good_btn                  21  0x00000015 (const ??? 0)  (usage 12)
iMainModule7Bad_btn                   98  0x00000062 (const ??? 0)  (usage 12)
iMainModule7Good_btn                  22  0x00000016 (const ??? 0)  (usage 12)
iMainModule8Bad_btn                   99  0x00000063 (const ??? 0)  (usage 12)
iMainModule8Good_btn                  23  0x00000017 (const ??? 0)  (usage 12)
iMainModule9Bad_btn                  100  0x00000064 (const ??? 0)  (usage 12)
iMainModule9Good_btn                  24  0x00000018 (const ??? 0)  (usage 12)
iMaxTime_Label                         5  0x00000005 (const ??? 0)  (usage 3)
img_ClearAttributes                 -383  0xfffffe81 (PmmC func) args[3] r=1  (usage 138)
IMG_COUNT                              0  0x00000000 (const dword)  (not used)
IMG_CURRENT_FRAME                     89  0x00000059 (const dword)  (not used)
img_Darken                          -377  0xfffffe87 (PmmC func) args[2] r=1  (not used)
IMG_DAT_FILENAME                       4  0x00000004 (const dword)  (not used)
img_Disable                         -376  0xfffffe88 (PmmC func) args[2] r=1  (not used)
img_Enable                          -375  0xfffffe89 (PmmC func) args[2] r=1  (not used)
IMG_ENTRYLEN                           1  0x00000001 (const dword)  (not used)
IMG_FLAGS                             85  0x00000055 (const dword)  (not used)
IMG_FRAME_COUNT                       86  0x00000056 (const dword)  (not used)
IMG_FRAME_DELAY                       84  0x00000054 (const dword)  (not used)
IMG_GCI_FILENAME                       3  0x00000003 (const dword)  (not used)
IMG_GCIFILE_HANDLE                     5  0x00000005 (const dword)  (not used)
img_GetWord                         -380  0xfffffe84 (PmmC func) args[3] r=1  (not used)
IMG_HEIGHT                            83  0x00000053 (const dword)  (not used)
img_Lighten                         -378  0xfffffe86 (PmmC func) args[2] r=1  (not used)
IMG_MODE                               2  0x00000002 (const dword)  (not used)
IMG_PIXEL_COUNT_HI                    88  0x00000058 (const dword)  (not used)
IMG_PIXEL_COUNT_LO                    87  0x00000057 (const dword)  (not used)
img_SelectReadPosition              -385  0xfffffe7f (PmmC func) args[5] r=1  (not used)
img_SequentialRead                  -386  0xfffffe7e (PmmC func) args[2] r=1  (not used)
img_SetAttributes                   -382  0xfffffe82 (PmmC func) args[3] r=1  (usage 111)
img_SetPosition                     -374  0xfffffe8a (PmmC func) args[4] r=1  (not used)
img_SetWord                         -379  0xfffffe85 (PmmC func) args[4] r=1  (usage 138)
img_Show                            -381  0xfffffe83 (PmmC func) args[2] r=1  (usage 252)
img_Touched                         -384  0xfffffe80 (PmmC func) args[2] r=1  (usage 3)
IMG_WIDTH                             82  0x00000052 (const dword)  (not used)
iModule1Bad_btn                       83  0x00000053 (const ??? 0)  (usage 12)
iModule1Good_btn                      42  0x0000002a (const ??? 0)  (usage 12)
iModule2Bad_btn                       88  0x00000058 (const ??? 0)  (usage 12)
iModule2Good_btn                      48  0x00000030 (const ??? 0)  (usage 12)
iModule3Bad_btn                       89  0x00000059 (const ??? 0)  (usage 12)
iModule3Good_btn                      51  0x00000033 (const ??? 0)  (usage 12)
iModule4Bad_btn                       84  0x00000054 (const ??? 0)  (usage 12)
iModule4Good_btn                      46  0x0000002e (const ??? 0)  (usage 12)
iModule5Bad_btn                       87  0x00000057 (const ??? 0)  (usage 12)
iModule5Good_btn                      49  0x00000031 (const ??? 0)  (usage 12)
iModule6Bad_btn                       90  0x0000005a (const ??? 0)  (usage 12)
iModule6Good_btn                      52  0x00000034 (const ??? 0)  (usage 12)
iModule7Bad_btn                       85  0x00000055 (const ??? 0)  (usage 12)
iModule7Good_btn                      47  0x0000002f (const ??? 0)  (usage 12)
iModule8Bad_btn                       86  0x00000056 (const ??? 0)  (usage 12)
iModule8Good_btn                      50  0x00000032 (const ??? 0)  (usage 12)
iModule9Bad_btn                       91  0x0000005b (const ??? 0)  (usage 12)
iModule9Good_btn                      53  0x00000035 (const ??? 0)  (usage 12)
iModuleError_Label                    64  0x00000040 (const ??? 0)  (usage 3)
iModuleID_Label                       40  0x00000028 (const ??? 0)  (usage 3)
iModuleNumber_Title                   65  0x00000041 (const ??? 0)  (usage 3)
iModuleOverCharged_Label              61  0x0000003d (const ??? 0)  (usage 3)
iModuleOverDischarged_Label           63  0x0000003f (const ??? 0)  (usage 3)
iModuleOverTemp_Label                 62  0x0000003e (const ??? 0)  (usage 3)
iModules_Title                        41  0x00000029 (const ??? 0)  (usage 3)
iModuleTemp_Label                     58  0x0000003a (const ??? 0)  (usage 3)
iModuleTemp_Units                     59  0x0000003b (const ??? 0)  (usage 3)
iModuleVoltage_Label                  57  0x00000039 (const ??? 0)  (usage 3)
iModuleVoltage_Unit                   60  0x0000003c (const ??? 0)  (usage 3)
INACTIVE                               0  0x00000000 (const dword)  (not used)
INDIANRED                          51947  0x0000caeb (const dword)  (not used)
INDIGO                             18448  0x00004810 (const dword)  (not used)
iNumberDischarges_Label                3  0x00000003 (const ??? 0)  (usage 3)
INVERSE                               64  0x00000040 (const dword)  (not used)
iOutputCurrent_Label                   8  0x00000008 (const ??? 0)  (usage 3)
iOverDischarged_Label                 34  0x00000022 (const ??? 0)  (usage 3)
iRelayState_Label                      2  0x00000002 (const ??? 0)  (usage 3)
iResetDischarges_btn                  11  0x0000000b (const ??? 0)  (usage 9)
iResetSystemStatus_btn                30  0x0000001e (const ??? 0)  (usage 9)
isalnum                              -41  0xffffffd7 (PmmC func) args[1] r=1  (not used)
isalpha                              -40  0xffffffd8 (PmmC func) args[1] r=1  (not used)
isdigit                              -36  0xffffffdc (PmmC func) args[1] r=1  (not used)
iShelf_btn                            15  0x0000000f (const ??? 0)  (usage 12)
iShelfAlarms_Title                    31  0x0000001f (const ??? 0)  (usage 3)
iShelfAverageTemp_Label               37  0x00000025 (const ??? 0)  (usage 3)
iShelfAverageTemp_Units               56  0x00000038 (const ??? 0)  (usage 3)
iShelfEmergencyStop_btn               66  0x00000042 (const ??? 0)  (not used)
iShelfError_Label                     35  0x00000023 (const ??? 0)  (usage 3)
iShelfMaxTemp_Label                   38  0x00000026 (const ??? 0)  (usage 3)
iShelfMinTemp_Label                   39  0x00000027 (const ??? 0)  (usage 3)
iShelfOverCharge_Label                32  0x00000020 (const ??? 0)  (usage 3)
iShelfOverTemp_Label                  33  0x00000021 (const ??? 0)  (usage 3)
iShelfReadings_Title                  36  0x00000024 (const ??? 0)  (usage 3)
iShelfStart_btn                       44  0x0000002c (const ??? 0)  (not used)
iShelfStop_btn                        43  0x0000002b (const ??? 0)  (not used)
iShelfSystemStatus_Title              67  0x00000043 (const ??? 0)  (not used)
iShelfToMain_btn                      45  0x0000002d (const ??? 0)  (usage 12)
iShelfTotalVoltage_Label              54  0x00000036 (const ??? 0)  (usage 3)
iShelfTotalVoltage_Units              55  0x00000037 (const ??? 0)  (usage 3)
islower                              -39  0xffffffd9 (PmmC func) args[1] r=1  (not used)
isprint                              -42  0xffffffd6 (PmmC func) args[1] r=1  (not used)
isspace                              -43  0xffffffd5 (PmmC func) args[1] r=1  (not used)
iStatictext10                         68  0x00000044 (const ??? 0)  (not used)
iStatictext11                         69  0x00000045 (const ??? 0)  (not used)
iStatictext12                         70  0x00000046 (const ??? 0)  (not used)
iStatictext13                         71  0x00000047 (const ??? 0)  (not used)
iStatictext14                         72  0x00000048 (const ??? 0)  (not used)
iStatictext15                         73  0x00000049 (const ??? 0)  (not used)
iStatictext16                         74  0x0000004a (const ??? 0)  (not used)
iStatictext17                         75  0x0000004b (const ??? 0)  (not used)
iStatictext18                         76  0x0000004c (const ??? 0)  (not used)
iStatictext19                         77  0x0000004d (const ??? 0)  (not used)
iStatictext20                         82  0x00000052 (const ??? 0)  (not used)
iStoredEnergy_Gauge                   12  0x0000000c (const ??? 0)  (not used)
iStoredEnergy_Label                    4  0x00000004 (const ??? 0)  (usage 3)
isupper                              -38  0xffffffda (PmmC func) args[1] r=1  (not used)
iswhite                              -44  0xffffffd4 (PmmC func) args[1] r=1  (not used)
isxdigit                             -37  0xffffffdb (PmmC func) args[1] r=1  (not used)
iSystemIdle_Label                     26  0x0000001a (const ??? 0)  (usage 3)
iSystemMode_Title                      1  0x00000001 (const ??? 0)  (usage 3)
iSystemOff_Label                      25  0x00000019 (const ??? 0)  (usage 3)
iSystemPower_Label                    28  0x0000001c (const ??? 0)  (usage 3)
iSystemStart_btn                      10  0x0000000a (const ??? 0)  (usage 18)
iSystemStatus_Title                    0  0x00000000 (const ??? 0)  (usage 3)
iSystemStop_btn                       13  0x0000000d (const ??? 0)  (usage 18)
iSystemVoltage_Label                  27  0x0000001b (const ??? 0)  (usage 3)
ITALIC                                32  0x00000020 (const dword)  (not used)
iterator                            -404  0xfffffe6c (PmmC func) args[1] r=0  (not used)
IVORY                              65534  0x0000fffe (const dword)  (not used)
iWinbutton18                          78  0x0000004e (const ??? 0)  (not used)
iWinbutton19                          79  0x0000004f (const ??? 0)  (not used)
iWinbutton20                          80  0x00000050 (const ??? 0)  (not used)
iWinbutton21                          81  0x00000051 (const ??? 0)  (not used)
KHAKI                              63281  0x0000f731 (const dword)  (not used)
LANDSCAPE                              0  0x00000000 (const dword)  (usage 3)
LANDSCAPE_R                            1  0x00000001 (const dword)  (not used)
LAVENDER                           59199  0x0000e73f (const dword)  (not used)
LAVENDERBLUSH                      65438  0x0000ff9e (const dword)  (not used)
LAWNGREEN                          32736  0x00007fe0 (const dword)  (not used)
LED_BAD                            63488  0x0000f800 (const dword)  (usage 27)
LED_GOOD                           13926  0x00003666 (const dword)  (usage 27)
LED_IDLE                           13535  0x000034df (const dword)  (not used)
LEFT_POS                               2  0x00000002 (const dword)  (not used)
LEMONCHIFFON                       65497  0x0000ffd9 (const dword)  (not used)
LIGHTBLUE                          44764  0x0000aedc (const dword)  (not used)
LIGHTCORAL                         62480  0x0000f410 (const dword)  (not used)
LIGHTCYAN                          59391  0x0000e7ff (const dword)  (not used)
LIGHTGOLD                          65498  0x0000ffda (const dword)  (not used)
LIGHTGREEN                         38770  0x00009772 (const dword)  (not used)
LIGHTGREY                          54938  0x0000d69a (const dword)  (not used)
LIGHTPINK                          64952  0x0000fdb8 (const dword)  (not used)
LIGHTSALMON                        64783  0x0000fd0f (const dword)  (not used)
LIGHTSEAGREEN                       9621  0x00002595 (const dword)  (not used)
LIGHTSKYBLUE                       34431  0x0000867f (const dword)  (not used)
LIGHTSLATEGRAY                     29779  0x00007453 (const dword)  (not used)
LIGHTSTEELBLUE                     46651  0x0000b63b (const dword)  (not used)
LIGHTYELLOW                        65532  0x0000fffc (const dword)  (not used)
LIME                                2016  0x000007e0 (const dword)  (not used)
LIMEGREEN                          13926  0x00003666 (const dword)  (usage 3)
LINE_PATTERN                          26  0x0000001a (const dword)  (not used)
LINEN                              65436  0x0000ff9c (const dword)  (not used)
LO                                     0  0x00000000 (const dword)  (not used)
LObyte                               -47  0xffffffd1 (PmmC func) args[1] r=1  (not used)
LOCAL                                N/A         N/A (macro) //   (not used)
LPCOARSE                           61680  0x0000f0f0 (const dword)  (not used)
LPDASHDOT                            975  0x000003cf (const dword)  (not used)
LPDASHDOTDOT                         819  0x00000333 (const dword)  (not used)
LPFINE                             43690  0x0000aaaa (const dword)  (not used)
LPMEDIUM                           13107  0x00003333 (const dword)  (not used)
LPSOLID                                0  0x00000000 (const dword)  (not used)
M_PA0                                  1  0x00000001 (const dword)  (not used)
M_PA1                                  2  0x00000002 (const dword)  (not used)
M_PA10                              1024  0x00000400 (const dword)  (not used)
M_PA11                              2048  0x00000800 (const dword)  (not used)
M_PA12                              4096  0x00001000 (const dword)  (not used)
M_PA13                              8192  0x00002000 (const dword)  (not used)
M_PA14                             16384  0x00004000 (const dword)  (not used)
M_PA15                             32768  0x00008000 (const dword)  (not used)
M_PA2                                  4  0x00000004 (const dword)  (not used)
M_PA3                                  8  0x00000008 (const dword)  (not used)
M_PA4                                 16  0x00000010 (const dword)  (not used)
M_PA5                                 32  0x00000020 (const dword)  (not used)
M_PA6                                 64  0x00000040 (const dword)  (not used)
M_PA7                                128  0x00000080 (const dword)  (not used)
M_PA8                                256  0x00000100 (const dword)  (not used)
M_PA9                                512  0x00000200 (const dword)  (not used)
MAGENTA                            63519  0x0000f81f (const dword)  (not used)
main                                5012  0x00001394 (User func) args[0] r=0  (not used)
MAROON                             32768  0x00008000 (const dword)  (not used)
MAX                                  -55  0xffffffc9 (PmmC func) args[2] r=1  (not used)
MDA                                63552  0x0000f840 (const dword)  (not used)
MEDIA_ADDRESS_HI                      91  0x0000005b (const dword)  (not used)
MEDIA_ADDRESS_LO                      90  0x0000005a (const dword)  (not used)
media_Flush                         -218  0xffffff26 (PmmC func) args[0] r=1  (not used)
media_Image                         -217  0xffffff27 (PmmC func) args[2] r=0  (not used)
media_Init                          -219  0xffffff25 (PmmC func) args[0] r=1  (not used)
media_RdSector                      -211  0xffffff2d (PmmC func) args[1] r=1  (not used)
media_ReadByte                      -213  0xffffff2b (PmmC func) args[0] r=1  (not used)
media_ReadWord                      -214  0xffffff2a (PmmC func) args[0] r=1  (not used)
MEDIA_SECTOR_COUNT                    94  0x0000005e (const dword)  (not used)
MEDIA_SECTOR_HI                       93  0x0000005d (const dword)  (not used)
MEDIA_SECTOR_LO                       92  0x0000005c (const dword)  (not used)
media_SetAdd                        -209  0xffffff2f (PmmC func) args[2] r=0  (not used)
media_SetSector                     -210  0xffffff2e (PmmC func) args[2] r=0  (not used)
media_Video                         -207  0xffffff31 (PmmC func) args[2] r=0  (not used)
media_VideoFrame                    -208  0xffffff30 (PmmC func) args[3] r=0  (not used)
media_WriteByte                     -215  0xffffff29 (PmmC func) args[1] r=1  (not used)
media_WriteWord                     -216  0xffffff28 (PmmC func) args[1] r=1  (not used)
media_WrSector                      -212  0xffffff2c (PmmC func) args[1] r=1  (not used)
MEDIUMAQUAMARINE                   26229  0x00006675 (const dword)  (not used)
MEDIUMBLUE                            25  0x00000019 (const dword)  (not used)
MEDIUMORCHID                       47802  0x0000baba (const dword)  (not used)
MEDIUMPURPLE                       37787  0x0000939b (const dword)  (not used)
MEDIUMSEAGREEN                     15758  0x00003d8e (const dword)  (not used)
MEDIUMSLATEBLUE                    31581  0x00007b5d (const dword)  (not used)
MEDIUMSPRINGGREEN                   2003  0x000007d3 (const dword)  (not used)
MEDIUMTURQUOISE                    20121  0x00004e99 (const dword)  (not used)
MEDIUMVIOLETRED                    49328  0x0000c0b0 (const dword)  (not used)
mem_Alloc                           -413  0xfffffe63 (PmmC func) args[1] r=1  (not used)
mem_AllocV                          -414  0xfffffe62 (PmmC func) args[1] r=1  (not used)
mem_AllocZ                          -415  0xfffffe61 (PmmC func) args[1] r=1  (not used)
mem_ArrayOp1                         -67  0xffffffbd (PmmC func) args[4] r=0  (not used)
mem_ArrayOp2                         -68  0xffffffbc (PmmC func) args[5] r=0  (not used)
mem_Compare                         -421  0xfffffe5b (PmmC func) args[3] r=1  (not used)
mem_Copy                            -420  0xfffffe5c (PmmC func) args[3] r=1  (not used)
mem_Free                            -417  0xfffffe5f (PmmC func) args[1] r=1  (not used)
mem_Heap                            -418  0xfffffe5e (PmmC func) args[0] r=1  (not used)
mem_Realloc                         -416  0xfffffe60 (PmmC func) args[2] r=1  (not used)
mem_Set                             -419  0xfffffe5d (PmmC func) args[3] r=1  (not used)
MIDI                                   9  0x00000009 (const dword)  (not used)
MIDNIGHTBLUE                        6350  0x000018ce (const dword)  (not used)
MIN                                  -54  0xffffffca (PmmC func) args[2] r=1  (not used)
MINTCREAM                          63487  0x0000f7ff (const dword)  (not used)
MISTYROSE                          65340  0x0000ff3c (const dword)  (not used)
MOCCASIN                           65334  0x0000ff36 (const dword)  (not used)
mod0                                  70  0x00000046 (mem) word[8] (global)  (usage 8)
mod1                                  86  0x00000056 (mem) word[8] (global)  (usage 8)
mod2                                 102  0x00000066 (mem) word[8] (global)  (usage 8)
mod3                                 118  0x00000076 (mem) word[8] (global)  (usage 8)
mod4                                 134  0x00000086 (mem) word[8] (global)  (usage 8)
mod5                                 150  0x00000096 (mem) word[8] (global)  (usage 8)
mod6                                 166  0x000000a6 (mem) word[8] (global)  (usage 8)
mod7                                 182  0x000000b6 (mem) word[8] (global)  (usage 8)
mod8                                 198  0x000000c6 (mem) word[8] (global)  (usage 8)
MOD_A                                  7  0x00000007 (const dword)  (usage 6)
MOD_FORM                               2  0x00000002 (const dword)  (usage 3)
mod_ptr_1                            234  0x000000ea (mem) word (global)  (usage 15)
mod_ptr_2                            236  0x000000ec (mem) word (global)  (usage 15)
MOD_T                                  6  0x00000006 (const dword)  (usage 6)
mod_temp                             242  0x000000f2 (mem) word[2] (global)Notice: global var 'mod_temp' is never used
  (not used)
MOD_V                                  4  0x00000004 (const dword)  (usage 12)
mod_volt                             238  0x000000ee (mem) word[2] (global)Notice: global var 'mod_volt' is never used
  (not used)
mods                                 214  0x000000d6 (mem) word[9] (global)  (usage 9)
NAVAJOWHITE                        65269  0x0000fef5 (const dword)  (not used)
NAVY                                  16  0x00000010 (const dword)  (not used)
NOTOUCH                                0  0x00000000 (const dword)  (not used)
NP_565                                 0  0x00000000 (const dword)  (not used)
NP_RGB                                 1  0x00000001 (const dword)  (not used)
NP_Write                            -535  0xfffffde9 (PmmC func) args[7] r=1  (not used)
NP_XRGB                                2  0x00000002 (const dword)  (not used)
NybleSwap                            -50  0xffffffce (PmmC func) args[1] r=1  (not used)
OBJECT_COLOUR                         18  0x00000012 (const dword)  (not used)
OFF                                    0  0x00000000 (const dword)  (not used)
OFFLINE                                1  0x00000001 (const dword)  (not used)
OLDLACE                            65468  0x0000ffbc (const dword)  (not used)
OLIVE                              33792  0x00008400 (const dword)  (not used)
OLIVEDRAB                          27748  0x00006c64 (const dword)  (not used)
ON                                     1  0x00000001 (const dword)  (not used)
ONLINE                                 0  0x00000000 (const dword)  (not used)
OP1_ADD                                5  0x00000005 (const dword)  (not used)
OP1_AND                                2  0x00000002 (const dword)  (not used)
OP1_BLACKEN                           16  0x00000010 (const dword)  (not used)
OP1_DARKEN                            18  0x00000012 (const dword)  (not used)
OP1_DIV                                8  0x00000008 (const dword)  (not used)
OP1_GRAY                              14  0x0000000e (const dword)  (not used)
OP1_IOR                                3  0x00000003 (const dword)  (not used)
OP1_LIGHTEN                           17  0x00000011 (const dword)  (not used)
OP1_MUL                                7  0x00000007 (const dword)  (not used)
OP1_NOP                                0  0x00000000 (const dword)  (not used)
OP1_REV                                9  0x00000009 (const dword)  (not used)
OP1_ROL                               12  0x0000000c (const dword)  (not used)
OP1_ROR                               13  0x0000000d (const dword)  (not used)
OP1_SET                                1  0x00000001 (const dword)  (not used)
OP1_SHL                               10  0x0000000a (const dword)  (not used)
OP1_SHR                               11  0x0000000b (const dword)  (not used)
OP1_SUB                                6  0x00000006 (const dword)  (not used)
OP1_WHITEN                            15  0x0000000f (const dword)  (not used)
OP1_XOR                                4  0x00000004 (const dword)  (not used)
OP2_ADD                                4  0x00000004 (const dword)  (not used)
OP2_AND                                1  0x00000001 (const dword)  (not used)
OP2_BLEND                              9  0x00000009 (const dword)  (not used)
OP2_COPY                               8  0x00000008 (const dword)  (not used)
OP2_DIV                                7  0x00000007 (const dword)  (not used)
OP2_IOR                                2  0x00000002 (const dword)  (not used)
OP2_MUL                                6  0x00000006 (const dword)  (not used)
OP2_SUB                                5  0x00000005 (const dword)  (not used)
OP2_XOR                                3  0x00000003 (const dword)  (not used)
OPAQUE                                 1  0x00000001 (const dword)  (not used)
ORANGE                             64800  0x0000fd20 (const dword)  (not used)
ORANGERED                          64032  0x0000fa20 (const dword)  (not used)
ORCHID                             56218  0x0000db9a (const dword)  (not used)
OUTLINE                                1  0x00000001 (const dword)  (not used)
OUTLINE_COLOUR                        24  0x00000018 (const dword)  (not used)
OVERVIEW_FORM                          0  0x00000000 (const dword)  (usage 9)
OVF                                  -63  0xffffffc1 (PmmC func) args[0] r=1  (not used)
OW_Read                             -523  0xfffffdf5 (PmmC func) args[1] r=1  (not used)
OW_Read9                            -524  0xfffffdf4 (PmmC func) args[1] r=1  (not used)
OW_Reset                            -522  0xfffffdf6 (PmmC func) args[1] r=1  (not used)
OW_Write                            -525  0xfffffdf3 (PmmC func) args[2] r=0  (not used)
PA0                                    1  0x00000001 (const dword)  (not used)
PA1                                    2  0x00000002 (const dword)  (not used)
PA10                                  11  0x0000000b (const dword)  (not used)
PA11                                  12  0x0000000c (const dword)  (not used)
PA12                                  13  0x0000000d (const dword)  (not used)
PA13                                  14  0x0000000e (const dword)  (not used)
PA14                                  15  0x0000000f (const dword)  (not used)
PA15                                  16  0x00000010 (const dword)  (not used)
PA2                                    3  0x00000003 (const dword)  (not used)
PA3                                    4  0x00000004 (const dword)  (not used)
PA4                                    5  0x00000005 (const dword)  (not used)
PA5                                    6  0x00000006 (const dword)  (not used)
PA6                                    7  0x00000007 (const dword)  (not used)
PA7                                    8  0x00000008 (const dword)  (not used)
PA8                                    9  0x00000009 (const dword)  (not used)
PA9                                   10  0x0000000a (const dword)  (not used)
PALEGOLDENROD                      61269  0x0000ef55 (const dword)  (not used)
PALEGREEN                          40915  0x00009fd3 (const dword)  (not used)
PALETURQUOISE                      44925  0x0000af7d (const dword)  (not used)
PALEVIOLETRED                      56210  0x0000db92 (const dword)  (not used)
PANEL_FRAME                            3  0x00000003 (const dword)  (not used)
PANEL_HIDE                             2  0x00000002 (const dword)  (not used)
PANEL_RAISED                           1  0x00000001 (const dword)  (usage 54)
PANEL_SUNKEN                           0  0x00000000 (const dword)  (usage 15)
PAPAYAWHIP                         65402  0x0000ff7a (const dword)  (not used)
pause                                 -6  0xfffffffa (PmmC func) args[1] r=0  (usage 11)
PEACHPUFF                          65239  0x0000fed7 (const dword)  (not used)
peekW                                -34  0xffffffde (PmmC func) args[1] r=1  (not used)
PEN_SIZE                              16  0x00000010 (const dword)  (not used)
PERU                               52263  0x0000cc27 (const dword)  (not used)
PIN_AN                                 5  0x00000005 (const dword)  (not used)
PIN_ANAVG                              6  0x00000006 (const dword)  (not used)
pin_Counter                         -514  0xfffffdfe (PmmC func) args[3] r=1  (not used)
PIN_COUNTER_PA4                      123  0x0000007b (const dword)  (not used)
PIN_COUNTER_PA5                      124  0x0000007c (const dword)  (not used)
PIN_COUNTER_PA6                      125  0x0000007d (const dword)  (not used)
PIN_COUNTER_PA7                      126  0x0000007e (const dword)  (not used)
PIN_COUNTER_PA8                      127  0x0000007f (const dword)  (not used)
PIN_COUNTER_PA9                      128  0x00000080 (const dword)  (not used)
PIN_EVENT_PA4                        129  0x00000081 (const dword)  (not used)
PIN_EVENT_PA5                        130  0x00000082 (const dword)  (not used)
PIN_EVENT_PA6                        131  0x00000083 (const dword)  (not used)
PIN_EVENT_PA7                        132  0x00000084 (const dword)  (not used)
PIN_EVENT_PA8                        133  0x00000085 (const dword)  (not used)
PIN_EVENT_PA9                        134  0x00000086 (const dword)  (not used)
pin_HI                              -113  0xffffff8f (PmmC func) args[1] r=1  (not used)
PIN_INP                                0  0x00000000 (const dword)  (not used)
PIN_INP_HI                             1  0x00000001 (const dword)  (not used)
PIN_INP_LO                             2  0x00000002 (const dword)  (not used)
pin_LO                              -114  0xffffff8e (PmmC func) args[1] r=1  (not used)
PIN_OUT                                3  0x00000003 (const dword)  (not used)
PIN_OUT_OD                             4  0x00000004 (const dword)  (not used)
pin_Pulseout                        -512  0xfffffe00 (PmmC func) args[2] r=1  (not used)
pin_PulseoutB                       -513  0xfffffdff (PmmC func) args[2] r=1  (not used)
pin_PulseoutCount                   -519  0xfffffdf9 (PmmC func) args[4] r=1  (not used)
pin_Read                            -116  0xffffff8c (PmmC func) args[1] r=1  (not used)
pin_Set                             -112  0xffffff90 (PmmC func) args[2] r=1  (not used)
pin_Val                             -115  0xffffff8d (PmmC func) args[2] r=0  (not used)
PINK                               65049  0x0000fe19 (const dword)  (not used)
PLUM                               56603  0x0000dd1b (const dword)  (not used)
pokeW                                -35  0xffffffdd (PmmC func) args[2] r=0  (not used)
PORTRAIT                               2  0x00000002 (const dword)  (not used)
PORTRAIT_R                             3  0x00000003 (const dword)  (not used)
POWDERBLUE                         46876  0x0000b71c (const dword)  (not used)
print_shelf_voltage               UNRESOLVED (User func) args[3] r=0  (not used)
print_system_voltage              UNRESOLVED (User func) args[2] r=0  (not used)
print_temperature                 UNRESOLVED (User func) args[3] r=0  (not used)
process_input                     UNRESOLVED (User func) args[0] r=0  (not used)
PROGRESSBAR_HIDE                       2  0x00000002 (const dword)  (not used)
PROGRESSBAR_RAISED                 65535  0x0000ffff (const dword)  (not used)
PROGRESSBAR_SUNKEN                 65534  0x0000fffe (const dword)  (not used)
PTN_BDIAGONAL                      65518  0x0000ffee (const ??? 0)  (not used)
PTN_BRICKS                         65521  0x0000fff1 (const ??? 0)  (not used)
PTN_BS_HORIZONTAL                  65510  0x0000ffe6 (const ??? 0)  (not used)
PTN_BS_VERTICAL                    65509  0x0000ffe5 (const ??? 0)  (not used)
PTN_BSHORIZONTAL                   65516  0x0000ffec (const ??? 0)  (not used)
PTN_BSVERTICAL                     65515  0x0000ffeb (const ??? 0)  (not used)
PTN_CARGONET                       65522  0x0000fff2 (const ??? 0)  (not used)
PTN_CIRCUITS                       65523  0x0000fff3 (const ??? 0)  (not used)
PTN_COBBLESTONES                   65524  0x0000fff4 (const ??? 0)  (not used)
PTN_COURSE_B_DIAGONAL              65512  0x0000ffe8 (const ??? 0)  (not used)
PTN_COURSE_CROSS                   65513  0x0000ffe9 (const ??? 0)  (not used)
PTN_COURSE_DIAGONALCROSS           65514  0x0000ffea (const ??? 0)  (not used)
PTN_COURSE_DOTS                    65508  0x0000ffe4 (const ??? 0)  (not used)
PTN_COURSE_F_DIAGONAL              65511  0x0000ffe7 (const ??? 0)  (not used)
PTN_CROSSES                        65535  0x0000ffff (const ??? 0)  (not used)
PTN_DAISIES                        65525  0x0000fff5 (const ??? 0)  (not used)
PTN_DIZZY                          65526  0x0000fff6 (const ??? 0)  (not used)
PTN_EMPTY                          65504  0x0000ffe0 (const dword)  (not used)
PTN_FDIAGONAL                      65517  0x0000ffed (const ??? 0)  (not used)
PTN_FIELDEFFECT                    65527  0x0000fff7 (const ??? 0)  (not used)
PTN_FINE_CROSS                     65519  0x0000ffef (const ??? 0)  (not used)
PTN_FINE_DIAGONAL_CROSS            65520  0x0000fff0 (const ??? 0)  (not used)
PTN_FINE_DOTS                      65506  0x0000ffe2 (const ??? 0)  (not used)
PTN_KEY                            65528  0x0000fff8 (const ??? 0)  (not used)
PTN_MEDIUM_DOTS                    65507  0x0000ffe3 (const ??? 0)  (not used)
PTN_ROUNDER                        65529  0x0000fff9 (const ??? 0)  (not used)
PTN_SCALES                         65530  0x0000fffa (const ??? 0)  (not used)
PTN_SOLID                          65505  0x0000ffe1 (const ??? 0)  (not used)
PTN_STONE                          65531  0x0000fffb (const ??? 0)  (not used)
PTN_THATCHES                       65532  0x0000fffc (const ??? 0)  (not used)
PTN_TILE                           65533  0x0000fffd (const ??? 0)  (not used)
PTN_WAFFLESREVENGE                 65534  0x0000fffe (const ??? 0)  (not used)
PURPLE                             32784  0x00008010 (const dword)  (not used)
putch                                 -2  0xfffffffe (PmmC func) args[1] r=0  (not used)
putchXY                               -3  0xfffffffd (PmmC func) args[3] r=0  (not used)
putnum                                -7  0xfffffff9 (PmmC func) args[2] r=1  (not used)
putnumXY                             -51  0xffffffcd (PmmC func) args[4] r=1  (not used)
putstr                                -9  0xfffffff7 (PmmC func) args[1] r=1  (usage 6)
putstrCentred                         -5  0xfffffffb (PmmC func) args[3] r=0  (not used)
putstrXY                              -4  0xfffffffc (PmmC func) args[3] r=0  (not used)
PWM_10KHZ                              6  0x00000006 (const dword)  (not used)
PWM_15KHZ                              7  0x00000007 (const dword)  (not used)
PWM_20KHZ                              8  0x00000008 (const dword)  (not used)
PWM_25KHZ                              9  0x00000009 (const dword)  (not used)
PWM_30KHZ                             10  0x0000000a (const dword)  (not used)
PWM_35KHZ                             11  0x0000000b (const dword)  (not used)
PWM_5KHZ                               5  0x00000005 (const dword)  (not used)
PWM_625HZ                              4  0x00000004 (const dword)  (not used)
PWM_BINARY                             3  0x00000003 (const dword)  (not used)
pwm_Init                            -521  0xfffffdf7 (PmmC func) args[3] r=1  (not used)
PWM_OFF                                0  0x00000000 (const dword)  (not used)
PWM_PLAIN                              1  0x00000001 (const dword)  (not used)
PWM_SERVO                              2  0x00000002 (const dword)  (not used)
QEN1_COUNTER_HI                      136  0x00000088 (const dword)  (not used)
QEN1_COUNTER_LO                      135  0x00000087 (const dword)  (not used)
QEN1_DELTA                           137  0x00000089 (const dword)  (not used)
QEN2_COUNTER_HI                      139  0x0000008b (const dword)  (not used)
QEN2_COUNTER_LO                      138  0x0000008a (const dword)  (not used)
QEN2_DELTA                           140  0x0000008c (const dword)  (not used)
Qencoder1                           -515  0xfffffdfd (PmmC func) args[3] r=1  (not used)
Qencoder1Reset                      -517  0xfffffdfb (PmmC func) args[0] r=0  (not used)
Qencoder2                           -516  0xfffffdfc (PmmC func) args[3] r=1  (not used)
Qencoder2Reset                      -518  0xfffffdfa (PmmC func) args[0] r=0  (not used)
RAND                                 -59  0xffffffc5 (PmmC func) args[0] r=1  (not used)
RANDOM_HI                             33  0x00000021 (const dword)  (not used)
RANDOM_LO                             32  0x00000020 (const dword)  (not used)
RANDVAL                              -60  0xffffffc4 (PmmC func) args[2] r=1  (not used)
RB_CHKD                                0  0x00000000 (const dword)  (usage 12)
RB_UNCHKD                          54937  0x0000d699 (const dword)  (usage 12)
RED                                63488  0x0000f800 (const dword)  (usage 3)
request_all_shelf_mods            UNRESOLVED (User func) args[1] r=0  (not used)
request_mod                          230  0x000000e6 (User func) args[2] r=0  (usage 2)
RIGHT_POS                              4  0x00000004 (const dword)  (not used)
ROSYBROWN                          48241  0x0000bc71 (const dword)  (not used)
ROYALBLUE                          17244  0x0000435c (const dword)  (not used)
RUNFLASH                             128  0x00000080 (const dword)  (not used)
SADDLEBROWN                        35362  0x00008a22 (const dword)  (not used)
SALMON                             64526  0x0000fc0e (const dword)  (not used)
SANDYBROWN                         62764  0x0000f52c (const dword)  (not used)
SAVE_TO_DISK                           7  0x00000007 (const dword)  (not used)
SCREEN_MODE                           23  0x00000017 (const dword)  (usage 3)
SEAGREEN                           11338  0x00002c4a (const dword)  (not used)
SEASHELL                           65469  0x0000ffbd (const dword)  (not used)
SEED                                 -61  0xffffffc3 (PmmC func) args[1] r=0  (not used)
serin                               -236  0xffffff14 (PmmC func) args[0] r=1  (not used)
serin1                              -237  0xffffff13 (PmmC func) args[0] r=1  (usage 6)
serin2                              -238  0xffffff12 (PmmC func) args[0] r=1  (not used)
serin3                              -239  0xffffff11 (PmmC func) args[0] r=1  (not used)
serout                              -240  0xffffff10 (PmmC func) args[1] r=0  (not used)
serout1                             -241  0xffffff0f (PmmC func) args[1] r=0  (usage 3)
serout2                             -242  0xffffff0e (PmmC func) args[1] r=0  (not used)
serout3                             -243  0xffffff0d (PmmC func) args[1] r=0  (not used)
set_mods                             323  0x00000143 (User func) args[1] r=0  (usage 2)
set_shelf                            488  0x000001e8 (User func) args[1] r=0  (usage 2)
setbaud                             -224  0xffffff20 (PmmC func) args[1] r=0  (not used)
shelf0                                34  0x00000022 (mem) word[13] (global)  (usage 6)
SHELF_A                                0  0x00000000 (const ??? 0)  (usage 3)
SHELF_E                                0  0x00000000 (const ??? 0)  (usage 3)
SHELF_FORM                             1  0x00000001 (const dword)  (usage 9)
SHELF_H                                0  0x00000000 (const ??? 0)  (usage 3)
SHELF_ID                               0  0x00000000 (const ??? 0)  (usage 3)
SHELF_L                                0  0x00000000 (const ??? 0)  (usage 3)
shelf_ptr                             60  0x0000003c (mem) word (global)  (usage 30)
SHELF_T                                0  0x00000000 (const ??? 0)  (usage 3)
shelf_temp                            66  0x00000042 (mem) word[2] (global)Notice: global var 'shelf_temp' is never used
  (not used)
SHELF_V                                0  0x00000000 (const ??? 0)  (usage 6)
shelf_volt                            62  0x0000003e (mem) word[2] (global)  (usage 6)
SIENNA                             41605  0x0000a285 (const dword)  (not used)
SILVER                             50712  0x0000c618 (const dword)  (usage 12)
SIN                                  -57  0xffffffc7 (PmmC func) args[1] r=1  (not used)
SKYBLUE                            34429  0x0000867d (const dword)  (not used)
SLATEBLUE                          27353  0x00006ad9 (const dword)  (not used)
SLATEGRAY                          29714  0x00007412 (const dword)  (not used)
SLIDER_HIDE                            2  0x00000002 (const dword)  (not used)
SLIDER_RAISED                          1  0x00000001 (const dword)  (not used)
SLIDER_SUNKEN                          0  0x00000000 (const dword)  (not used)
snd_BufSize                         -461  0xfffffe33 (PmmC func) args[1] r=0  (not used)
snd_Continue                        -464  0xfffffe30 (PmmC func) args[0] r=0  (not used)
snd_Freq                            -466  0xfffffe2e (PmmC func) args[2] r=1  (not used)
snd_Pause                           -463  0xfffffe31 (PmmC func) args[0] r=0  (not used)
snd_Pitch                           -460  0xfffffe34 (PmmC func) args[1] r=1  (not used)
snd_Playing                         -465  0xfffffe2f (PmmC func) args[0] r=1  (not used)
snd_Stop                            -462  0xfffffe32 (PmmC func) args[0] r=0  (not used)
snd_Volume                          -459  0xfffffe35 (PmmC func) args[1] r=0  (not used)
SNOW                               65503  0x0000ffdf (const dword)  (not used)
SOLID                                  0  0x00000000 (const dword)  (not used)
SPI1                                   1  0x00000001 (const dword)  (not used)
SPI16_MODE_0                           8  0x00000008 (const dword)  (not used)
SPI16_MODE_1                           9  0x00000009 (const dword)  (not used)
SPI16_MODE_2                          10  0x0000000a (const dword)  (not used)
SPI16_MODE_3                          11  0x0000000b (const dword)  (not used)
SPI16_MODE_4                          12  0x0000000c (const dword)  (not used)
SPI16_MODE_5                          13  0x0000000d (const dword)  (not used)
SPI16_MODE_6                          14  0x0000000e (const dword)  (not used)
SPI16_MODE_7                          15  0x0000000f (const dword)  (not used)
SPI1_Init                           -349  0xfffffea3 (PmmC func) args[2] r=1  (not used)
SPI1_Read                           -352  0xfffffea0 (PmmC func) args[0] r=1  (not used)
spi1_ReadBlock                      -333  0xfffffeb3 (PmmC func) args[2] r=0  (not used)
SPI1_SCK_pin                        -346  0xfffffea6 (PmmC func) args[1] r=1  (not used)
SPI1_SDI_pin                        -343  0xfffffea9 (PmmC func) args[1] r=1  (not used)
SPI1_SDO_pin                        -340  0xfffffeac (PmmC func) args[1] r=1  (not used)
SPI1_Write                          -355  0xfffffe9d (PmmC func) args[1] r=1  (not used)
spi1_WriteBlock                     -359  0xfffffe99 (PmmC func) args[2] r=0  (not used)
SPI2                                   2  0x00000002 (const dword)  (not used)
SPI2_Init                           -350  0xfffffea2 (PmmC func) args[2] r=1  (not used)
SPI2_Read                           -353  0xfffffe9f (PmmC func) args[0] r=1  (not used)
spi2_ReadBlock                      -334  0xfffffeb2 (PmmC func) args[2] r=0  (not used)
SPI2_SCK_pin                        -347  0xfffffea5 (PmmC func) args[1] r=1  (not used)
SPI2_SDI_pin                        -344  0xfffffea8 (PmmC func) args[1] r=1  (not used)
SPI2_SDO_pin                        -341  0xfffffeab (PmmC func) args[1] r=1  (not used)
SPI2_Write                          -356  0xfffffe9c (PmmC func) args[1] r=1  (not used)
spi2_WriteBlock                     -360  0xfffffe98 (PmmC func) args[2] r=0  (not used)
SPI3                                   3  0x00000003 (const dword)  (not used)
SPI3_Init                           -351  0xfffffea1 (PmmC func) args[2] r=1  (not used)
SPI3_Read                           -354  0xfffffe9e (PmmC func) args[0] r=1  (not used)
spi3_ReadBlock                      -335  0xfffffeb1 (PmmC func) args[2] r=0  (not used)
SPI3_SCK_pin                        -348  0xfffffea4 (PmmC func) args[1] r=1  (not used)
SPI3_SDI_pin                        -345  0xfffffea7 (PmmC func) args[1] r=1  (not used)
SPI3_SDO_pin                        -342  0xfffffeaa (PmmC func) args[1] r=1  (not used)
SPI3_Write                          -357  0xfffffe9b (PmmC func) args[1] r=1  (not used)
spi3_WriteBlock                     -361  0xfffffe97 (PmmC func) args[2] r=0  (not used)
SPI8_MODE_0                            0  0x00000000 (const dword)  (not used)
SPI8_MODE_1                            1  0x00000001 (const dword)  (not used)
SPI8_MODE_2                            2  0x00000002 (const dword)  (not used)
SPI8_MODE_3                            3  0x00000003 (const dword)  (not used)
SPI8_MODE_4                            4  0x00000004 (const dword)  (not used)
SPI8_MODE_5                            5  0x00000005 (const dword)  (not used)
SPI8_MODE_6                            6  0x00000006 (const dword)  (not used)
SPI8_MODE_7                            7  0x00000007 (const dword)  (not used)
spi_Disable                         -339  0xfffffead (PmmC func) args[0] r=0  (not used)
spi_Init                            -336  0xfffffeb0 (PmmC func) args[3] r=0  (not used)
spi_Read                            -337  0xfffffeaf (PmmC func) args[0] r=1  (not used)
spi_ReadBlock                       -332  0xfffffeb4 (PmmC func) args[2] r=0  (not used)
SPI_SPEED0                             0  0x00000000 (const dword)  (not used)
SPI_SPEED1                             1  0x00000001 (const dword)  (not used)
SPI_SPEED10                           10  0x0000000a (const dword)  (not used)
SPI_SPEED11                           11  0x0000000b (const dword)  (not used)
SPI_SPEED12                           12  0x0000000c (const dword)  (not used)
SPI_SPEED13                           13  0x0000000d (const dword)  (not used)
SPI_SPEED14                           14  0x0000000e (const dword)  (not used)
SPI_SPEED15                           15  0x0000000f (const dword)  (not used)
SPI_SPEED2                             2  0x00000002 (const dword)  (not used)
SPI_SPEED3                             3  0x00000003 (const dword)  (not used)
SPI_SPEED4                             4  0x00000004 (const dword)  (not used)
SPI_SPEED5                             5  0x00000005 (const dword)  (not used)
SPI_SPEED6                             6  0x00000006 (const dword)  (not used)
SPI_SPEED7                             7  0x00000007 (const dword)  (not used)
SPI_SPEED8                             8  0x00000008 (const dword)  (not used)
SPI_SPEED9                             9  0x00000009 (const dword)  (not used)
spi_Write                           -338  0xfffffeae (PmmC func) args[1] r=0  (not used)
spi_WriteBlock                      -358  0xfffffe9a (PmmC func) args[2] r=0  (not used)
spiflash_BlockErase                 -541  0xfffffde3 (PmmC func) args[3] r=0  (not used)
spiflash_BulkErase                  -540  0xfffffde4 (PmmC func) args[2] r=0  (not used)
spiflash_Exec                       -554  0xfffffdd6 (PmmC func) args[3] r=1  (not used)
spiflash_GetC                       -547  0xfffffddd (PmmC func) args[2] r=1  (not used)
spiflash_GetS                       -551  0xfffffdd9 (PmmC func) args[4] r=1  (not used)
spiflash_GetW                       -549  0xfffffddb (PmmC func) args[2] r=1  (not used)
spiflash_ID                         -539  0xfffffde5 (PmmC func) args[2] r=1  (not used)
spiflash_Image                      -545  0xfffffddf (PmmC func) args[4] r=1  (not used)
spiflash_LoadFunction               -552  0xfffffdd8 (PmmC func) args[2] r=1  (not used)
spiflash_LoadImageControl           -555  0xfffffdd5 (PmmC func) args[2] r=1  (not used)
spiflash_PlayWAV                    -556  0xfffffdd4 (PmmC func) args[2] r=1  (not used)
spiflash_PutC                       -546  0xfffffdde (PmmC func) args[3] r=0  (not used)
spiflash_PutS                       -550  0xfffffdda (PmmC func) args[3] r=1  (not used)
spiflash_PutW                       -548  0xfffffddc (PmmC func) args[3] r=0  (not used)
spiflash_Read                       -543  0xfffffde1 (PmmC func) args[4] r=1  (not used)
spiflash_Run                        -553  0xfffffdd7 (PmmC func) args[3] r=1  (not used)
spiflash_SetAdd                     -542  0xfffffde2 (PmmC func) args[3] r=0  (not used)
spiflash_SIG                        -538  0xfffffde6 (PmmC func) args[2] r=1  (not used)
spiflash_Write                      -544  0xfffffde0 (PmmC func) args[4] r=1  (not used)
SPRINGGREEN                         2031  0x000007ef (const dword)  (not used)
SQRT                                 -62  0xffffffc2 (PmmC func) args[1] r=1  (not used)
START_BYT                             24  0x00000018 (const dword)  (usage 2)
STEELBLUE                          17430  0x00004416 (const dword)  (not used)
STR                                  128  0x00000080 (const dword)  (not used)
str_ByteMove                        -487  0xfffffe19 (PmmC func) args[3] r=1  (not used)
str_Cat                             -485  0xfffffe1b (PmmC func) args[2] r=1  (not used)
str_CatN                            -486  0xfffffe1a (PmmC func) args[3] r=1  (not used)
str_Copy                            -488  0xfffffe18 (PmmC func) args[2] r=1  (not used)
str_CopyN                           -489  0xfffffe17 (PmmC func) args[3] r=1  (not used)
str_Find                            -481  0xfffffe1f (PmmC func) args[2] r=1  (not used)
str_FindI                           -482  0xfffffe1e (PmmC func) args[2] r=1  (not used)
str_GetByte                         -475  0xfffffe25 (PmmC func) args[1] r=1  (not used)
str_GetC                            -474  0xfffffe26 (PmmC func) args[2] r=1  (not used)
str_GetD                            -471  0xfffffe29 (PmmC func) args[2] r=1  (not used)
str_GetHexW                         -473  0xfffffe27 (PmmC func) args[2] r=1  (not used)
str_GetW                            -472  0xfffffe28 (PmmC func) args[2] r=1  (not used)
str_GetWord                         -476  0xfffffe24 (PmmC func) args[1] r=1  (not used)
str_Length                          -483  0xfffffe1d (PmmC func) args[1] r=1  (not used)
str_Match                           -479  0xfffffe21 (PmmC func) args[2] r=1  (not used)
str_MatchI                          -480  0xfffffe20 (PmmC func) args[2] r=1  (not used)
str_Printf                          -484  0xfffffe1c (PmmC func) args[2] r=1  (not used)
str_Ptr                             -470  0xfffffe2a (PmmC func) args[1] r=1  (not used)
str_PutByte                         -477  0xfffffe23 (PmmC func) args[2] r=0  (not used)
str_PutWord                         -478  0xfffffe22 (PmmC func) args[2] r=0  (not used)
strheight                            -14  0xfffffff2 (PmmC func) args[0] r=1  (not used)
strlen                               -10  0xfffffff6 (PmmC func) args[1] r=1  (not used)
strwidth                             -13  0xfffffff3 (PmmC func) args[1] r=1  (not used)
STYLE1                                 2  0x00000002 (const dword)  (not used)
STYLE2                                 3  0x00000003 (const dword)  (not used)
SWAP                                 -56  0xffffffc8 (PmmC func) args[2] r=0  (not used)
sys_DeepSleep                       -405  0xfffffe6b (PmmC func) args[1] r=1  (not used)
sys_Driver                          -531  0xfffffded (PmmC func) args[0] r=0  (not used)
sys_ErrorMessage                    -534  0xfffffdea (PmmC func) args[1] r=1  (not used)
sys_EventQueue                      -396  0xfffffe74 (PmmC func) args[0] r=1  (not used)
sys_EventsPostpone                  -397  0xfffffe73 (PmmC func) args[0] r=0  (not used)
sys_EventsResume                    -398  0xfffffe72 (PmmC func) args[0] r=0  (not used)
sys_GetDate                         -401  0xfffffe6f (PmmC func) args[0] r=0  (not used)
sys_GetDateVar                      -528  0xfffffdf0 (PmmC func) args[3] r=0  (not used)
sys_GetTime                         -399  0xfffffe71 (PmmC func) args[0] r=0  (not used)
sys_GetTimer                        -394  0xfffffe76 (PmmC func) args[1] r=1  (not used)
sys_GetTimeVar                      -529  0xfffffdef (PmmC func) args[4] r=0  (not used)
sys_PmmC                            -530  0xfffffdee (PmmC func) args[0] r=0  (not used)
sys_SetDate                         -402  0xfffffe6e (PmmC func) args[3] r=1  (not used)
sys_SetTime                         -400  0xfffffe70 (PmmC func) args[3] r=1  (not used)
sys_SetTimer                        -393  0xfffffe77 (PmmC func) args[2] r=0  (not used)
sys_SetTimerEvent                   -395  0xfffffe75 (PmmC func) args[2] r=1  (not used)
sys_Sleep                           -403  0xfffffe6d (PmmC func) args[1] r=1  (not used)
sys_StoreTouchCalibration           -368  0xfffffe90 (PmmC func) args[0] r=1  (not used)
sys_T                               -391  0xfffffe79 (PmmC func) args[0] r=1  (not used)
sys_T_HI                            -392  0xfffffe78 (PmmC func) args[0] r=1  (not used)
SYS_X_MAX                             44  0x0000002c (const dword)  (not used)
SYS_Y_MAX                             45  0x0000002d (const dword)  (not used)
system                                 2  0x00000002 (mem) word[16] (global)  (usage 15)
SYSTEM_TIMER_HI                       35  0x00000023 (const dword)  (not used)
SYSTEM_TIMER_LO                       34  0x00000022 (const dword)  (not used)
TAN                                54705  0x0000d5b1 (const dword)  (not used)
TB1                                  100  0x00000064 (const dword)  (not used)
TB2                                  101  0x00000065 (const dword)  (not used)
TB3                                  102  0x00000066 (const dword)  (not used)
TB4                                  103  0x00000067 (const dword)  (not used)
TEAL                                1040  0x00000410 (const dword)  (not used)
TEXT                               63489  0x0000f801 (const dword)  (not used)
TEXT_ANGLE                            15  0x0000000f (const dword)  (not used)
TEXT_ATTRIBUTES                       13  0x0000000d (const dword)  (not used)
TEXT_BACKGROUND                        1  0x00000001 (const dword)  (not used)
TEXT_BOLD                              9  0x00000009 (const dword)  (not used)
TEXT_COLOUR                            0  0x00000000 (const dword)  (not used)
TEXT_HEIGHT                            4  0x00000004 (const dword)  (not used)
TEXT_HIGHLIGHT                         1  0x00000001 (const dword)  (not used)
TEXT_INVERSE                          11  0x0000000b (const dword)  (not used)
TEXT_ITALIC                           10  0x0000000a (const dword)  (not used)
TEXT_MARGIN                           97  0x00000061 (const dword)  (not used)
TEXT_OPACITY                           8  0x00000008 (const dword)  (not used)
TEXT_PRINTDELAY                        7  0x00000007 (const dword)  (not used)
TEXT_UNDERLINED                       12  0x0000000c (const dword)  (not used)
TEXT_WIDTH                             3  0x00000003 (const dword)  (not used)
TEXT_WRAP                             14  0x0000000e (const dword)  (not used)
TEXT_XGAP                              5  0x00000005 (const dword)  (not used)
TEXT_XPOS                             95  0x0000005f (const dword)  (not used)
TEXT_YGAP                              6  0x00000006 (const dword)  (not used)
TEXT_YPOS                             96  0x00000060 (const dword)  (not used)
THISTLE                            56827  0x0000ddfb (const dword)  (not used)
TIMER0                                 0  0x00000000 (const dword)  (not used)
TIMER1                                 1  0x00000001 (const dword)  (not used)
TIMER2                                 2  0x00000002 (const dword)  (not used)
TIMER3                                 3  0x00000003 (const dword)  (not used)
TIMER4                                 4  0x00000004 (const dword)  (not used)
TIMER5                                 5  0x00000005 (const dword)  (not used)
TIMER6                                 6  0x00000006 (const dword)  (not used)
TIMER7                                 7  0x00000007 (const dword)  (not used)
TMR0                                  36  0x00000024 (const dword)  (not used)
TMR1                                  37  0x00000025 (const dword)  (not used)
TMR2                                  38  0x00000026 (const dword)  (not used)
TMR3                                  39  0x00000027 (const dword)  (not used)
TMR4                                  40  0x00000028 (const dword)  (not used)
TMR5                                  41  0x00000029 (const dword)  (not used)
TMR6                                  42  0x0000002a (const dword)  (not used)
TMR7                                  43  0x0000002b (const dword)  (not used)
to                                    -1  0xffffffff (PmmC func) args[1] r=0  (not used)
tolower                              -46  0xffffffd2 (PmmC func) args[1] r=1  (not used)
TOMATO                             64264  0x0000fb08 (const dword)  (not used)
TOP_POS                                3  0x00000003 (const dword)  (not used)
touch_DetectRegion                  -406  0xfffffe6a (PmmC func) args[4] r=0  (not used)
TOUCH_DISABLE                          1  0x00000001 (const dword)  (not used)
TOUCH_ENABLE                           0  0x00000000 (const dword)  (usage 3)
touch_Get                           -408  0xfffffe68 (PmmC func) args[1] r=1  (usage 9)
TOUCH_GETX                             1  0x00000001 (const dword)  (usage 3)
TOUCH_GETY                             2  0x00000002 (const dword)  (usage 3)
TOUCH_MOVING                           3  0x00000003 (const dword)  (not used)
TOUCH_PRESSED                          1  0x00000001 (const dword)  (not used)
TOUCH_RAW_X                          117  0x00000075 (const dword)  (not used)
TOUCH_RAW_Y                          118  0x00000076 (const dword)  (not used)
TOUCH_REGIONDEFAULT                    2  0x00000002 (const dword)  (not used)
TOUCH_RELEASED                         2  0x00000002 (const dword)  (usage 3)
touch_Set                           -407  0xfffffe69 (PmmC func) args[1] r=0  (usage 3)
TOUCH_STATUS                           0  0x00000000 (const dword)  (usage 3)
touch_TestArea                      -410  0xfffffe66 (PmmC func) args[1] r=1  (not used)
touch_TestBox                       -409  0xfffffe67 (PmmC func) args[1] r=1  (not used)
TOUCH_XMAXCAL                         80  0x00000050 (const dword)  (not used)
TOUCH_XMINCAL                         78  0x0000004e (const dword)  (not used)
TOUCH_YMAXCAL                         81  0x00000051 (const dword)  (not used)
TOUCH_YMINCAL                         79  0x0000004f (const dword)  (not used)
toupper                              -45  0xffffffd3 (PmmC func) args[1] r=1  (not used)
TRANSPARENCY                          21  0x00000015 (const dword)  (not used)
TRANSPARENT                            0  0x00000000 (const dword)  (not used)
TRANSPARENT_COLOUR                    20  0x00000014 (const dword)  (not used)
TRUE                                   1  0x00000001 (const dword)  (usage 3)
TURQUOISE                          18202  0x0000471a (const dword)  (not used)
txt_Angle                            -33  0xffffffdf (PmmC func) args[1] r=1  (not used)
txt_Attributes                       -31  0xffffffe1 (PmmC func) args[1] r=1  (not used)
txt_BGcolour                         -19  0xffffffed (PmmC func) args[1] r=1  (not used)
txt_Bold                             -27  0xffffffe5 (PmmC func) args[1] r=1  (not used)
txt_Delay                            -25  0xffffffe7 (PmmC func) args[1] r=1  (not used)
txt_FGcolour                         -18  0xffffffee (PmmC func) args[1] r=1  (not used)
TXT_FONT_HEIGHT                      102  0x00000066 (const dword)  (not used)
TXT_FONT_ID                           98  0x00000062 (const dword)  (not used)
TXT_FONT_MAX                          99  0x00000063 (const dword)  (not used)
TXT_FONT_OFFSET                      100  0x00000064 (const dword)  (not used)
TXT_FONT_WIDTH                       101  0x00000065 (const dword)  (not used)
txt_FontBank                         -52  0xffffffcc (PmmC func) args[2] r=1  (not used)
txt_FontID                           -20  0xffffffec (PmmC func) args[1] r=1  (not used)
txt_Height                           -22  0xffffffea (PmmC func) args[1] r=1  (not used)
txt_Inverse                          -29  0xffffffe3 (PmmC func) args[1] r=1  (not used)
txt_Italic                           -28  0xffffffe4 (PmmC func) args[1] r=1  (not used)
txt_MoveCursor                       -16  0xfffffff0 (PmmC func) args[2] r=0  (not used)
txt_Opacity                          -26  0xffffffe6 (PmmC func) args[1] r=1  (not used)
txt_Set                              -17  0xffffffef (PmmC func) args[2] r=0  (not used)
txt_Underline                        -30  0xffffffe2 (PmmC func) args[1] r=1  (not used)
txt_Width                            -21  0xffffffeb (PmmC func) args[1] r=1  (not used)
txt_Wrap                             -32  0xffffffe0 (PmmC func) args[1] r=1  (not used)
txt_Xgap                             -23  0xffffffe9 (PmmC func) args[1] r=1  (not used)
txt_Ygap                             -24  0xffffffe8 (PmmC func) args[1] r=1  (not used)
TYPE                                   2  0x00000002 (const dword)  (usage 6)
uadd_3232                            -71  0xffffffb9 (PmmC func) args[3] r=1  (not used)
ucmp_3232                            -75  0xffffffb5 (PmmC func) args[2] r=1  (not used)
UDEC                               17674  0x0000450a (const dword)  (not used)
UDEC1                              16650  0x0000410a (const dword)  (not used)
UDEC1Z                             20746  0x0000510a (const dword)  (not used)
UDEC1ZB                            24842  0x0000610a (const dword)  (not used)
UDEC2                              16906  0x0000420a (const dword)  (not used)
UDEC2Z                             21002  0x0000520a (const dword)  (not used)
UDEC2ZB                            25098  0x0000620a (const dword)  (not used)
UDEC3                              17162  0x0000430a (const dword)  (not used)
UDEC3Z                             21258  0x0000530a (const dword)  (not used)
UDEC3ZB                            25354  0x0000630a (const dword)  (not used)
UDEC4                              17418  0x0000440a (const dword)  (not used)
UDEC4Z                             21514  0x0000540a (const dword)  (not used)
UDEC4ZB                            25610  0x0000640a (const dword)  (not used)
UDEC5                              17674  0x0000450a (const dword)  (not used)
UDEC5Z                             21770  0x0000550a (const dword)  (not used)
UDEC5ZB                            25866  0x0000650a (const dword)  (not used)
UDECZ                              21770  0x0000550a (const dword)  (not used)
UDECZB                             25866  0x0000650a (const dword)  (not used)
udiv_3232                            -74  0xffffffb6 (PmmC func) args[3] r=1  (not used)
umul_1616                            -73  0xffffffb7 (PmmC func) args[3] r=1  (not used)
UNCHECKED                              1  0x00000001 (const dword)  (not used)
UNDERLINED                           128  0x00000080 (const dword)  (not used)
unicode_page                         -15  0xfffffff1 (PmmC func) args[3] r=1  (not used)
UP                                     1  0x00000001 (const dword)  (not used)
usub_3232                            -72  0xffffffb8 (PmmC func) args[3] r=1  (not used)
VIOLET                             60445  0x0000ec1d (const dword)  (not used)
volt_mod                          UNRESOLVED  (not used)
WHEAT                              63222  0x0000f6f6 (const dword)  (not used)
WHITE                              65535  0x0000ffff (const dword)  (usage 57)
WHITESMOKE                         63422  0x0000f7be (const dword)  (not used)
X_MAX                                  0  0x00000000 (const dword)  (not used)
X_ORG                                  6  0x00000006 (const dword)  (not used)
X_ORIGIN                              30  0x0000001e (const dword)  (not used)
Y_MAX                                  1  0x00000001 (const dword)  (not used)
Y_ORG                                  7  0x00000007 (const dword)  (not used)
Y_ORIGIN                              31  0x0000001f (const dword)  (not used)
YELLOW                             65504  0x0000ffe0 (const dword)  (not used)
YELLOWGREEN                        40550  0x00009e66 (const dword)  (not used)
